<!doctype html>
<html lang="en">
<head>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FC0XXR6EFQ"></script>
    <script>
      window.dataLayer = window.dataLayer || []
      function gtag(){dataLayer.push(arguments)}
      gtag("js", new Date())

      function kbGetOrCreateAnonUserId() {
        try {
          const k = "kb_anon_user_id_v1"
          const existing = localStorage.getItem(k)
          if (existing && existing.length > 6) return existing
          const id =
            (window.crypto && typeof window.crypto.randomUUID === "function")
              ? window.crypto.randomUUID()
              : ("kb-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16))
          localStorage.setItem(k, id)
          return id
        } catch (e) {
          return "kb-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16)
        }
      }

      window.KB_BUILD_VERSION = "0.1.239"
      const KB_GA_MEASUREMENT_ID = "G-FC0XXR6EFQ"
      const KB_ANON_USER_ID = kbGetOrCreateAnonUserId()

      gtag("config", KB_GA_MEASUREMENT_ID, {
        user_id: KB_ANON_USER_ID,
        send_page_view: true
      })

      window.KB_TELEMETRY = (function () {
        function safe(fn) {
          try { fn() } catch (e) {}
        }

        function ready() {
          return typeof window.gtag === "function"
        }

        function event(name, params) {
          safe(() => {
            if (!ready()) return
            const base = { kb_build_version: window.KB_BUILD_VERSION || "" }
            if (typeof name === "string" && name.indexOf("kb_") === 0) base.kb_anon_user_id = KB_ANON_USER_ID
            const p = Object.assign(base, params || {})
            window.gtag("event", name, p)
          })
        }

        function screen(name) {
          event("kb_screen_view", { kb_screen: name })
        }

        function sessionStart() {
          safe(() => {
            const k = "kb_session_started_v1"
            if (sessionStorage.getItem(k)) return
            sessionStorage.setItem(k, "1")
            event("kb_session_start", { kb_anon_user_id: KB_ANON_USER_ID })
          })
        }

        return {
          event,
          screen,
          sessionStart,
          uid: () => KB_ANON_USER_ID
        }
      })()

      try { window.KB_TELEMETRY.sessionStart() } catch (e) {}
    </script>
    <!-- KB_BUILD_VERSION: 0.1.239 -->
    <!--
      - 0.1.239 (2026-01-26): Screen 3 layout test. Update map slot to 640x640, keep the two right columns layout.
      - 0.1.238 (2026-01-26): Screen 3 layout test. Set map slot to 512x512, move game buttons under answers, and move account panes into a right-side column.
      - 0.1.237 (2026-01-25): Call KB_TELEMETRY.screen only from show*Screen functions.
      - 0.1.236 (2026-01-24): Attach kb_anon_user_id to all kb_* GA4 events.
CHANGELOG:
      - 0.1.235 (2026-01-24): Fix missing kbHealTiles wrapper and sync redemption store manifest expected hash.
      - 0.1.234 (2026-01-23): Add GA4 telemetry hooks (games, questions, rewards, redemptions) and persistent anonymous user ID.
      - 0.1.233 (2026-01-22): Update footer text across screens to 2025-2026 range, include viewing recommendation, and bump version.
      - 0.1.231 (2026-01-17): Reduce Leaflet tile seam artifacts and make footer version updates consistent across screens.
      - 0.1.226 (2026-01-17): Rename browser tab title to 'K-Bucks Demo'.
      - 0.1.225 (2025-12-27): Screen 2 wording, 'Available to Redeem' -> 'Available to redeem'.
      - 0.1.224 (2025-12-27): Restore Leaflet zoomSnap 0.2, zoomDelta 0.2, minZoom 2.2, and setView zoom 2.2. Fix footer version placeholders.
      - 0.1.223 (2025-12-27): Screen 1 wording, 'Child can earn' -> 'Available for the Child to earn'.
      - 0.1.222 (2025-12-27): Add K-Bucks/Hour (estimate) to Practice Times Tables spigot, keep version fields consistent.
      - 0.1.221 (2025-12-27): Restore Leaflet zoomSnap 0.2, zoomDelta 0.2, minZoom 2.2.
    -->
<meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>K-Bucks Demo</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>













    *, *::before, *::after { box-sizing: border-box; }

    * { box-sizing: border-box; }

    /* Hide number input spinners (Chrome, Safari, Edge) */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button{
      -webkit-appearance: none;
      margin: 0;
    }
    /* Hide number input spinners (Firefox) */
    input[type=number]{
      -moz-appearance: textfield;
      appearance: textfield;
    }

    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    :root{
      --kb-header-h: 27px;
      --kb-footer-h: 23px;
      --kb-main-w: 2142px;
      --kb-main-h: 1184px;
      --kb-side-w: 360px;
      --kb-gap: 18px;
    }
    .screen{
      width: calc(var(--kb-main-w) + var(--kb-side-w) + var(--kb-gap));
      margin: 0 auto;
    }

    .headerBar{
      height: var(--kb-header-h);
      display: flex;
      align-items: flex-start;
      padding: 0;
      margin: 0 0 10px;
    }

    .headerLine{
      display: flex;
      align-items: baseline;
      gap: 14px;
      width: 100%;
      font-size: 14px;
      white-space: nowrap;
      overflow: visible;
    }

    .screenTitle{
      font-size: 24px;
      line-height: 24px;
      font-weight: 700;
      margin-right: 0;

    }

    .storeMain{
      width: var(--kb-main-w);
      height: var(--kb-main-h);
    }

    .footerBar{
      height: var(--kb-footer-h);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 6px;
      font-size: 13px;
      color: #444;
    }
body { margin: 0; background: #f6f6f6; color: #111; overflow: hidden; }
    .wrap {  padding: 8px 20px;  }
    .title { font-size: 20px; margin: 0; }

    
    .topHeader{
      display: flex;
      align-items: baseline;
      justify-content: flex-start;
      gap: 10px;
      margin: 0 0 10px;
      flex-wrap: wrap;
    }
    .topStatus{
      display: flex;
      align-items: baseline;
      gap: 10px;
      flex-wrap: wrap;
    }
    

    

    .topStatus .scoreInline{
      width: auto;
      flex: 0 0 auto;
      margin-right: 0;
      text-align: left;
    }

    .scoreInline{
      width: auto;
      flex: 0 0 auto;
      margin-right: 0;
      text-align: left;
    }

    .scoreInline {
      font-size: 13px;
      color: #333;
      white-space: nowrap;
      width: 20ch;
      text-align: right;
      margin-right: 10px;
      flex: 0 0 20ch;
    }
.copyrightLine{
      width: 100%;
      text-align: center;
      margin-top: 6px;
      padding-bottom: 6px;
      color: #444;
    }
.layout {
      display: grid;
      grid-template-columns: var(--kb-main-w) var(--kb-side-w);
      gap: var(--kb-gap);
      align-items: stretch;
      height: var(--kb-main-h);
      width: calc(var(--kb-main-w) + var(--kb-side-w) + var(--kb-gap));
    }
#bingoSlot { width: var(--kb-main-w); height: var(--kb-main-h); }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    #mapSlot {
      position: relative;
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #e9eef5;
      width: 100%;
      height: 100%;
      min-height: 0;
      overflow: hidden;
    }
    /* Screen 3 layout experiment: 640x640 map slot and two right columns */
    #screenGame .layout.gameLayout.kbNtcLayout {
      grid-template-columns: 642px var(--kb-side-w) var(--kb-side-w);
      width: calc(642px + (2 * var(--kb-side-w)) + (2 * var(--kb-gap)));
      align-items: start;
    }

    #screenGame #mapSlot {
      width: 642px;
      height: 642px;
    }

    #screenGame .kbNtcSideLeft,
    #screenGame .kbNtcSideRight {
      height: var(--kb-main-h);
      overflow: auto;
    }



    /* Fix A: reduce Leaflet tile seam artifacts */
    #mapSlot img.leaflet-tile {
      outline: 1px solid transparent;
    }

    /* Double-buffered Leaflet map containers */
    .kbMapBuffer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      min-height: 0;
    }

    .kbMapFront {
      opacity: 1;
      pointer-events: auto;
      z-index: 2;
    }

    .kbMapBack {
      opacity: 0;
      pointer-events: none;
      z-index: 1;
    }

    #redeemPane {
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #fff;
      width: 100%;
      height: 100%;
      min-height: 0;
      padding: 14px;
      overflow: auto;
      display: block;
    }
    
    #bingoPane {
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: var(--kb-ocean-gray);
      width: 100%;
      height: 100%;
      min-height: 0;
      padding: 14px;
      overflow: hidden;
      display: block;
    }
#redeemPane .redeemHeader {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    #redeemPane h2 {
      margin: 0;
      font-size: 18px;
    }
    #redeemBalance {
      margin-top: 6px;
      color: #333;
      font-size: 16px;
      white-space: pre-wrap;
    }
    #redeemPaneMessage {
      margin-top: 8px;
      min-height: 18px;
      color: #333;
      font-size: 13px;
      white-space: pre-wrap;
    }

    

    /* Educational Content pane should match Redemption Store styling */
    /* Main-slot bottom nav, no extra scrollbars, D = 14px */
    #redeemPane, #eduPane{
      box-sizing: border-box;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #store, #eduList{
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
    }
    #redeemPane .storeList, #eduPane .storeList{
      margin-bottom: 0;
    }
    .controls.mainSlotNav{
      justify-content: flex-end;
      margin-top: 14px; /* D */
      margin-bottom: 0;
    }



    /* Reserve space so last card never sits under the nav button */
    /* Bottom-right navigation button inside main panes (D = 14px) */
    #eduPane {
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #fff;
      width: 100%;
      height: 100%;
      min-height: 0;
      padding: 14px;
      overflow: auto;
      display: block;
    }
    #eduPane .redeemHeader {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    #eduPane h2 {
      margin: 0;
      font-size: 18px;
    }
    #earnBalance {
      margin-top: 6px;
      color: #333;
      font-size: 16px;
      white-space: pre-wrap;
    }
    #eduPaneMessage {
      margin-top: 8px;
      min-height: 18px;
      color: #333;
      font-size: 13px;
      white-space: pre-wrap;
    }
#side {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: var(--kb-side-w);
      height: var(--kb-main-h);
      overflow: auto;
    }

    #bingoSide {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: var(--kb-side-w);
      height: var(--kb-main-h);
      overflow: auto;
    }

    /* Bingo quiz pane: do not reserve empty space below the button */
    #bingoQuizPane #bingoMessage { margin-top: 8px; min-height: 0; }
    #bingoQuizPane #bingoMessage:empty { display: none; }

    /* Bingo pair highlighting */
/* Answered pairs, green for correct, red for incorrect. Matches Select your answer colors. */
.bingoPairBtn.kbBingoDoneCorrect,
.bingoPairBtn.kbBingoDoneCorrect:hover,
.bingoPairBtn.kbBingoDoneCorrect:active,
.bingoPairBtn.kbBingoDoneCorrect:focus {
  background: #c8f3c8;
  border-color: #7bd47b;
  color: #222222;
}

.bingoPairBtn.kbBingoDoneWrong,
.bingoPairBtn.kbBingoDoneWrong:hover,
.bingoPairBtn.kbBingoDoneWrong:active,
.bingoPairBtn.kbBingoDoneWrong:focus {
  background: #f6c1c1;
  border-color: #e18a8a;
  color: #222222;
}

/* Current question pair: the only orange highlight */
.bingoPairBtn.kbBingoCurrent,
.bingoPairBtn.kbBingoCurrent:hover,
.bingoPairBtn.kbBingoCurrent:active,
.bingoPairBtn.kbBingoCurrent:focus {
  background: orange;
  border-color: rgba(199, 111, 0, 0.75);
  outline: none;
}
.pane {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 14px;
    }

    .paneHeader {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .pane h3 {
      margin: 0;
      font-size: 16px;
    }
    .pct { font-weight: 400; }
    .arrowDivider{
      display:flex;
      justify-content:flex-start;
      padding:0;
      margin:0;
      width: 100%;
    }

    .spigotPane{
  width: 100%;
  display:flex;
      box-sizing: border-box;
    
    
  padding: 8px;
}
.spigotInner{
  width: 100%;
  height: 100%;
  display:flex;
  flex-wrap: nowrap;
  gap: 10px;
  align-items: stretch;
}
.spigotImg{
  flex: 0 0 auto;
  height: 100%;
  max-height: 100%;
  max-width: 52%;
  width: auto;
  display:block;
  object-fit: contain;
  object-position: left bottom;
  align-self: flex-end;
}
.spigotText{
  flex: 1;
  min-width: 0;
  display:flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: flex-start;
  text-align: left;
}
.copyrightLine{
      width: 100%;
      text-align: center;
      margin-top: 6px;
      padding-bottom: 6px;
      color: #444;
    }
.answers { list-style: none; padding: 0; margin: 0; }
    .answers li { margin: 1px 0; }

    .ansBtn {
      width: 100%;
      text-align: left;
      border: 1px solid transparent;
      background: transparent;
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font: inherit;
      font-size: 15px;
          line-height: 1.2;
}
    .ansBtn:hover { background: #f3f3f3; }
    /* Ensure correctness highlighting overrides hover/press states immediately */
    .ansBtn.correct,
    .ansBtn.correct:hover,
    .ansBtn.correct:active,
    .ansBtn.correct:focus { background: #c8f3c8; border-color: #7bd47b; }

    .ansBtn.wrong,
    .ansBtn.wrong:hover,
    .ansBtn.wrong:active,
    .ansBtn.wrong:focus { background: #f6c1c1; border-color: #e18a8a; }

    /* Keep disabled answer buttons readable, but do not gray out correct or wrong */
    .ansBtn:disabled {
      color: #666;
      -webkit-text-fill-color: #666;
      opacity: 1;
      cursor: default;
    }
    .ansBtn.correct:disabled,
    .ansBtn.wrong:disabled {
      color: #111;
      -webkit-text-fill-color: #111;
      opacity: 1;
    }
    .ansBtn:disabled .label,
    .ansBtn:disabled .mark { color: inherit; -webkit-text-fill-color: inherit; }

    .bullet { width: 16px; text-align: center; color: #111; }
    .label { flex: 1; }
    .mark { width: 18px; text-align: center; font-weight: 700; }

    .correct { background: #c8f3c8; border-color: #7bd47b; }
    .wrong { background: #f6c1c1; border-color: #e18a8a; }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: flex-start;
      margin-top: 12px;
    }

    .controls button,
    .bottomBar button,
    .modal .controls button,
    .storeItem button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #888;
      background: #f7f7f7;
      cursor: pointer;
      white-space: nowrap;
    }

    .storeItem button:disabled { opacity: 0.45; cursor: not-allowed; }

    .controls button:disabled { opacity: 0.55; cursor: not-allowed; }

    .status {
      margin-top: 10px;
      min-height: 18px;
      color: #333;
      font-size: 13px;
      white-space: pre-wrap;
    }

    
    /* Quiz pane: do not reserve empty space below the button */
    #quizPane #message { margin-top: 8px; min-height: 0; }
    #quizPane #message:empty { display: none; }

.acctLine{
      margin-top: 6px;
      line-height: 1.35;
      font-size: 13px;
      color: #333;
      white-space: nowrap;
    }

    .kbHourLine{ color: #555; }

    .flowInput {
      width: 12ch;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #bbb;
      font: inherit;
      font-size: 13px;
      margin-left: 6px;
    }

    
    #sponsorMatchInput, #bingoSponsorMatchInput{ text-align: center; width: 2.2em; height: 2.2em; padding: 0; }
.moneyInput {
      width: 12.5ch;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #bbb;
      font: inherit;
      font-size: 13px;
      margin-left: 6px;
    }
    /* Empty-wallet highlight disabled for now
    .moneyInput.emptyWallet {
      background: #fffbe6;
    }
    */
    .bottomBar {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      align-items: center;
      padding: 14px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .overlay.show { display: flex; }

    .modal {
      background: #fff;
      border-radius: 10px;
      padding: 18px;
      max-width: 640px;
      width: 100%;
      border: 1px solid #ddd;
    }
    .modal h2 { margin: 0 0 8px; font-size: 18px; }
    .modal p { margin: 0 0 14px; color: #333; }

    .storeList { display: grid; gap: 8px; margin: 12px 0; }
    .storeItem {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: #fafafa;
    }
    .storeItem strong { font-weight: 600; }
  
  
    

.storeLeft{
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;
}
.storeThumb{
  width: 144px;
  height: 144px;
  border-radius: 10px;
  object-fit: contain;
  flex: 0 0 auto;
  border: 1px solid #ddd;
  background: #fff;
}
.storeMeta{ min-width: 0; }
.storePrice{ font-size: 16px; }

.eduFundsLine{ font-size: 12px; line-height: 1.25; color: #333; white-space: nowrap; }
.eduFundsSpacer{ height: 10px; }
.ansBtn { box-sizing: border-box; min-height: 38px; }
    .ansBtn .bullet { flex: 0 0 14px; width: 14px; }
    .ansBtn .mark { flex: 0 0 18px; width: 18px; text-align: right; }
    .ansBtn .label { flex: 1 1 auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

  
    .matchSuffix{
      margin-left: 6px;
      font-size: 13px;
      opacity: 0.9;
      white-space: nowrap;
    }

  
  
  
  
  
  



.spigotText .acctLine{ white-space: normal; overflow-wrap: anywhere; }


    /* Screen 1: pin Redemption Store button to bottom-right of the Main Slot */
    #eduPane{
      box-sizing: border-box;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #eduList{
      flex: 1 1 auto;
      min-height: 0;
    }
    #eduPane .controls.mainSlotNav{
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
      margin-bottom: 0;
    }


    /* Screen 2: redemption items list is non-scrollable (may truncate) */
    #screenStore #redeemPane {
      overflow: hidden;
    }
    #screenStore #store {
      overflow: visible;
    }


    

    
    
      /* padding-bottom is set dynamically in JS to (button height + D) */
    }
    #screenStore #redeemPane .controls.mainSlotNav{
      position: absolute;
      right: 0;            /* 0 from padding edge = D(14px) from border */
      bottom: 0;           /* 0 from padding edge = D(14px) from border */
      margin: 0;
      justify-content: flex-end;
    }


    
    /* Full list up: default .storeList margin-top is 12px, set to 0 */
    #screenStore #store .storeList{
      margin-top: 0;
      margin-bottom: 14px; /* Last item -> button */
    }
    /* Keep button in the normal flow, no extra gap above it */
    #screenStore #redeemPane .controls.mainSlotNav{
      position: static;
      margin-top: 0;
      margin-bottom: 0;
      justify-content: flex-end;
    }


    /* Screen 2: anchor Educational Content button like Screen 1 (flex bottom), list non-scrollable */
    #screenStore #redeemPane{
      box-sizing: border-box;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* list may truncate, no scrollbar */
    }
    #screenStore #store{
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden; /* non-scrollable, may truncate */
    }
    #screenStore #store .storeList{
      margin-top: 0; /* neutralized negative shift */
      margin-bottom: 0;
    }
    #screenStore #redeemPane .controls.mainSlotNav{
      margin-top: 14px;  /* D: list -> button */
      margin-bottom: 0;
      justify-content: flex-end;
    }



/* Screen 2: fit full redemption list without truncation, do not move header */
#screenStore #redeemPane{
  /* Keep header area unchanged */
  overflow: hidden; /* no scrollbar, everything must fit */
}
#screenStore #store{
  overflow: hidden; /* non-scrollable */
}
#screenStore #store .storeList{
  margin-top: 0;      /* was negative in prior experiments, causes top clipping */
  margin-bottom: 0;
  gap: 6px;           /* tighter vertical spacing */
}
#screenStore #store .storeItem{
  padding-top: 8px;   /* tighter item height */
  padding-bottom: 8px;
}
#screenStore #store .storeThumb{
  width: 140px;       /* slightly smaller thumbs to fit 6 items */
  height: 140px;
}



    /* Thumbnails: make images fit the thumb box cleanly */
    .storeThumb {
      overflow: hidden;
    }
    .storeThumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: center;
      display: block;
    }
    /* multiplication_table.png is designed to fill the thumb, so use cover */
    .storeThumb img[src*="multiplication_table.png"] {
      object-fit: cover;
    }

    :root{
      --kb-ocean-gray: #D4DADC; /* matches map background (ocean) */
      --kb-ocean-dark: #6A6D6E; /* 2x darker than ocean gray */
      --kb-map-white: #FAFAF8;  /* matches unselected countries */
    }

    /* Screen 4: Practice Times Tables grid */
    #bingoPane{
      background: var(--kb-ocean-gray);
    }
    #bingoGrid{
      height: 100%;
    }
    .bingoGrid{
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-auto-rows: 1fr;
      gap: 16px;
      align-items: stretch;
    
      background: var(--kb-ocean-gray);
    }
    .bingoCard{
      background: var(--kb-map-white);
      border-radius: 14px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    
      border: 1px solid var(--kb-ocean-gray);
    }
    .bingoCardHeader{
      background: var(--kb-map-white);
      color: #222222;
      text-align: center;
      font-weight: 700;
      font-size: 30px;
      min-height: 56px;
      padding: 12px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .bingoCardBody{
      padding: 0 14px 14px 14px;
      color: #111;
      display: flex;
      flex-direction: column;
      justify-content: space-evenly;
      flex: 1;
      min-height: 0;
    }

    .bingoPairBtn{
      width: 100%;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(106, 109, 110, 0.45);
      background: var(--kb-map-white);
      cursor: default;
      font-size: 24px;
      line-height: 1;
      min-height: 36px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      color: #222222;
    }
    .bingoPairBtn .bingoA{ justify-self: end; padding-right: 14px; }
    .bingoPairBtn .bingoX{ justify-self: center; }
    .bingoPairBtn .bingoB{ justify-self: start; padding-left: 14px; }

.bingoLine{
      width: 100%;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      white-space: nowrap;
    }
    .bingoA{
      justify-self: end;
      text-align: right;
      padding-right: 0.5ch;
    }
    .bingoX{
      justify-self: center;
      text-align: center;
    }
    .bingoB{
      justify-self: start;
      text-align: left;
      padding-left: 0.5ch;
    }


    .storeRating{
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
      font-size: 13px;
      line-height: 1.2;
      user-select: none;
    }
    .storeRating .ratingValue{
      font-weight: 400;
color: #111;
    }
    .storeRating .ratingStars{
      color: #f4b400;
      letter-spacing: 1px;
      font-size: 14px;
      transform: translateY(-0.5px);
    }
    .storeRating .ratingCaret{
      color: #777;
      font-size: 14px;
      transform: translateY(-0.5px);
    }
    .storeRating .ratingCount{
      color: #777;
      font-size: 13px;
    }


    .storeRating .ratingStarsBox{
      position: relative;
      display: inline-block;
      line-height: 1;
      vertical-align: middle;
    }
    .storeRating .starsBase{
      color: #d0d0d0;
      letter-spacing: 1px;
      font-size: 14px;
    }
    .storeRating .starsFill{
      position: absolute;
      left: 0;
      top: 0;
      overflow: hidden;
      white-space: nowrap;
      color: #f4b400;
      letter-spacing: 1px;
      font-size: 14px;
    }

</style>
</head>

<body>
  <div class="wrap">
    <div id="screenGame" class="screen" style="display:none;">
            <div class="headerBar">
        <div class="topHeader">
          <p class="title">Name That Country</p>
          <div class="topStatus" aria-live="polite">
            <div class="scoreInline" id="progress">Progress: 0/0</div>
            <div class="scoreInline" id="status">Score: 0/0 (0%)</div>
            <div class="scoreInline" id="timer">Time: 00:00:00</div>
          </div>
        </div>
      </div>
<div class="layout gameLayout kbNtcLayout">
        <div id="mapSlot">
          <div class="kbMapBuffer kbMapFront" id="mapA"></div>
          <div class="kbMapBuffer kbMapBack" id="mapB"></div>
        </div>

<div id="side" class="side kbNtcSideLeft">
        <div class="pane" id="quizPane">
          <div class="paneHeader">
            <h3>Select your answer:</h3>
</div>

          <ul class="answers" id="answers"></ul>

          <div class="status" id="message"></div>

          <div class="controls">
            <button id="nextBtn" disabled type="button">Next question</button>
          </div>

        </div>

        <div class="bottomBar">
          <button id="quitBtn" type="button" disabled>Practice misses</button>
          <button id="startNewBtn" type="button">New game</button>
          <button id="redeemBtn" type="button">Quit game</button>
        </div>
      </div>

<div id="ntcAccounts" class="side kbNtcSideRight">
<div class="pane">
          <h3>Parent</h3>
          <div class="acctLine">
            K-Bucks:
            <input id="parentInput" class="moneyInput" type="text" inputmode="decimal" min="0" step="0.01" value="0.00" />
          </div>
          <div class="acctLine">
            Flow rate (K-Bucks per correct answer):
            <input id="flowRateInput" class="flowInput moneyInput" type="text" inputmode="decimal" min="0" step="any" value="0.00" />
          </div>
        </div>

        <div class="pane">
          <h3>Education Sponsors</h3>
          <div class="acctLine">
            K-Bucks:
            <input id="sponsorInput" class="moneyInput" type="text" inputmode="decimal" min="0" step="any" value="0.00" />
          </div>
          <div class="acctLine">
            Parent : Sponsors match ratio (3 ≤ x ≤ 7):
            <input id="sponsorMatchInput" class="flowInput" type="number" min="3" max="7" step="any" value="5" /><span class="matchSuffix"> : 1</span></div>
      </div>

        

        
        <div class="arrowDivider" aria-hidden="true"><div id="spigotPane" class="pane spigotPane">
          <div class="spigotInner">
            <img class="spigotImg" src="spigot.png?v=3" alt="" />
            <div class="spigotText">
              <div class="acctLine">Flow rate (K-Bucks, Parent + Sponsors): <span id="spigotFlowRateOut">0.00</span></div>
              <div class="acctLine kbHourLine">K-Bucks/Hour (estimate): <span id="spigotKbucksPerHourOut">0.00</span></div>
            </div>
          </div>
        </div></div>

        <div class="pane" id="childPane">
          <h3>Child <span class="pct">(75%)</span></h3>
          <div class="acctLine" id="childAcct">K-Bucks: 0.00000</div>
        </div>

        <div class="pane">
          <h3>Content Developer <span class="pct">(12.5%)</span></h3>
          <div class="acctLine" id="devAcct">K-Bucks: 0.00000</div>
        </div>


        <div class="pane">
          <h3>K-Bucks Platform <span class="pct">(12.5%)</span></h3>
          <div class="acctLine" id="platformAcct">K-Bucks: 0.00000</div>
          <div class="acctLine" id="platformInfo"></div>
        </div>
      </div>
      </div>
<div class="scoreInline copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.1.239</span>. Best viewed in desktop Chrome at 100% zoom, ideally on a 2560x1440 display or higher.</div>

</div>

    <div id="screenStore" class="screen" style="display:none;">
            <div class="headerBar">
        <div class="topHeader">
          <p class="title">K-Bucks: Learn & Earn!</p>
        </div>
      </div>
<div class="storeMain">
<div id="redeemPane" aria-live="polite">
        <div class="redeemHeader">
          <div>
            <h2>Redemption Store</h2>
            <p id="redeemBalance" class="storePrice">Available to redeem (Child K-Bucks): KBU 0.00</p>
            <div id="redeemPaneMessage"></div>
          </div>
</div>

        <div id="store"></div>
        <div class="controls mainSlotNav">
          <button id="closeRedeemBtn" type="button">Educational Content</button>
        </div>
</div>
      </div>
      <div class="scoreInline copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.1.239</span>. Best viewed in desktop Chrome at 100% zoom, ideally on a 2560x1440 display or higher.</div>
</div>
      

  

  <div id="screenEdu" class="screen">
<div class="headerBar">
        <div class="topHeader">
          <p class="title">K-Bucks: Learn & Earn!</p>
        </div>
      </div>
<div class="storeMain">
        <div id="eduPane" aria-live="polite">
          <div class="redeemHeader">
            <div>
              <h2>Educational Content</h2>
              <p id="earnBalance" class="storePrice">Available for the Child to earn (from Parent + Sponsors): KBU 0.00</p>
              <div id="eduPaneMessage"></div>
            </div>
</div>

          <div id="eduList"></div>
          <div class="controls mainSlotNav">
            <button id="openStoreBtn" type="button">Redemption Store</button>
          </div>
</div>
      </div>

      <div class="scoreInline copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.1.239</span>. Best viewed in desktop Chrome at 100% zoom, ideally on a 2560x1440 display or higher.</div>
    </div>

    <div id="screenBingo" class="screen" style="display:none;">
      <div class="headerBar">
        <div class="topHeader">
          <p class="title">Practice Times Tables</p>
        <div class="topStatus" aria-live="polite">
            <div class="scoreInline" id="bingoProgress">Progress: 0/100 (0%)</div>
            <div class="scoreInline" id="bingoStatus">Score: 0/0 (0%)</div>
            <div class="scoreInline" id="bingoTimer">Time: 00:00:00</div>
          </div>
          </div>
      </div>

      <div class="layout gameLayout">
      <div id="bingoSlot">
        <div id="bingoPane" aria-live="polite">
          <div id="bingoGrid" class="bingoGrid">
        <div class="bingoCard">
          <div class="bingoCardHeader">1</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">1</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">2</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">2</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">3</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">3</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">4</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">4</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">5</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">5</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">6</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">6</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">7</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">7</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">8</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">8</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">9</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">9</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
        <div class="bingoCard">
          <div class="bingoCardHeader">10</div>
          <div class="bingoCardBody">
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">1</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">2</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">3</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">4</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">5</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">6</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">7</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">8</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">9</span></div>
            <div class="bingoLine"><span class="bingoA">10</span><span class="bingoX">&times;</span><span class="bingoB">10</span></div>
          </div>
        </div>
          </div>
        </div>
      </div>

      <div id="bingoSide">
        <div class="pane" id="bingoQuizPane">
          <div class="paneHeader">
            <h3>Select your answer:</h3>
</div>

          <ul class="answers" id="bingoAnswers"></ul>

          <div class="status" id="bingoMessage"></div>

          <div class="controls">
            <button id="bingoNextBtn" disabled type="button">Next question</button>
          </div>

        </div>

        <div class="pane">
          <h3>Parent</h3>
          <div class="acctLine">
            K-Bucks:
            <input id="bingoParentInput" class="moneyInput" type="text" inputmode="decimal" min="0" step="0.01" value="0.00" />
          </div>
          <div class="acctLine">
            Flow rate (K-Bucks per correct answer):
            <input id="bingoFlowRateInput" class="flowInput moneyInput" type="text" inputmode="decimal" min="0" step="any" value="0.00" />
          </div>
        </div>

        <div class="pane">
          <h3>Education Sponsors</h3>
          <div class="acctLine">
            K-Bucks:
            <input id="bingoSponsorInput" class="moneyInput" type="text" inputmode="decimal" min="0" step="any" value="0.00" />
          </div>
          <div class="acctLine">
            Parent : Sponsors match ratio (3 ≤ x ≤ 7):
            <input id="bingoSponsorMatchInput" class="flowInput" type="number" min="3" max="7" step="any" value="5" /><span class="matchSuffix"> : 1</span>
          </div>
        </div>

        <div class="arrowDivider" aria-hidden="true"><div id="bingoSpigotPane" class="pane spigotPane">
          <div class="spigotInner">
            <img class="spigotImg" src="spigot.png?v=3" alt="" />
            <div class="spigotText">
              <div class="acctLine">Flow rate (K-Bucks, Parent + Sponsors): <span id="bingoSpigotFlowRateOut">0.00</span></div>
              <div class="acctLine kbHourLine">K-Bucks/Hour (estimate): <span id="bingoSpigotKbucksPerHourOut">0.00</span></div>
            </div>
          </div>
        </div></div>

        <div class="pane" id="bingoChildPane">
          <h3>Child <span class="pct">(75%)</span></h3>
          <div class="acctLine" id="bingoChildAcct">K-Bucks: 0.00</div>
        </div>

        <div class="pane">
          <h3>Content Developer <span class="pct">(12.5%)</span></h3>
          <div class="acctLine" id="bingoDevAcct">K-Bucks: 0.00</div>
        </div>

        <div class="pane">
          <h3>K-Bucks Platform <span class="pct">(12.5%)</span></h3>
          <div class="acctLine" id="bingoPlatformAcct">K-Bucks: 0.00</div>
          <div class="acctLine" id="bingoPlatformInfo"></div>
        </div>

      
        <div class="bottomBar">
          <button id="bingoQuitBtn" type="button" disabled>Practice misses</button>
          <button id="bingoStartNewBtn" type="button">New game</button>
          <button id="bingoRedeemBtn" type="button">Quit game</button>
        </div>
      </div>
    </div>

      <div class="scoreInline copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.1.239</span>. Best viewed in desktop Chrome at 100% zoom, ideally on a 2560x1440 display or higher.</div>
    </div>

</div>

    
    

<div class="overlay" id="overlay">
    <div class="modal">
      <h2>Game ended</h2>
      <p id="finalText">Thanks for playing.</p>
      <div class="controls">
        <button id="restartBtn" type="button">Restart</button>
      </div>
    </div>
  </div>
<script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  >


</script>

  <script>









    const SCALE = 1000000000  
    const KB_BUILD_VERSION = "0.1.239"
    try { window.KB_BUILD_VERSION = KB_BUILD_VERSION } catch (e) {}

    // Screen 4, Practice Times Tables tables
    // productPairs, all 100 A x B pairs, 1..10 by 1..10
    // productResults, all unique products from those pairs
    const KB_BINGO_TABLES = (() => {
      const productPairs = []
      const productsSet = new Set()
      for (let a = 1; a <= 10; a++) {
        for (let b = 1; b <= 10; b++) {
          const product = a * b
          productPairs.push({ a, b, product })
          productsSet.add(product)
        }
      }
      const productResults = Array.from(productsSet).sort((x, y) => x - y)
      const tables = { productPairs, productResults }
      try { window.KB_BINGO_TABLES = tables } catch (e) {}
      return tables
    })()
// Keep footer version in sync with KB_BUILD_VERSION
    try {
      document.querySelectorAll(".kbBuildVersion").forEach((el) => {
        try { el.textContent = KB_BUILD_VERSION } catch (e) {}
      })
    } catch (e) {}
// Footer debug info (shows fixed target header and footer heights).
function kbReadCssPxVar(varName) {
  try {
    const raw = getComputedStyle(document.documentElement).getPropertyValue(varName) || ""
    const n = parseInt(String(raw).trim().replace("px", ""), 10)
    return Number.isFinite(n) ? n : 0
  } catch (e) {
    return 0
  }
}

// Wallet display formatter:
// - comma separators for integer part
// - at least 2 decimals
// - more decimals only when they contain non-zero digits
// - no rounding
function fmtWalletMin2U(u) {
  const x = Number(u)
  if (!Number.isFinite(x) || x <= 0) return "0.00"

  const intPart = Math.floor(x / SCALE)
  const fracUnits = Math.floor(x % SCALE)

  const intStr = String(intPart).replace(/\B(?=(\d{3})+(?!\d))/g, ",")

  // Build 9 digits of fractional precision.
  let frac = String(fracUnits).padStart(9, "0")
  // Trim trailing zeros, but keep at least 2 digits.
  frac = frac.replace(/0+$/, "")
  if (frac.length < 2) frac = frac.padEnd(2, "0")

  // If everything was zeros, show .00
  if (!frac || /^0+$/.test(frac)) return intStr + ".00"

  return intStr + "." + frac
}
// 1 unit = 0.000000001 K-Bucks

    const ORANGE_STYLE = {
      color: "#d08a00",
      weight: 3,
      fill: true,
      fillColor: "#f2a400",
      fillOpacity: 1.0
    }



    // Show countries slightly smaller than a tight fit. Fractional zoom remains enabled.
    const KB_ZOOM_OUT_AFTER_FIT = 0.25

    function kbZoomOutAfterNextMoveEnd(targetMap, delta) {
      try {
        if (!targetMap || !Number.isFinite(delta) || delta <= 0) return
        targetMap.once("moveend", () => {
          try {
            const z = targetMap.getZoom()
            if (!Number.isFinite(z)) return
            targetMap.setZoom(z - delta, { animate: false })
          } catch (e) {}
        })
      } catch (e) {}
    }
    const UN_MEMBERS_URL = "https://restcountries.com/v3.1/all?fields=name,cca2,cca3,unMember"

    const WORLD_BOUNDS = L.latLngBounds(
  L.latLng(-85.05112878, -180),
  L.latLng(85.05112878, 180)
)


let map = null
let kbBaseTileLayer = null

const kbMapBuffers = {
  front: { id: "mapA", div: null, map: null, tileLayer: null, currentLayer: null },
  back: { id: "mapB", div: null, map: null, tileLayer: null, currentLayer: null }
}

let kbFrontKey = "front"
let kbBackKey = "back"

function kbGetFrontBuffer() { return kbMapBuffers[kbFrontKey] }
function kbGetBackBuffer() { return kbMapBuffers[kbBackKey] }

function kbSetBufferClasses() {
  const f = kbGetFrontBuffer()
  const b = kbGetBackBuffer()
  try {
    if (f && f.div) {
      f.div.classList.add("kbMapFront")
      f.div.classList.remove("kbMapBack")
    }
    if (b && b.div) {
      b.div.classList.add("kbMapBack")
      b.div.classList.remove("kbMapFront")
    }
  } catch (e) {}
}

function kbCreateLeafletMap(containerId) {
  const m = L.map(containerId, {
    zoomControl: true,
    attributionControl: false,
    minZoom: 2.2,
    maxBounds: WORLD_BOUNDS,
    maxBoundsViscosity: 1.0,
    worldCopyJump: false,
    zoomSnap: 0.2,
    zoomDelta: 0.2,
    preferCanvas: false
  }).setView([20, 0], 2.2)

  try {
    window.kbMapSeq = (window.kbMapSeq || 0) + 1
    m._kbSeq = window.kbMapSeq
  } catch (e) {}

  L.control.attribution({ prefix: false }).addTo(m)

  const tileLayer = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png", {
    subdomains: "abcd",
    detectRetina: true,
    maxZoom: 19,
    attribution: "© OpenStreetMap contributors © CARTO",
    noWrap: true,
    bounds: WORLD_BOUNDS,
    updateWhenIdle: true,
    keepBuffer: 4,
    // Avoid showing gray "missing tile" blocks if a tile request fails or is throttled.
    errorTileUrl: "data:image/gif;base64,R0lGODlhAQABAAAAACwAAAAAAQABAAA="
  }).addTo(m)

  return { map: m, tileLayer: tileLayer }
}

function kbHealTilesOnBuffer(buf, reason, opts) {
  const o = opts || {}
  const doRedraw = !!o.redraw
  try {
    if (buf && buf.map && buf.map.invalidateSize) {
      try { buf.map.invalidateSize({ animate: false, pan: false }) } catch (e) {
        try { buf.map.invalidateSize() } catch (e2) {}
      }
    }
  } catch (e) {}
  if (doRedraw) {
    try { if (buf && buf.tileLayer && buf.tileLayer.redraw) buf.tileLayer.redraw() } catch (e) {}
  }
  try { if (typeof kbDbg === "function") kbDbg("healTiles", { reason: reason, redraw: doRedraw }) } catch (e) {}
}

function kbHealTiles(reason, opts) {
  // Wrapper for legacy calls. Heal both front and back Leaflet buffers if present.
  try { kbHealTilesOnBuffer(kbGetFrontBuffer(), reason || "heal", opts) } catch (e) {}
  try { kbHealTilesOnBuffer(kbGetBackBuffer(), reason || "heal", opts) } catch (e) {}
}


function kbDestroyLeafletMap(reason) {
  try { if (typeof kbDbg === "function") kbDbg("destroyLeafletMap", { reason: reason }) } catch (e) {}

  const bufs = [kbMapBuffers.front, kbMapBuffers.back]
  for (const buf of bufs) {
    try {
      if (buf && buf.map) {
        try { buf.map.off() } catch (e) {}
        try { buf.map.remove() } catch (e) {}
      }
    } catch (e) {}
    try {
      if (buf && buf.div) {
        try { delete buf.div._leaflet_id } catch (e) {}
      }
    } catch (e) {}
    try {
      if (buf) {
        buf.map = null
        buf.tileLayer = null
        buf.currentLayer = null
      }
    } catch (e) {}
  }

  map = null
  kbBaseTileLayer = null
}

function kbEnsureLeafletMap(reason) {
  if (map) return map

  kbMapBuffers.front.div = document.getElementById(kbMapBuffers.front.id)
  kbMapBuffers.back.div = document.getElementById(kbMapBuffers.back.id)

  const frontPair = kbCreateLeafletMap(kbMapBuffers.front.id)
  kbMapBuffers.front.map = frontPair.map
  kbMapBuffers.front.tileLayer = frontPair.tileLayer

  const backPair = kbCreateLeafletMap(kbMapBuffers.back.id)
  kbMapBuffers.back.map = backPair.map
  kbMapBuffers.back.tileLayer = backPair.tileLayer

  kbFrontKey = "front"
  kbBackKey = "back"
  kbSetBufferClasses()

  map = kbMapBuffers.front.map
  kbBaseTileLayer = kbMapBuffers.front.tileLayer

  // Keep mapDiv pointing to the visible buffer
  try { if (kbMapBuffers.front.div) mapDiv = kbMapBuffers.front.div } catch (e) {}
  try { if (typeof kbDebug !== "undefined" && kbDebug && mapDiv) mapDiv.appendChild(kbDebug) } catch (e) {}

  try { if (typeof kbDbg === "function") kbDbg("ensureLeafletMap", { reason: reason }) } catch (e) {}
  return map
}

function kbSwapMapBuffers(reason) {
  try { if (typeof kbDbg === "function") kbDbg("swapBuffers", { reason: reason }) } catch (e) {}

  const tmp = kbFrontKey
  kbFrontKey = kbBackKey
  kbBackKey = tmp
  kbSetBufferClasses()

  const f = kbGetFrontBuffer()
  if (f) {
    map = f.map
    kbBaseTileLayer = f.tileLayer
    try { if (f.div) mapDiv = f.div } catch (e) {}
    try { if (typeof kbDebug !== "undefined" && kbDebug && mapDiv) mapDiv.appendChild(kbDebug) } catch (e) {}
    try { currentLayer = f.currentLayer } catch (e) {}
    try { kbHealTilesOnBuffer(f, "swap") } catch (e) {}
  }

  const b = kbGetBackBuffer()
  try { kbHealTilesOnBuffer(b, "swap-back") } catch (e) {}
}


let mapDiv = document.getElementById("mapA")
    const redeemPane = document.getElementById("redeemPane")
    const sideEl = document.getElementById("side")
    // Debug overlay and logging (disabled by default)
    const KB_DEBUG = false
    const mapSlotEl = document.getElementById("mapSlot")
    const gameScreenForDebugEl = document.getElementById("screenGame")
    const headerEl = gameScreenForDebugEl ? gameScreenForDebugEl.querySelector(".headerBar") : null
    const footerEl = gameScreenForDebugEl ? gameScreenForDebugEl.querySelector(".copyrightLine") : null

    let kbDebug = null
    if (KB_DEBUG) {
      kbDebug = document.createElement("div")
      kbDebug.id = "kbDebug"
      kbDebug.style.cssText = "position:absolute;top:8px;left:8px;z-index:1000;background:rgba(255,255,255,0.95);border:1px solid #ddd;border-radius:6px;padding:6px 8px;font-size:12px;line-height:1.25;pointer-events:none;white-space:pre;"
      try { mapDiv.style.position = "relative" } catch (e) {}
      try { mapDiv.appendChild(kbDebug) } catch (e) {}
    }

    const kbDbgLines = []
    function kbDbg(msg, obj) {
      if (!KB_DEBUG) return
      const t = (performance.now() / 1000).toFixed(3)
      let line = "[KBDBG " + t + "] " + msg
      if (obj !== undefined) {
        try { line += " " + JSON.stringify(obj) } catch (e) {}
      }
      try { console.log(line) } catch (e) {}
      kbDbgLines.push(line)
      if (kbDbgLines.length > 60) kbDbgLines.shift()
      try { kbScheduleDebugUpdate() } catch (e) {}
    }
    try { window.kbDbg = kbDbg } catch (e) {}


    
    function kbMapState() {
      const rect = mapDiv ? mapDiv.getBoundingClientRect() : { width: 0, height: 0 }
      let size = { x: 0, y: 0 }
      let center = null
      let zoom = null
      try { size = map.getSize() } catch (e) {}
      try { center = map.getCenter() } catch (e) {}
      try { zoom = map.getZoom() } catch (e) {}
      return {
        screen: (typeof currentScreen !== "undefined") ? currentScreen : "unknown",
        mapRect: { w: Math.round(rect.width), h: Math.round(rect.height) },
        mapOffset: { w: mapDiv ? mapDiv.offsetWidth : 0, h: mapDiv ? mapDiv.offsetHeight : 0 },
        leafletSize: { x: size.x, y: size.y },
        center: center ? { lat: +center.lat.toFixed(5), lng: +center.lng.toFixed(5) } : null,
        zoom: zoom
      }
    }

    function kbNormalizeMapView(reason) {
      if (!map || !map.getCenter) return false
      let c = null
      try { c = map.getCenter() } catch (e) {}
      if (!c) return false

      const bad = (Math.abs(c.lat) > 80) || (Math.abs(c.lng) > 180) || (!isFinite(c.lat)) || (!isFinite(c.lng))
      if (!bad) return false

      try { kbDbg("normalizeMapView", { reason: reason, before: kbMapState() }) } catch (e) {}
      try { if (map.stop) map.stop() } catch (e) {}
      try { map.setView([20, 0], 2.2, { animate: false }) } catch (e) {}
      try { if (map.invalidateSize) map.invalidateSize({ animate: false, pan: false }) } catch (e) {}
      try { kbDbg("normalizeMapView done", { reason: reason, after: kbMapState() }) } catch (e) {}
      return true
    }

    function kbAttachMapDebugListeners() {
      if (!map) return
      try {
        map.whenReady(() => kbDbg("map whenReady", kbMapState()))

        map.on("resize", (e) => {
          kbDbg("map resize", {
            old: e && e.oldSize ? { x: e.oldSize.x, y: e.oldSize.y } : null,
            now: kbMapState()
          })
        })

        map.on("moveend", () => {
          if (!currentLayer) return
          let pt = null
          let ll = null
          try {
            const b = currentLayer.getBounds()
            ll = b.getCenter()
            pt = map.latLngToContainerPoint(ll)
          } catch (e) {}
          kbDbg("map moveend", {
            now: kbMapState(),
            layerCenterPx: pt ? { x: Math.round(pt.x), y: Math.round(pt.y) } : null,
            layerCenterLatLng: ll ? { lat: +ll.lat.toFixed(5), lng: +ll.lng.toFixed(5) } : null
          })
        })
      } catch (e) {}
    }

let kbDebugRaf = null
    function kbScheduleDebugUpdate() {
      if (kbDebugRaf) cancelAnimationFrame(kbDebugRaf)
      kbDebugRaf = requestAnimationFrame(kbUpdateDebugOverlay)
    }

    function kbPx(n) {
      return Math.max(0, Math.round(n || 0))
    }

    function kbUpdateDebugOverlay() {
      if (!KB_DEBUG || !kbDebug) return
      try {
        const mapRect = mapDiv.getBoundingClientRect()
        const slotRect = mapSlotEl ? mapSlotEl.getBoundingClientRect() : { width: 0, height: 0 }
        const sideRect = sideEl ? sideEl.getBoundingClientRect() : { height: 0 }
        const headerRect = headerEl ? headerEl.getBoundingClientRect() : { height: 0 }
        const footerRect = footerEl ? footerEl.getBoundingClientRect() : { height: 0 }

        kbDebug.textContent =
          "Map pane: " + kbPx(mapRect.width) + " x " + kbPx(mapRect.height) + " px\n" +
          "Map slot: " + kbPx(slotRect.width) + " x " + kbPx(slotRect.height) + " px\n" +
          "Right span height: " + kbPx(sideRect.height) + " px\n" +
          "Header height: " + kbPx(headerRect.height) + " px\n" +
          "Footer height: " + kbPx(footerRect.height) + " px" +
          "\n\nScreen: " + ((typeof currentScreen !== "undefined") ? currentScreen : "unknown") +
          "\nMap offset: " + (mapDiv ? mapDiv.offsetWidth : 0) + " x " + (mapDiv ? mapDiv.offsetHeight : 0) +
          "\nLeaflet size: " + (function(){ try { const s = map.getSize(); return s.x + " x " + s.y } catch(e){ return "n/a" } })() +
          (kbDbgLines && kbDbgLines.length ? ("\n\nLast logs:\n" + kbDbgLines.slice(-8).join("\n")) : "")
      } catch (e) {
        // ignore
      }
    }

    // Keep this passive, never call map.invalidateSize from debug
    const kbDebugRO = new ResizeObserver(() => kbScheduleDebugUpdate())
    if (mapSlotEl) kbDebugRO.observe(mapSlotEl)
    if (sideEl) kbDebugRO.observe(sideEl)
    if (headerEl) kbDebugRO.observe(headerEl)
    if (footerEl) kbDebugRO.observe(footerEl)
    kbDebugRO.observe(mapDiv)
    window.addEventListener("resize", () => kbScheduleDebugUpdate())
    document.addEventListener("visibilitychange", () => kbScheduleDebugUpdate())
    kbScheduleDebugUpdate()

    const answersEl = document.getElementById("answers")
    const nextBtn = document.getElementById("nextBtn")
    const quitBtn = document.getElementById("quitBtn")
    const statusEl = document.getElementById("status")
    const timerEl = document.getElementById("timer")
    
    const progressEl = document.getElementById("progress")
const messageEl = document.getElementById("message")

    const bingoAnswersEl = document.getElementById("bingoAnswers")
    const bingoNextBtn = document.getElementById("bingoNextBtn")
    const bingoMessageEl = document.getElementById("bingoMessage")
    const bingoProgressEl = document.getElementById("bingoProgress")
    const bingoStatusEl = document.getElementById("bingoStatus")
    const bingoTimerEl = document.getElementById("bingoTimer")
    const bingoQuitBtn = document.getElementById("bingoQuitBtn")
    const bingoStartNewBtn = document.getElementById("bingoStartNewBtn")
    const bingoRedeemBtn = document.getElementById("bingoRedeemBtn")

    const bingoParentInput = document.getElementById("bingoParentInput")
    const bingoSponsorInput = document.getElementById("bingoSponsorInput")
    const bingoSponsorMatchInput = document.getElementById("bingoSponsorMatchInput")
    const bingoFlowRateInput = document.getElementById("bingoFlowRateInput")
    const bingoSpigotFlowRateOut = document.getElementById("bingoSpigotFlowRateOut")
    const bingoSpigotKbucksPerHourOut = document.getElementById("bingoSpigotKbucksPerHourOut")

    const bingoChildAcctEl = document.getElementById("bingoChildAcct")
    const bingoDevAcctEl = document.getElementById("bingoDevAcct")
    const bingoPlatformAcctEl = document.getElementById("bingoPlatformAcct")
    const bingoChildPaneEl = document.getElementById("bingoChildPane")
    const bingoSpigotPaneEl = document.getElementById("bingoSpigotPane")
    const bingoPlatformInfoEl = document.getElementById("bingoPlatformInfo")


    const overlay = document.getElementById("overlay")
    const restartBtn = document.getElementById("restartBtn")

    const parentInput = document.getElementById("parentInput")
    const sponsorInput = document.getElementById("sponsorInput")
    const sponsorMatchInput = document.getElementById("sponsorMatchInput")
    const flowRateInput = document.getElementById("flowRateInput")
    
    const sponsorFlowRateOut = document.getElementById("sponsorFlowRateOut")
    const spigotFlowRateOut = document.getElementById("spigotFlowRateOut")
    const spigotKbucksPerHourOut = document.getElementById("spigotKbucksPerHourOut")

    const childAcctEl = document.getElementById("childAcct")
    const devAcctEl = document.getElementById("devAcct")
    const platformAcctEl = document.getElementById("platformAcct")
    const childPaneEl = document.getElementById("childPane")
    const spigotPaneEl = document.getElementById("spigotPane")

    function syncSpigotPaneSize() {
      if (!childPaneEl || !spigotPaneEl) return
      const r = childPaneEl.getBoundingClientRect()
      const w = Math.round(r.width)
      const h = Math.round(r.height)
      if (!w || !h || w < 120 || h < 40) return
      spigotPaneEl.style.width = w + "px"
      spigotPaneEl.style.height = h + "px"
    }

    window.addEventListener("resize", syncSpigotPaneSize)

    const platformInfoEl = document.getElementById("platformInfo")

    const redeemBtn = document.getElementById("redeemBtn")
    const startNewBtn = document.getElementById("startNewBtn")
    const redeemBalanceEl = document.getElementById("redeemBalance")
    const redeemPaneMessageEl = document.getElementById("redeemPaneMessage")
    const storeEl = document.getElementById("store")
    const closeRedeemBtn = document.getElementById("closeRedeemBtn")

    const earnBalanceEl = document.getElementById("earnBalance")
    const eduPaneMessageEl = document.getElementById("eduPaneMessage")
    const eduListEl = document.getElementById("eduList")
    const openStoreBtn = document.getElementById("openStoreBtn")

    const screenEduEl = document.getElementById("screenEdu")

const screenBingoEl = document.getElementById("screenBingo")

    const screenGameEl = document.getElementById("screenGame")
    const screenStoreEl = document.getElementById("screenStore")
    let currentScreen = "edu"
    function getCssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim()
    }


    function showGameScreen() {
      try { kbDbg("showGameScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "bingo") {
        if (!bingoTimerStopped && bingoTimerRunning) pauseBingoTimer()
      }
currentScreen = "game"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("name_that_country") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = ""
      if (screenStoreEl) screenStoreEl.style.display = "none"
      if (screenEduEl) screenEduEl.style.display = "none"
      
      if (screenBingoEl) screenBingoEl.style.display = "none"
      
      // Recreate Leaflet map fresh each time we enter the game screen.
      try { kbDestroyLeafletMap("showGameScreen") } catch (e) {}
      try { kbEnsureLeafletMap("showGameScreen") } catch (e) {}

      try { syncMapHeight() } catch (e) {}
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
    }

    function showStoreScreen() {
      try { kbDbg("showStoreScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "bingo") {
        if (!bingoTimerStopped && bingoTimerRunning) pauseBingoTimer()
      }
currentScreen = "store"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("redemption_store") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = "none"
      if (screenStoreEl) screenStoreEl.style.display = ""
      if (screenEduEl) screenEduEl.style.display = "none"
      
      if (screenBingoEl) screenBingoEl.style.display = "none"
      
      try { kbUpdateGlobalBalances() } catch (e) {}
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
    }

    function showEduScreen() {
      try { kbDbg("showEduScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "bingo") {
        if (!bingoTimerStopped && bingoTimerRunning) pauseBingoTimer()
      }
currentScreen = "edu"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("educational_content") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = "none"
      if (screenStoreEl) screenStoreEl.style.display = "none"
      if (screenEduEl) screenEduEl.style.display = ""
      
      if (screenBingoEl) screenBingoEl.style.display = "none"
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
      try { updateAccounts() } catch (e) {}
      try { renderEdu() } catch (e) {}
    }
    
    // Bingo (Screen 4) K-Bucks wallets and flow logic.
    // Keep independent from the Name That Country (Screen 3) wallets.
    let kbBingoParentU = 0 * SCALE
    let kbBingoSponsorU = 0 * SCALE
    let kbBingoDevU = 0
    let kbBingoFlowU = toUnits("0.00")
    let kbBingoSponsorMatch = 5
    let kbBingoDevCarry = 0
    let kbBingoPlatCarry = 0

    function kbBingoSpigotFlowRateU() {
      const parentFlowU = Number(kbBingoFlowU)
      if (!Number.isFinite(parentFlowU) || parentFlowU <= 0) return 0

      let sponsorAddU = 0
      const m = Number(kbBingoSponsorMatch)
      const sponsorWalletU = Number(kbBingoSponsorU)

      if (Number.isFinite(sponsorWalletU) && sponsorWalletU > 0 && Number.isFinite(m) && m > 0) {
        sponsorAddU = Math.trunc(parentFlowU / m)
        if (sponsorAddU > sponsorWalletU) sponsorAddU = sponsorWalletU
        if (sponsorAddU < 0) sponsorAddU = 0
      }
      return parentFlowU + sponsorAddU
    }

    function kbBingoFmtSpigotFlowRate() {
      return fmtUnitsTrimU(kbBingoSpigotFlowRateU())
    }

    function kbBingoSpigotKbucksPerHourU() {
      // Estimate: flow per answer * 600 (see Screen 3 formula).
      return Math.trunc(kbBingoSpigotFlowRateU() * 600)
    }

    function kbBingoFmtSpigotKbucksPerHour() {
      return fmtWalletMin2U(kbBingoSpigotKbucksPerHourU())
    }


    function kbBingoSyncSpigotPaneSize() {
      if (!bingoChildPaneEl || !bingoSpigotPaneEl) return
      const r = bingoChildPaneEl.getBoundingClientRect()
      const w = Math.round(r.width)
      const h = Math.round(r.height)
      if (!w || !h || w < 120 || h < 40) return
      bingoSpigotPaneEl.style.width = w + "px"
      bingoSpigotPaneEl.style.height = h + "px"
    }

    window.addEventListener("resize", kbBingoSyncSpigotPaneSize)

    function kbBingoUpdateAccounts() {
      if (kbBingoParentU <= 0) kbBingoFlowU = 0

      if (bingoParentInput && document.activeElement !== bingoParentInput) bingoParentInput.value = fmtParentU(kbBingoParentU)
      if (bingoSponsorInput && document.activeElement !== bingoSponsorInput) bingoSponsorInput.value = fmtSponsorU(kbBingoSponsorU)

      if (bingoFlowRateInput && document.activeElement !== bingoFlowRateInput) bingoFlowRateInput.value = fmtFlowInputU(kbBingoFlowU)
      if (bingoSponsorMatchInput && document.activeElement !== bingoSponsorMatchInput) bingoSponsorMatchInput.value = String(kbBingoSponsorMatch)

      if (bingoSpigotFlowRateOut) bingoSpigotFlowRateOut.textContent = kbBingoFmtSpigotFlowRate()
      if (bingoSpigotKbucksPerHourOut) bingoSpigotKbucksPerHourOut.textContent = kbBingoFmtSpigotKbucksPerHour()
      if (bingoChildAcctEl) bingoChildAcctEl.textContent = "K-Bucks: " + fmtOtherU(kbGlobalChildU)
      if (bingoDevAcctEl) bingoDevAcctEl.textContent = "K-Bucks: " + fmtOtherU(kbBingoDevU)
      if (bingoPlatformAcctEl) bingoPlatformAcctEl.textContent = "K-Bucks: " + fmtOtherU(kbGlobalPlatformU)

      kbBingoSyncSpigotPaneSize()
      kbUpdateGlobalBalances()
    }

    function kbBingoClampFlowRate() {
      if (!bingoFlowRateInput) return
      const raw = String(bingoFlowRateInput.value || "")
      let vU = parseUnitsNoRound(raw)
      if (vU < 0) vU = 0
      if (kbBingoParentU <= 0) vU = 0
      kbBingoFlowU = vU
      bingoFlowRateInput.value = fmtFlowInputU(kbBingoFlowU)
      kbBingoUpdateAccounts()
    }

    function kbBingoClampParentInput() {
      if (!bingoParentInput) return
      const raw = String(bingoParentInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      kbBingoParentU = vU
      if (kbBingoParentU <= 0) kbBingoFlowU = 0
      if (bingoFlowRateInput) bingoFlowRateInput.value = fmtFlowInputU(kbBingoFlowU)
      kbBingoUpdateAccounts()
      if (bingoParentInput) bingoParentInput.value = fmtParentU(kbBingoParentU)
    }

    function kbBingoClampSponsorInput() {
      if (!bingoSponsorInput) return
      const raw = String(bingoSponsorInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      kbBingoSponsorU = vU
      kbBingoUpdateAccounts()
      if (bingoSponsorInput && document.activeElement !== bingoSponsorInput) bingoSponsorInput.value = fmtSponsorU(kbBingoSponsorU)
    }

    function kbBingoClampSponsorMatch() {
      if (!bingoSponsorMatchInput) return
      const raw = String(bingoSponsorMatchInput.value || "").trim()
      let v = Number(raw)

      if (!Number.isFinite(v) || v < 3 || v > 7) {
        bingoSponsorMatchInput.value = String(kbBingoSponsorMatch)
        return
      }
      kbBingoSponsorMatch = v
      if (document.activeElement !== bingoSponsorMatchInput) bingoSponsorMatchInput.value = String(kbBingoSponsorMatch)
      kbBingoUpdateAccounts()
    }


    let kbBingoPairsUpgradedToButtons = false
    function kbUpgradeBingoPairsToButtons() {
      if (kbBingoPairsUpgradedToButtons) return
      kbBingoPairsUpgradedToButtons = true
      const lines = document.querySelectorAll('#screenBingo .bingoLine')
      lines.forEach((line) => {
        const btn = document.createElement('button')
        btn.type = 'button'
        btn.className = 'bingoPairBtn'
        // Preserve existing A × B spans and layout
        while (line.firstChild) btn.appendChild(line.firstChild)
        line.replaceWith(btn)
      })
    }

    
    // --- Bingo quiz logic (Screen 4) ---
    const kbBingoUniqueResults = (() => {
      const s = new Set()
      for (let a = 1; a <= 10; a += 1) {
        for (let b = 1; b <= 10; b += 1) s.add(a * b)
      }
      return Array.from(s).sort((x, y) => x - y)
    })()

    let kbBingoPairs = []
    let kbBingoPairByKey = new Map()

    // Normal mode state
    let kbBingoAnsweredKeys = new Set()
    let kbBingoMisses = new Set()

    // Practice misses mode
    let kbBingoMode = "normal" // "normal" or "practice"
    let kbBingoPracticeTotal = 0

    let kbBingoPracticeDeck = []
    let kbBingoPracticeIndex = 0
    let kbBingoPracticeShown = 0

    // Shared state
    let kbBingoCurrentPair = null
    let kbBingoLocked = false
    let kbBingoComplete = false
    let kbBingoRounds = 0
    let kbBingoCorrectCount = 0
    let kbBingoCurrentAnswerKey = null

    function kbShuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1))
        const tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
      }
      return arr
    }

    function kbBingoUpdateHeader(finalMode) {
      const total = kbBingoPairs.length || 100

      if (kbBingoMode === "practice") {
        if (bingoProgressEl) {
          const presented = kbBingoPracticeTotal > 0 ? Math.min(kbBingoPracticeShown, kbBingoPracticeTotal) : 0
          bingoProgressEl.textContent = "Practice misses: " + presented + "/" + kbBingoPracticeTotal
        }
        if (bingoStatusEl) bingoStatusEl.textContent = ""
        if (bingoTimerEl) bingoTimerEl.textContent = ""
      } else {
        const answered = kbBingoAnsweredKeys.size
        const correct = kbBingoCorrectCount

        if (bingoProgressEl) {
          bingoProgressEl.textContent = "Progress: " + answered + "/" + total + formatScorePct(answered, total)
        }
        if (bingoStatusEl) {
          const prefix = finalMode ? "Final score: " : "Score: "
          bingoStatusEl.textContent = prefix + correct + "/" + answered + (answered <= 0 ? " (0%)" : formatScorePct(correct, answered))
        }
      }

      if (bingoQuitBtn) bingoQuitBtn.disabled = kbBingoMisses.size === 0
    }

    function kbBingoEnsurePairs() {
      const btns = Array.from(document.querySelectorAll('#screenBingo .bingoPairBtn'))
      kbBingoPairs = []
      kbBingoPairByKey = new Map()
      for (const btn of btns) {
        const aEl = btn.querySelector(".bingoA")
        const bEl = btn.querySelector(".bingoB")
        const a = aEl ? parseInt(String(aEl.textContent || "").trim(), 10) : NaN
        const b = bEl ? parseInt(String(bEl.textContent || "").trim(), 10) : NaN
        if (!Number.isFinite(a) || !Number.isFinite(b)) continue
        const key = String(a) + "x" + String(b)
        btn.dataset.a = String(a)
        btn.dataset.b = String(b)
        btn.dataset.key = key
        const pair = { key, a, b, btn }
        kbBingoPairs.push(pair)
        kbBingoPairByKey.set(key, pair)
      }
    }

    function kbBingoClearHighlights() {
      for (const p of kbBingoPairs) {
        p.btn.classList.remove("kbBingoDoneCorrect")
        p.btn.classList.remove("kbBingoDoneWrong")
        p.btn.classList.remove("kbBingoCurrent")
      }
    }

    function kbBingoResetUIForNewQuestion() {
      if (bingoAnswersEl) bingoAnswersEl.innerHTML = ""
      if (bingoMessageEl) bingoMessageEl.textContent = ""
      if (bingoNextBtn) {
        bingoNextBtn.textContent = "Next question"
        bingoNextBtn.disabled = true
      }
      kbBingoLocked = false
    }

    function kbBingoRenderAnswers(options) {
      if (!bingoAnswersEl) return
      bingoAnswersEl.innerHTML = ""

      for (const opt of options) {
        const li = document.createElement("li")
        const btn = document.createElement("button")
        btn.className = "ansBtn"
        btn.type = "button"

        const bullet = document.createElement("span")
        bullet.className = "bullet"
        bullet.textContent = "•"

        const label = document.createElement("span")
        label.className = "label"
        label.textContent = opt.displayName

        const mark = document.createElement("span")
        mark.className = "mark"
        mark.textContent = ""

        btn.appendChild(bullet)
        btn.appendChild(label)
        btn.appendChild(mark)

        btn.addEventListener("click", () => kbBingoOnGuess(opt.key, btn))

        li.appendChild(btn)
        bingoAnswersEl.appendChild(li)
      }
    }

    function kbBingoLockAnswers() {
      const btns = Array.from((bingoAnswersEl || document).querySelectorAll(".ansBtn"))
      for (const b of btns) b.disabled = true
      return btns
    }

    function kbBingoBuildOptions(correctValue) {
      const correctKey = String(correctValue)
      const pool = kbBingoUniqueResults.map(v => String(v)).filter(v => v !== correctKey)
      kbShuffleInPlace(pool)
      const picked = pool.slice(0, 9)
      const allKeys = [correctKey, ...picked]
      kbShuffleInPlace(allKeys)
      return allKeys.map(k => ({ key: k, displayName: k }))
    }

    function kbBingoSetCurrentPair(pair) {
      for (const p of kbBingoPairs) p.btn.classList.remove("kbBingoCurrent")
      kbBingoCurrentPair = pair
      if (pair && pair.btn) pair.btn.classList.add("kbBingoCurrent")
    }

    function kbBingoPresentRandomPair() {
      kbBingoEnsurePairs()
      if (kbBingoPairs.length === 0) return

      if (kbBingoMode === "practice") {
        if (!kbBingoPracticeDeck || kbBingoPracticeDeck.length === 0) {
          if (bingoMessageEl) bingoMessageEl.textContent = "No misses yet. Play a New game first."
          if (bingoNextBtn) {
            bingoNextBtn.textContent = "Next question"
            bingoNextBtn.disabled = true
          }
          kbBingoUpdateHeader(false)
          return
        }

        // Infinite loop. After showing all misses, start again at 0/FFF.
        if (kbBingoPracticeIndex >= kbBingoPracticeDeck.length) {
          kbBingoPracticeIndex = 0
          kbBingoPracticeShown = 0
          kbBingoRounds = 0
          kbBingoCorrectCount = 0
          kbShuffleInPlace(kbBingoPracticeDeck)
          kbBingoUpdateHeader(false)
        }

        const key = kbBingoPracticeDeck[kbBingoPracticeIndex]
        const pick = kbBingoPairByKey.get(key)
        if (!pick) {
          // Defensive. Drop unknown keys and continue.
          kbBingoPracticeDeck = kbBingoPracticeDeck.filter(k => k !== key)
          kbBingoPracticeTotal = kbBingoPracticeDeck.length
          kbBingoPracticeIndex = Math.min(kbBingoPracticeIndex, kbBingoPracticeDeck.length)
          kbBingoUpdateHeader(false)
          return kbBingoPresentRandomPair()
        }

        kbBingoSetCurrentPair(pick)

        // Count the miss as soon as it is presented (highlighted in orange).
        kbBingoPracticeShown += 1
        kbBingoPracticeIndex += 1
        kbBingoUpdateHeader(false)

        const correctValue = pick.a * pick.b
        const options = kbBingoBuildOptions(correctValue)
        kbBingoCurrentAnswerKey = String(correctValue)

        kbBingoResetUIForNewQuestion()
        kbBingoRenderAnswers(options)
        return
      }

      // Normal mode
      const candidates = kbBingoPairs.filter(p => !kbBingoAnsweredKeys.has(p.key))
      if (candidates.length === 0) {
        kbBingoComplete = true
        if (bingoNextBtn) {
          bingoNextBtn.textContent = "Game over"
          bingoNextBtn.disabled = true
        }
        stopBingoTimer()
        kbBingoUpdateHeader(true)
        return
      }

      const pick = candidates[Math.floor(Math.random() * candidates.length)]
      kbBingoSetCurrentPair(pick)

      const correctValue = pick.a * pick.b
      const options = kbBingoBuildOptions(correctValue)
      kbBingoCurrentAnswerKey = String(correctValue)

      kbBingoResetUIForNewQuestion()
      kbBingoRenderAnswers(options)
    }

    function kbBingoOnGuess(chosenKey, chosenBtn) {
      if (kbBingoLocked) return
      kbBingoLocked = true

      const correctKey = kbBingoCurrentAnswerKey
      const allButtons = kbBingoLockAnswers()
      const isCorrect = String(chosenKey) === String(correctKey)
      const isPractice = kbBingoMode === "practice"

      let kbTelemetryTotalPayU = 0
      let kbTelemetryParentPayU = 0
      let kbTelemetrySponsorPayU = 0

      if (isPractice) {
        kbBingoRounds += 1
        if (isCorrect) kbBingoCorrectCount += 1
      } else {
        if (kbBingoCurrentPair) {
          kbBingoAnsweredKeys.add(kbBingoCurrentPair.key)
          if (!isCorrect) kbBingoMisses.add(kbBingoCurrentPair.key)
        }
        kbBingoRounds = kbBingoAnsweredKeys.size
        if (isCorrect) kbBingoCorrectCount += 1
      }

      kbBingoUpdateHeader(false)

      // K-Bucks flow (normal mode only). No flow for incorrect answers.
      if (!isPractice && isCorrect) {
        const parentFlowU = Number(kbBingoFlowU)
        const parentWalletU = Number(kbBingoParentU)

        let parentPayU = 0
        if (Number.isFinite(parentFlowU) && parentFlowU > 0 && Number.isFinite(parentWalletU) && parentWalletU > 0) {
          parentPayU = Math.min(parentFlowU, parentWalletU)
        }

        let sponsorPayU = 0
        const m = Number(kbBingoSponsorMatch)
        const sponsorWalletU = Number(kbBingoSponsorU)
        if (parentFlowU > 0 && Number.isFinite(m) && m > 0 && Number.isFinite(sponsorWalletU) && sponsorWalletU > 0) {
          const sponsorFlowU = Math.floor(Number(parentFlowU) / m)
          if (sponsorFlowU > 0) sponsorPayU = Math.min(sponsorFlowU, sponsorWalletU)
        }

        const totalPayU = parentPayU + sponsorPayU

        kbTelemetryParentPayU = parentPayU
        kbTelemetrySponsorPayU = sponsorPayU
        kbTelemetryTotalPayU = totalPayU

        if (totalPayU > 0) {
          // Split: 75% child, 12.5% content developer, 12.5% platform.
          // Use carry remainders (denominator 8) to avoid systematic rounding bias.
          const devNumer = totalPayU + kbBingoDevCarry
          const platNumer = totalPayU + kbBingoPlatCarry
          const devAdd = Math.floor(devNumer / 8)
          const platAdd = Math.floor(platNumer / 8)
          kbBingoDevCarry = devNumer % 8
          kbBingoPlatCarry = platNumer % 8

          const childAdd = totalPayU - devAdd - platAdd

          kbBingoParentU -= parentPayU
          kbBingoSponsorU -= sponsorPayU
          kbGlobalChildU += childAdd
          kbBingoDevU += devAdd
          kbGlobalPlatformU += platAdd

          if (kbBingoParentU <= 0) kbBingoFlowU = 0
          try { kbBingoUpdateAccounts() } catch (e) {}
        }
      }

      try {
        if (window.KB_TELEMETRY) {
          const toKbu = (u) => {
            const n = Number(u) || 0
            return n > 0 ? (n / SCALE) : 0
          }
          window.KB_TELEMETRY.event("kb_answer", {
            kb_game: "practice_times_tables",
            kb_mode: kbBingoMode,
            kb_correct: isCorrect ? 1 : 0,
            kb_round: kbBingoRounds,
            kb_total_pay_kbu: toKbu(kbTelemetryTotalPayU),
            kb_parent_pay_kbu: toKbu(kbTelemetryParentPayU),
            kb_sponsor_pay_kbu: toKbu(kbTelemetrySponsorPayU)
          })
        }
      } catch (e) {}

      if (isCorrect) {
        chosenBtn.classList.add("correct")
        const m = chosenBtn.querySelector(".mark")
        if (m) m.textContent = "✓"
      } else {
        chosenBtn.classList.add("wrong")
        const m = chosenBtn.querySelector(".mark")
        if (m) m.textContent = "✕"

        const correctBtn = allButtons.find(b => {
          const label = b.querySelector(".label")
          return label && String(label.textContent) === String(correctKey)
        })
        if (correctBtn) {
          correctBtn.classList.add("correct")
          const m2 = correctBtn.querySelector(".mark")
          if (m2) m2.textContent = "✓"
        }
      }

      // Mark the answered A x B pair only in normal mode.
      if (!isPractice) {
        try {
          if (kbBingoCurrentPair && kbBingoCurrentPair.btn) {
            const pairBtn = kbBingoCurrentPair.btn
            pairBtn.classList.remove("kbBingoCurrent")
            pairBtn.classList.remove("kbBingoDoneCorrect")
            pairBtn.classList.remove("kbBingoDoneWrong")
            pairBtn.classList.add(isCorrect ? "kbBingoDoneCorrect" : "kbBingoDoneWrong")
          }
        } catch (e) {}

        const done = kbBingoAnsweredKeys.size >= kbBingoPairs.length
        if (done) {
          kbBingoComplete = true
          if (bingoNextBtn) {
            bingoNextBtn.textContent = "Game over"
            bingoNextBtn.disabled = true
          }
          stopBingoTimer()
          kbBingoUpdateHeader(true)
        } else {
          if (bingoNextBtn) bingoNextBtn.disabled = false
        }
        return
      }

      // Practice misses mode. Always allow continuing. Wrap happens in kbBingoPresentRandomPair.
      if (bingoNextBtn) bingoNextBtn.disabled = false
    }

    function kbBingoStartNewGame() {
      try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_game_start", { kb_game: "practice_times_tables" }) } catch (e) {}

      kbBingoEnsurePairs()
      kbBingoAnsweredKeys = new Set()
      kbBingoMisses = new Set()
      kbBingoMode = "normal"
      kbBingoPracticeTotal = 0

      kbBingoCurrentPair = null
      kbBingoLocked = false
      kbBingoComplete = false
      kbBingoRounds = 0
      kbBingoCorrectCount = 0
      kbBingoCurrentAnswerKey = null

      kbBingoClearHighlights()
      try { kbBingoUpdateAccounts() } catch (e) {}

      if (bingoNextBtn) {
        bingoNextBtn.textContent = "Next question"
        bingoNextBtn.disabled = true
      }
      if (bingoMessageEl) bingoMessageEl.textContent = ""
      kbBingoUpdateHeader(false)
      resetAndStartBingoTimer()

      kbBingoPresentRandomPair()
    }

    function kbBingoStartPracticeMisses() {
      if (!kbBingoMisses || kbBingoMisses.size === 0) {
        if (bingoMessageEl) bingoMessageEl.textContent = "No misses yet. Play a New game first."
        if (bingoQuitBtn) bingoQuitBtn.disabled = true
        return
      }

      kbBingoEnsurePairs()
      kbBingoMode = "practice"
      kbBingoComplete = false

      kbBingoPracticeDeck = Array.from(kbBingoMisses)
      kbShuffleInPlace(kbBingoPracticeDeck)
      kbBingoPracticeIndex = 0
      kbBingoPracticeShown = 0
      kbBingoPracticeTotal = kbBingoPracticeDeck.length

      kbBingoRounds = 0
      kbBingoCorrectCount = 0
      kbBingoCurrentAnswerKey = null

      // Clear any red or green markings. In practice mode we only use the yellow current highlight.
      kbBingoClearHighlights()

      if (bingoNextBtn) {
        bingoNextBtn.textContent = "Next question"
        bingoNextBtn.disabled = true
      }
      if (bingoMessageEl) bingoMessageEl.textContent = ""
      resetAndStartBingoTimer()

      kbBingoPresentRandomPair()
    }

    function quitBingoToEdu() {
      try { kbDbg("quitBingoToEdu", kbMapState()) } catch (e) {}
      if (bingoTimerRunning) pauseBingoTimer()
      showEduScreen()
    }

    if (bingoNextBtn) {
      bingoNextBtn.addEventListener("click", () => {
        try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_next_question_press", { kb_game: "practice_times_tables", kb_mode: kbBingoMode }) } catch (e) {}
        if (kbBingoComplete) return
        kbBingoPresentRandomPair()
      })
    }
    if (bingoQuitBtn) bingoQuitBtn.addEventListener("click", kbBingoStartPracticeMisses)
    if (bingoStartNewBtn) bingoStartNewBtn.addEventListener("click", kbBingoStartNewGame)
    if (bingoRedeemBtn) bingoRedeemBtn.addEventListener("click", quitBingoToEdu)

function showBingoScreen() {
      try { kbDbg("showBingoScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "game") {
        if (timerRunning) pauseTimer()
      }
currentScreen = "bingo"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("practice_times_tables") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = "none"
      if (screenStoreEl) screenStoreEl.style.display = "none"
      if (screenEduEl) screenEduEl.style.display = "none"
      if (screenBingoEl) screenBingoEl.style.display = ""
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
      try { updateAccounts() } catch (e) {}
      try { kbBingoUpdateAccounts() } catch (e) {}
      try { kbUpgradeBingoPairsToButtons() } catch (e) {}
      try { kbBingoStartNewGame() } catch (e) {}
    }




    let countries = []
    let deck = []
    let deckIndex = 0
    let gameComplete = false

    let current = null
    let currentLayer = null
    let pendingBounds = null
    let locked = false
    let rounds = 0
    let correctCount = 0

    // Game mode: "normal" or "practice" (practice misses).
    let mode = "normal"

    // List of unique missed countries (keys) recorded during the current normal game.
    let misses = []
    let missesSet = new Set()

    // Fast lookup for country objects by key.
    let countryByKey = new Map()

    // Timer state (normal game only).
    let timerInterval = null
    let timerStartMs = 0
    let timerElapsedMs = 0
    let timerRunning = false
    let timerStopped = false

    function pad2(n) {
      return String(n).padStart(2, "0")
    }

    function formatTimeHMS(ms) {
      const totalSeconds = Math.max(0, Math.floor(ms / 1000))
      const hours = Math.floor(totalSeconds / 3600)
      const minutes = Math.floor((totalSeconds % 3600) / 60)
      const seconds = totalSeconds % 60
      const hh = String(hours).padStart(2, "0")
      return hh + ":" + pad2(minutes) + ":" + pad2(seconds)
    }

    function setTimerVisible(visible) {
      if (!timerEl) return
      timerEl.style.display = visible ? "" : "none"
    }

    function renderTimer() {
      if (!timerEl) return
      const ms = timerElapsedMs + (timerRunning ? (Date.now() - timerStartMs) : 0)
      timerEl.textContent = "Time: " + formatTimeHMS(ms)
    }

    function startTimer() {
      if (timerStopped) return
      if (mode !== "normal") return
      if (timerRunning) return
      timerRunning = true
      timerStartMs = Date.now()
      if (timerInterval) clearInterval(timerInterval)
      timerInterval = setInterval(renderTimer, 1000)
      renderTimer()
    }

    function pauseTimer() {
      if (!timerRunning) {
        renderTimer()
        return
      }
      timerElapsedMs += Date.now() - timerStartMs
      timerRunning = false
      timerStartMs = 0
      if (timerInterval) clearInterval(timerInterval)
      timerInterval = null
      renderTimer()
    }

    function stopTimer() {
      pauseTimer()
      timerStopped = true
    }

    function resetAndStartTimer() {
      timerElapsedMs = 0
      timerStopped = false
      timerRunning = false
      timerStartMs = 0
      if (timerInterval) clearInterval(timerInterval)
      timerInterval = null
      renderTimer()
      startTimer()
    }
    // Bingo timer (Screen 4)
    let bingoTimerInterval = null
    let bingoTimerStartMs = 0
    let bingoTimerElapsedMs = 0
    let bingoTimerRunning = false
    let bingoTimerStopped = false

    function renderBingoTimer() {
      if (!bingoTimerEl) return
      if (kbBingoMode === "practice") {
        bingoTimerEl.textContent = ""
        return
      }
      const now = Date.now()
      const ms = bingoTimerElapsedMs + (bingoTimerRunning ? (now - bingoTimerStartMs) : 0)
      bingoTimerEl.textContent = "Time: " + formatTimeHMS(ms)
    }

    function startBingoTimer() {
      if (bingoTimerStopped) return
      if (currentScreen !== "bingo") return
      if (bingoTimerRunning) return
      bingoTimerRunning = true
      bingoTimerStartMs = Date.now()
      if (bingoTimerInterval) clearInterval(bingoTimerInterval)
      bingoTimerInterval = setInterval(renderBingoTimer, 1000)
      renderBingoTimer()
    }

    function pauseBingoTimer() {
      if (!bingoTimerRunning) {
        renderBingoTimer()
        return
      }
      const now = Date.now()
      bingoTimerElapsedMs += (now - bingoTimerStartMs)
      bingoTimerRunning = false
      bingoTimerStartMs = 0
      if (bingoTimerInterval) clearInterval(bingoTimerInterval)
      bingoTimerInterval = null
      renderBingoTimer()
    }

    function stopBingoTimer() {
      pauseBingoTimer()
      bingoTimerStopped = true
    }

    function resetAndStartBingoTimer() {
      bingoTimerElapsedMs = 0
      bingoTimerStopped = false
      bingoTimerRunning = false
      bingoTimerStartMs = 0
      if (bingoTimerInterval) clearInterval(bingoTimerInterval)
      bingoTimerInterval = null
      renderBingoTimer()
      startBingoTimer()
    }

    // Pause timers when the tab or window is not active.
    let timerPausedByTab = false
    let bingoTimerPausedByTab = false

    function isRedeemOpen() {
      return currentScreen === "store"
    }

    function handleTabInactive() {
      if (currentScreen === "bingo") {
        if (bingoTimerPausedByTab) return
        if (bingoTimerStopped || kbBingoComplete) return
        bingoTimerPausedByTab = true
        if (bingoTimerRunning) pauseBingoTimer()
        return
      }

      if (timerPausedByTab) return
      if (mode !== "normal") return
      if (timerStopped || gameComplete) return
      timerPausedByTab = true
      if (timerRunning) pauseTimer()
    }

    function handleTabActive() {
      if (currentScreen === "bingo") {
        if (!bingoTimerPausedByTab) return
        bingoTimerPausedByTab = false
        if (bingoTimerStopped || kbBingoComplete) return
        startBingoTimer()
        return
      }

      if (!timerPausedByTab) return
      timerPausedByTab = false
      if (mode !== "normal") return
      if (timerStopped || gameComplete) return
      if (isRedeemOpen()) return
      startTimer()
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) handleTabInactive()
      else handleTabActive()
    })

    window.addEventListener("blur", () => {
      if (document.hidden) return
      handleTabInactive()
    })

    window.addEventListener("focus", () => {
      if (document.hidden) return
      handleTabActive()
    })


    //

    // K-Bucks demo wallet (units = 0.0001 K-Bucks)
    let parentU = 0 * SCALE
    let sponsorU = 0 * SCALE
    let kbGlobalChildU = 0
    let devU = 0
    let kbGlobalPlatformU = 0
    let flowU = toUnits("0.00")  // 0.00
    let flowDec = 2
    let sponsorMatch = 5
    let devCarry = 0
    let platCarry = 0
    function pick(obj, keys) {
      for (const k of keys) {
        if (obj && obj[k] != null && String(obj[k]).trim() !== "") return obj[k]
      }
      return null
    }

    function normNameKey(s) {
      return String(s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase()
        .replace(/&/g, "and")
        .replace(/[^a-z0-9 ]+/g, " ")
        .replace(/\s+/g, " ")
        .trim()
    }

    const NAME_ALIAS_TO_CANON = new Map([
      ["united states of america", "united states"],
      ["russian federation", "russia"],
      ["iran islamic republic of", "iran"],
      ["venezuela bolivarian republic of", "venezuela"],
      ["bolivia plurinational state of", "bolivia"],
      ["tanzania united republic of", "tanzania"],
      ["lao people s democratic republic", "laos"],
      ["viet nam", "vietnam"],
      ["syrian arab republic", "syria"],
      ["moldova republic of", "moldova"],
      ["korea republic of", "south korea"],
      ["korea democratic people s republic of", "north korea"],
      ["czech republic", "czechia"],
      ["cote d ivoire", "cote divoire"],
      ["congo", "republic of the congo"],
      ["congo democratic republic of the", "democratic republic of the congo"],
      ["myanmar burma", "myanmar"],
      ["brunei darussalam", "brunei"],
      ["timor leste", "east timor"],
      ["macedonia", "north macedonia"],
      ["swaziland", "eswatini"],
      ["cape verde", "cabo verde"],
      ["the bahamas", "bahamas"],
      ["turkiye", "turkey"],
      ["türkiye", "turkey"]
])

    function canon(name) {
      const n = normNameKey(name)
      return NAME_ALIAS_TO_CANON.get(n) || n
    }

    function getISO2(props) {
      return pick(props, ["ISO3166-1-Alpha-2", "ISO_A2", "iso_a2", "iso2", "ISO2", "alpha2", "alpha-2", "cca2", "id"])
    }

    function getISO3(props) {
      return pick(props, ["ISO3166-1-Alpha-3", "ISO_A3", "iso_a3", "ADM0_A3", "adm0_a3", "iso3", "ISO3", "alpha3", "alpha-3", "cca3"])
    }

    function geoName(props) {
      if (!props) return null
      return pick(props, [
        "ADMIN", "admin",
        "NAME", "name",
        "NAME_EN", "name_en",
        "SOVEREIGNT", "sovereignt",
        "COUNTRY", "country",
        "Country"
      ])
    }

    function shuffle(arr) {
      const a = arr.slice()
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        const t = a[i]
        a[i] = a[j]
        a[j] = t
      }
      return a
    }

    function pickNOther(n, excludeKey) {
      const pool = countries.filter(c => c.key !== excludeKey)
      return shuffle(pool).slice(0, n)
    }

    function buildPracticeDeck() {
      const arr = []
      for (const k of misses) {
        const c = countryByKey.get(k)
        if (c) arr.push(c)
      }
      deck = shuffle(arr)
      deckIndex = 0
    }


    function clearMapLayer() {
      try {
        const fbuf = (typeof kbGetFrontBuffer === "function") ? kbGetFrontBuffer() : null
        if (fbuf && fbuf.map === map) {
          try { kbClearLayerOn(fbuf) } catch (e) {}
          try { currentLayer = null } catch (e) {}
          return
        }
      } catch (e) {}

      if (currentLayer) {
        try { map.removeLayer(currentLayer) } catch (e) {}
        currentLayer = null
      }
    }

    function setCountryOnMap(feature) {
      clearMapLayer()
      try {
        const nm = feature && feature.properties ? (feature.properties.name || feature.properties.ADMIN || feature.properties.admin || feature.properties.NAME || "") : ""
        kbDbg("setCountryOnMap", { name: nm, now: kbMapState() })
      } catch (e) {}

      currentLayer = L.geoJSON(feature, { style: ORANGE_STYLE }).addTo(map)
      currentLayer.bringToFront()

      try {
        const fbuf = (typeof kbGetFrontBuffer === "function") ? kbGetFrontBuffer() : null
        if (fbuf && fbuf.map === map) fbuf.currentLayer = currentLayer
      } catch (e) {}

      const b = currentLayer.getBounds()
      if (!b || !b.isValid()) return


      // If the map is hidden (for example, the redemption store is open), defer fitBounds
      if (mapDiv && (mapDiv.offsetWidth === 0 || mapDiv.offsetHeight === 0)) {
        pendingBounds = b
        try { kbDbg("setCountryOnMap defer pendingBounds", kbMapState()) } catch (e) {}
        return
      }
      pendingBounds = null

      const size = map.getSize()
      const padY = Math.round(size.y * 0.25)
      const padX = Math.round(size.x * 0.10)

      try {
        kbDbg("setCountryOnMap fitBounds", {
          now: kbMapState(),
          padX: padX,
          padY: padY,
          bounds: (function(){ try { const sw = b.getSouthWest(); const ne = b.getNorthEast(); return { sw: { lat:+sw.lat.toFixed(5), lng:+sw.lng.toFixed(5) }, ne: { lat:+ne.lat.toFixed(5), lng:+ne.lng.toFixed(5) } } } catch(e){ return null } })()
        })
      } catch (e) {}
      try { kbZoomOutAfterNextMoveEnd(map, KB_ZOOM_OUT_AFTER_FIT) } catch (e) {}
      map.fitBounds(b, {
        paddingTopLeft: [padX, padY],
        paddingBottomRight: [padX, padY],
        maxZoom: 13,
        animate: false
      })
      try { setTimeout(() => kbHealTiles("afterFitBounds"), 0) } catch (e) {}
    }

    function fmtParentU(u) {
  return fmtWalletMin2U(u)
}
    function fmtSponsorU(u) {
  return fmtWalletMin2U(u)
}


    function fmtOtherU(u) {
      const x = Number(u)
      if (!Number.isFinite(x)) return "0.00"
      const k = x / SCALE
      if (k === 0) return "0.00"
      return fmtMin2Max5(k)
    }

    
function fmtFlow(u, decimals) {
  return fmtUnitsFlex(u)
}

    function fmtMin2Max5(x) {
      const v = Number(x)
      if (!Number.isFinite(v) || v <= 0) return "0.00"
      const parts = v.toFixed(5).split(".")
      let frac = parts[1].replace(/0+$/, "")
      if (frac.length < 2) frac = frac.padEnd(2, "0")
      return parts[0] + "." + frac
    }

// Format an internal-units value (SCALE = 1e9) with comma separators and minimal decimals.
// No rounding, no extra trailing zeros.
function fmtUnitsTrimU(u) {
  const x = Number(u)
  if (!Number.isFinite(x) || x <= 0) return "0.00"

  const intPart = Math.floor(x / SCALE)
  let fracUnits = Math.floor(x % SCALE)

  const intStr = String(intPart).replace(/\B(?=(\d{3})+(?!\d))/g, ",")

  if (!fracUnits) return intStr

  let frac = String(fracUnits).padStart(9, "0")
  frac = frac.replace(/0+$/, "")
  if (!frac) return intStr

  return intStr + "." + frac
}

// Combined Parent + Sponsors flow per correct answer, returned in internal units.
// We keep full internal precision (up to 9 decimals) and avoid rounding.
function spigotFlowRateU() {
  const parentU = Number(flowU)
  if (!Number.isFinite(parentU) || parentU <= 0) return 0

  let sponsorAddU = 0
  const m = Number(sponsorMatch)
  const sponsorWalletU = Number(sponsorU)

  if (Number.isFinite(sponsorWalletU) && sponsorWalletU > 0 && Number.isFinite(m) && m > 0) {
    // Convert parentU / m into units, truncating (not rounding).
    sponsorAddU = Math.trunc(parentU / m)
    if (sponsorAddU > sponsorWalletU) sponsorAddU = sponsorWalletU
    if (sponsorAddU < 0) sponsorAddU = 0
  }

  return parentU + sponsorAddU
}


    function fmtSponsorFlowRate() {
      // Sponsors pay at a rate derived from the parent flow and the match ratio.
      // If sponsor wallet is empty, sponsor flow rate is 0, mirroring parent flow behavior.
      if (Number(sponsorU) <= 0) return "0.00"

      const m = Number(sponsorMatch)
      if (!Number.isFinite(m) || m <= 0) return "0.00"

      let x = (Number(flowU) / SCALE) / m

      // Do not display a sponsor flow rate higher than the available sponsor wallet.
      const sponsorK = Number(sponsorU) / SCALE
      if (Number.isFinite(sponsorK) && x > sponsorK) x = sponsorK

      return fmtMin2Max5(x)
    }
function spigotFlowRateK() {
  // Combined Parent + Sponsors flow per correct answer, in K-Bucks.
  const parentK = Number(flowU) / SCALE
  if (!Number.isFinite(parentK) || parentK <= 0) return 0

  let sponsorK = 0
  const m = Number(sponsorMatch)
  const sponsorWalletK = Number(sponsorU) / SCALE

  if (Number.isFinite(sponsorWalletK) && sponsorWalletK > 0 && Number.isFinite(m) && m > 0) {
    sponsorK = parentK / m
    if (sponsorK > sponsorWalletK) sponsorK = sponsorWalletK
  }

  return parentK + sponsorK
}

function fmtSpigotFlowRate() {
  return fmtUnitsTrimU(spigotFlowRateU())
}

function spigotKbucksPerHourU() {
  // Estimate: flow per answer * (193 questions * 3600 sec/hour) / (1158 sec per full game) = flow * 600.
  return Math.trunc(spigotFlowRateU() * 600)
}

function fmtSpigotKbucksPerHour() {
  return fmtWalletMin2U(spigotKbucksPerHourU())
}



    function toUnits(val) {
      const raw = String(val == null ? "" : val)
      const cleaned = raw.replace(/,/g, "").trim()
      const x = Number(cleaned)
      if (!Number.isFinite(x)) return 0
      return Math.max(0, Math.round(x * SCALE))
    }

// Parse a money input string into internal units, truncating (not rounding) to 2 decimals.
function toMoneyUnits(val) {
  const raw0 = String(val == null ? "" : val)
  const cleaned = raw0.replace(/,/g, "").trim()
  if (!cleaned) return 0

  let sign = 1
  let s = cleaned
  if (s[0] === "-") { sign = -1; s = s.slice(1) }
  if (s[0] === "+") { s = s.slice(1) }

  const parts = s.split(".")
  const intStr = parts[0] || "0"
  if (!/^[0-9]+$/.test(intStr)) {
    const x = Number(cleaned)
    if (!Number.isFinite(x)) return 0
    const truncated = Math.trunc(x * 100) / 100
    return Math.max(0, Math.trunc(truncated * SCALE))
  }

  let frac = parts.length > 1 ? parts[1] : ""
  // Keep only digits, then keep at most 2, then pad to 2 for cents math.
  frac = String(frac).replace(/[^0-9]/g, "").slice(0, 2)
  while (frac.length < 2) frac += "0"

  const intPart = Number(intStr)
  const cents = Number(frac || "0")

  const units = sign * (intPart * SCALE + cents * (SCALE / 100))
  return Math.max(0, units)
}

// Parse a decimal string into internal units without rounding.
// Keeps up to 9 fractional digits (SCALE = 1e9). Extra digits are dropped.
function parseUnitsNoRound(val) {
  const raw0 = String(val == null ? "" : val)
  const cleaned = raw0.replace(/,/g, "").trim()
  if (!cleaned) return 0

  let s = cleaned
  let sign = 1
  if (s[0] === "-") { sign = -1; s = s.slice(1) }
  if (s[0] === "+") { s = s.slice(1) }

  const parts = s.split(".")
  const intStr = (parts[0] || "0").replace(/[^0-9]/g, "")
  let fracStr = parts.length > 1 ? parts[1] : ""
  fracStr = String(fracStr).replace(/[^0-9]/g, "")

  if (!intStr) return 0

  fracStr = fracStr.slice(0, 9)
  while (fracStr.length < 9) fracStr += "0"

  const intPart = Number(intStr)
  const fracPart = Number(fracStr)

  if (!Number.isFinite(intPart) || !Number.isFinite(fracPart)) return 0

  const u = sign * (intPart * SCALE + fracPart)
  return Math.max(0, u)
}

// Format internal units with comma separators and minimal decimals.
// No padding zeros, no rounding.
function fmtUnitsFlex(u) {
  const x = Number(u)
  if (!Number.isFinite(x) || x <= 0) return "0.00"

  const intPart = Math.floor(x / SCALE)
  let frac = String(Math.floor(x % SCALE)).padStart(9, "0")
  frac = frac.replace(/0+$/, "")

  const intStr = String(intPart).replace(/\B(?=(\d{3})+(?!\d))/g, ",")

  if (!frac) return intStr
  return intStr + "." + frac
}


// Format flow rate for the input box.
// At least 2 decimals, keep extra precision (up to 9 decimals), no rounding.
function fmtFlowInputU(u) {
  return fmtWalletMin2U(u)
}


    
function clampFlowRate() {
  if (!flowRateInput) return

  const raw = String(flowRateInput.value || "")
  let vU = parseUnitsNoRound(raw)
  if (vU < 0) vU = 0
  if (parentU <= 0) vU = 0

  flowU = vU
  flowRateInput.value = fmtFlowInputU(flowU)

  saveWallet()
  updateAccounts()
}

    function clampParentInput() {
      if (!parentInput) return
      const raw = String(parentInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      parentU = vU
      if (parentU <= 0) flowU = 0
      saveWallet()
      // Re-render flow after clamp
      if (flowRateInput) flowRateInput.value = fmtFlowInputU(flowU)
      updateAccounts()
      if (parentInput) parentInput.value = fmtParentU(parentU)}

    function clampSponsorInput() {
      if (!sponsorInput) return
      const raw = String(sponsorInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      sponsorU = vU

      saveWallet()
      updateAccounts()
      if (sponsorInput && document.activeElement !== sponsorInput) sponsorInput.value = fmtSponsorU(sponsorU)
    }

            function clampSponsorMatch() {
      if (!sponsorMatchInput) return
      const raw = String(sponsorMatchInput.value || "").trim()
      let v = Number(raw)

      // Reject non-numeric or out of range. Keep last valid sponsorMatch.
      if (!Number.isFinite(v) || v < 3 || v > 7) {
        sponsorMatchInput.value = String(sponsorMatch)
        return
      }

      sponsorMatch = v

      // Keep whatever the user typed while focused. Otherwise show the numeric value.
      if (document.activeElement !== sponsorMatchInput) sponsorMatchInput.value = String(sponsorMatch)

      saveWallet()
      updateAccounts()
    }

    function formatScorePct(correct, total) {
      if (!total || total <= 0) return ""
      const pct = (correct / total) * 100
      const pct1 = Math.round(pct * 10) / 10
      const pctStr = (pct1 % 1 === 0) ? String(Math.round(pct1)) : String(pct1)
      return " (" + pctStr + "%)"
    }

    function updateScoreDisplay(finalMode) {
      const total = (deck && deck.length) ? deck.length : (countries && countries.length ? countries.length : 0)

      if (mode === "practice") {
        setTimerVisible(false)
        if (progressEl) progressEl.textContent = ""
        const b = total
        const a = Math.min(Math.max(deckIndex || 0, 0), b)
        statusEl.textContent = "Practice misses: " + a + "/" + b
        return
      }

      setTimerVisible(true)

      if (progressEl) {
        const shown = Math.min(Math.max(rounds || 0, 0), total)
        progressEl.textContent = "Progress: " + shown + "/" + total + formatScorePct(shown, total)
      }

      if (finalMode) {
        statusEl.textContent = "Final score: " + correctCount + "/" + rounds + formatScorePct(correctCount, rounds)
        return
      }

      if (rounds <= 0) {
        statusEl.textContent = "Score: 0/0 (0%)"
        return
      }

      statusEl.textContent = "Score: " + correctCount + "/" + rounds + formatScorePct(correctCount, rounds)
    }


    function loadWallet() {
      try {
        const raw = localStorage.getItem("kbucks_wallet_v14")
        if (!raw) return
        const obj = JSON.parse(raw)
        if (Number.isFinite(obj.parentU)) parentU = obj.parentU
        if (Number.isFinite(obj.sponsorU)) sponsorU = obj.sponsorU
        if (Number.isFinite(obj.sponsorMatch)) sponsorMatch = Math.max(0, Number(obj.sponsorMatch))
        if (Number.isFinite(obj.kbGlobalChildU)) kbGlobalChildU = obj.kbGlobalChildU
        if (Number.isFinite(obj.devU)) devU = obj.devU
        if (Number.isFinite(obj.kbGlobalPlatformU)) kbGlobalPlatformU = obj.kbGlobalPlatformU
        if (Number.isFinite(obj.flowU)) flowU = obj.flowU
        if (Number.isFinite(obj.flowDec)) flowDec = obj.flowDec
        if (Number.isFinite(obj.devCarry)) devCarry = obj.devCarry
        if (Number.isFinite(obj.platCarry)) platCarry = obj.platCarry
      } catch (e) {}
    }

    function saveWallet() {
      try {
        localStorage.setItem("kbucks_wallet_v14", JSON.stringify({ parentU, kbGlobalChildU, devU, kbGlobalPlatformU, flowU, flowDec, devCarry, platCarry , sponsorU , sponsorMatch}))
      } catch (e) {}
    }

    function resetWalletDefaults() {
      // Defaults on every refresh
      parentU = 0 * SCALE
      sponsorU = 0
      sponsorMatch = 5
      kbGlobalChildU = 0
      devU = 0
      kbGlobalPlatformU = 0
      flowU = toUnits("0.00")  // 0.00
      flowDec = 2
      devCarry = 0
      platCarry = 0
      if (flowRateInput) flowRateInput.value = "0.00"
      if (parentInput) parentInput.value = "0.00"
      if (sponsorInput) sponsorInput.value = "0.00"
      if (sponsorMatchInput) sponsorMatchInput.value = "5"
      saveWallet()
      updateAccounts()
    }

    

    // Global helpers, shared across games
    function kbSponsorTagAlongU(parentUVal, sponsorUVal, matchRatioVal) {
      const p = Number(parentUVal) || 0
      const s = Number(sponsorUVal) || 0
      const r = Number(matchRatioVal) || 0
      if (p <= 0) return 0
      if (s <= 0) return 0
      if (r <= 0) return 0
      const want = Math.floor(p / r)
      return Math.min(s, want)
    }

    // "Child can earn (from Parent + Sponsors)" is global and sums both games.
    function kbAvailableToEarnForGameU(flowRateUVal, parentUVal, sponsorUVal, matchRatioVal) {
      const flow = Number(flowRateUVal) || 0
      if (!Number.isFinite(flow) || flow <= 0) return 0

      const p = Number(parentUVal) || 0
      if (!Number.isFinite(p) || p <= 0) return 0

      const sponsorAdd = kbSponsorTagAlongU(p, sponsorUVal, matchRatioVal)
      return (p + sponsorAdd) * 0.75
    }

    function kbAvailableToEarnNtcU() {
      return kbAvailableToEarnForGameU(flowU, parentU, sponsorU, sponsorMatch)
    }

    function kbAvailableToEarnBingoU() {
      return kbAvailableToEarnForGameU(kbBingoFlowU, kbBingoParentU, kbBingoSponsorU, kbBingoSponsorMatch)
    }

    function kbComputeAvailableToEarnU() {
      return kbAvailableToEarnNtcU() + kbAvailableToEarnBingoU()
    }
function kbUpdateGlobalBalances() {
      if (redeemBalanceEl) {
        redeemBalanceEl.textContent =
          "Available to redeem (Child K-Bucks): " + "KBU " + fmtOtherU(kbGlobalChildU)
      }
      if (earnBalanceEl) {
        earnBalanceEl.textContent =
          "Available for the Child to earn (from Parent + Sponsors): " + "KBU " + fmtOtherU(kbComputeAvailableToEarnU())
      }
    }

function updateAccounts() {
      if (parentU <= 0) flowU = 0
      if (parentInput && document.activeElement !== parentInput) parentInput.value = fmtParentU(parentU)
      if (sponsorInput && document.activeElement !== sponsorInput) sponsorInput.value = fmtSponsorU(sponsorU)

      if (flowRateInput && document.activeElement !== flowRateInput) flowRateInput.value = fmtFlowInputU(flowU)
      if (sponsorMatchInput && document.activeElement !== sponsorMatchInput) sponsorMatchInput.value = String(sponsorMatch)
      
      if (sponsorFlowRateOut) sponsorFlowRateOut.textContent = fmtSponsorFlowRate()
      if (spigotFlowRateOut) spigotFlowRateOut.textContent = fmtSpigotFlowRate()
      if (spigotKbucksPerHourOut) spigotKbucksPerHourOut.textContent = fmtSpigotKbucksPerHour()
      if (childAcctEl) childAcctEl.textContent = "K-Bucks: " + fmtOtherU(kbGlobalChildU)
      if (devAcctEl) devAcctEl.textContent = "K-Bucks: " + fmtOtherU(devU)
      if (platformAcctEl) platformAcctEl.textContent = "K-Bucks: " + fmtOtherU(kbGlobalPlatformU)
      // Empty-wallet highlight disabled for now
      // if (parentInput) parentInput.classList.toggle("emptyWallet", parentU <= 0)
      // if (sponsorInput) sponsorInput.classList.toggle("emptyWallet", sponsorU <= 0)
      kbUpdateGlobalBalances()
      syncSpigotPaneSize()


    }
        // REDEMPTION_STORE_START
        const STORE_ITEMS = [
              { name: "Plastic Spider Ring", cost: 0.05, image: "plastic_spider_ring.jpg", rating: 4.5, reviews: "1.2M" },
              { name: "STAEDTLER Eraser", cost: 0.10, image: "eraser.png", rating: 4.9, reviews: "123.7K" },
              { name: "Baskin Robins Gift Card", cost: 25.00, image: "baskin_robins_gift_card.jpg", rating: 3.2, reviews: "46.9K" },
              { name: "UGG Boots", cost: 199.00, image: "ugg_boots.jpg", rating: 4.1, reviews: "23.8K" },
              { name: "Sony PlayStation 5 Digital", cost: 399.00, image: "ps5_digital.jpg", rating: 4.7, reviews: "36.1K" },
              { name: "Apple iPhone 17", cost: 799.00, image: "iphone_17.png", rating: 4.9, reviews: "18.5K" }
            ]

// REDEMPTION_STORE_END
            // KB_STORE_MANIFEST_EXPECTED: count=6, minCost=0.05, maxCost=799.00, hash=887d77dd
            const KB_STORE_MANIFEST_EXPECTED = {
              count: 6,
              minCost: "0.05",
              maxCost: "799.00",
              hash: "887d77dd"
            }

            function kbFNV1a32(str) {
              let h = 0x811c9dc5
              for (let i = 0; i < str.length; i++) {
                h ^= (str.charCodeAt(i) & 0xff)
                h = Math.imul(h, 0x01000193) >>> 0
              }
              return ("00000000" + h.toString(16)).slice(-8)
            }

            function kbNormalizeStore(items) {
              return (items || []).map(it => {
                const name = String(it && it.name || "").trim()
                const image = String(it && it.image || "").trim()
                const costNum = Number(it && it.cost)
                const cost = Number.isFinite(costNum) ? costNum.toFixed(2) : ""
                return { name, cost, image }
              })
            }

            function kbComputeStoreHash(items) {
              const normalized = kbNormalizeStore(items)
              const json = JSON.stringify(normalized)
              return kbFNV1a32(json)
            }

            function kbVerifyStoreManifest() {
              try {
                const normalized = kbNormalizeStore(STORE_ITEMS)
                const count = normalized.length
                const costs = normalized.map(x => Number(x.cost)).filter(Number.isFinite)
                const minCost = costs.length ? Math.min(...costs).toFixed(2) : ""
                const maxCost = costs.length ? Math.max(...costs).toFixed(2) : ""
                const hash = kbComputeStoreHash(STORE_ITEMS)

                const exp = KB_STORE_MANIFEST_EXPECTED
                const problems = []
                if (count !== exp.count) problems.push(`count expected ${exp.count} got ${count}`)
                if (minCost !== exp.minCost) problems.push(`minCost expected ${exp.minCost} got ${minCost}`)
                if (maxCost !== exp.maxCost) problems.push(`maxCost expected ${exp.maxCost} got ${maxCost}`)
                if (hash !== exp.hash) problems.push(`hash expected ${exp.hash} got ${hash}`)

                if (problems.length) {
                  console.warn("[K-Bucks] Redemption store manifest changed:", problems.join(", "))
                }
              } catch (e) {}
            }

            function kbWarnIfStoreNotSorted() {
              try {
                for (let i = 1; i < STORE_ITEMS.length; i++) {
                  if (Number(STORE_ITEMS[i].cost) < Number(STORE_ITEMS[i - 1].cost)) {
                    console.warn("[K-Bucks] Redemption store is not sorted by increasing KB price at index", i)
                    return
                  }
                }
              } catch (e) {}
            }

            function kbWarnIfStoreHasDuplicates() {
              try {
                const seen = new Set()
                for (const it of STORE_ITEMS) {
                  const key = String(it && it.name || "").trim().toLowerCase()
                  if (!key) continue
                  if (seen.has(key)) {
                    console.warn("[K-Bucks] Duplicate redemption store item name detected:", it.name)
                    return
                  }
                  seen.add(key)
                }
              } catch (e) {}
            }

            function kbWarnIfBannedStoreItems() {
              try {
                const bannedSubstrings = ["lululemon gift card", "lululemon"]
                for (const it of STORE_ITEMS) {
                  const name = String(it && it.name || "").toLowerCase()
                  for (const bad of bannedSubstrings) {
                    if (name.includes(bad)) {
                      console.warn("[K-Bucks] Banned redemption store item detected:", it.name)
                      return
                    }
                  }
                }
              } catch (e) {}
            }

            (function kbRunGuardrailsOnce() {
              kbVerifyStoreManifest()
              kbWarnIfStoreNotSorted()
              kbWarnIfStoreHasDuplicates()
              kbWarnIfBannedStoreItems()
            })()
function renderStore() {
      if (!storeEl) return

      const wrap = document.createElement("div")
      wrap.className = "storeList"

      for (const it of STORE_ITEMS) {
        const row = document.createElement("div")
        row.className = "storeItem"

        const left = document.createElement("div")
        left.className = "storeLeft"

        if (it.image) {
          const img = document.createElement("img")
          img.className = "storeThumb"
          img.alt = it.name
          img.loading = "lazy"
          img.src = it.image
          left.appendChild(img)
        }

        const meta = document.createElement("div")
        meta.className = "storeMeta"

        const nameEl = document.createElement("div")
        nameEl.innerHTML = "<strong>" + it.name + "</strong>"
        meta.appendChild(nameEl)

        // Rating line (Screen 2)
        if (Number.isFinite(Number(it && it.rating))) {
          const rating = document.createElement("div")
          rating.className = "storeRating"

          const v = Number(it.rating)
          const pct = Math.max(0, Math.min(100, (v / 5) * 100))
          const count = String(it && it.reviews || "").trim()

          rating.innerHTML =
            '<span class="ratingValue">' + v.toFixed(1) + '</span>' +
            '<span class="ratingStarsBox"><span class="starsBase">★★★★★</span><span class="starsFill" style="width:' + pct.toFixed(0) + '%;">★★★★★</span></span>' +
            '<span class="ratingCaret">▾</span>' +
            (count ? '<span class="ratingCount">(' + count + ')</span>' : '')

          meta.appendChild(rating)
        }


        const price = document.createElement("div")
        const costStr = Number(it.cost).toFixed(2)
        price.className = "storePrice"
        price.textContent = "KBU " + costStr
        meta.appendChild(price)

        left.appendChild(meta)

        const btn = document.createElement("button")
        btn.type = "button"
        btn.textContent = "Redeem"

        const costU = toUnits(it.cost)
        btn.disabled = kbGlobalChildU < costU

        btn.addEventListener("click", () => {
          if (btn.disabled) return

          kbGlobalChildU = Math.max(0, kbGlobalChildU - costU)
          saveWallet()
          updateAccounts()
          renderStore()

          const msg = "Redeemed " + it.name + " for KBU " + costStr + "."
          if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = msg
          if (messageEl) messageEl.textContent = msg
          try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_redeem", { kb_item: it.name, kb_item_cost_kbu: Number(costStr) }) } catch (e) {}
        })

        row.appendChild(left)
        row.appendChild(btn)
        wrap.appendChild(row)
      }

      storeEl.innerHTML = ""
      storeEl.appendChild(wrap)
    }
    const EDU_ITEMS = [
      { key: "mm", name: "Practice Times Tables", cost: 0.05, image: "multiplication_table.png" },
      { key: "ntc", name: "Name That Country", cost: 0.10, image: "name_that_country.png" }
    ]

    function renderEdu() {
      if (!eduListEl) return
      // Clear any previous render
      eduListEl.innerHTML = ""

      const wrap = document.createElement("div")
      wrap.className = "storeList"

      for (const it of EDU_ITEMS) {
        const row = document.createElement("div")
        row.className = "storeItem"

        const left = document.createElement("div")
        left.className = "storeLeft"

        if (it.image) {
          const img = document.createElement("img")
          img.className = "storeThumb"
          img.alt = it.name
          img.loading = "lazy"
          img.src = it.image
          left.appendChild(img)
        }

        const meta = document.createElement("div")
        meta.className = "storeMeta"

        const nameEl = document.createElement("div")
        nameEl.innerHTML = "<strong>" + it.name + "</strong>"
        meta.appendChild(nameEl)
        // Rating line (Screen 1)
        if (it.key === "ntc" || it.key === "mm") {
          const rating = document.createElement("div")
          rating.className = "storeRating"

          if (it.key === "ntc") {
            rating.innerHTML =
              '<span class="ratingValue">4.8</span>' +
              '<span class="ratingStars">★★★★★</span>' +
              '<span class="ratingCaret">▾</span>' +
              '<span class="ratingCount">(53.3K)</span>'
          } else {
            rating.innerHTML =
              '<span class="ratingValue">4.5</span>' +
              '<span class="ratingStarsBox"><span class="starsBase">★★★★★</span><span class="starsFill" style="width:90%;">★★★★★</span></span>' +
              '<span class="ratingCaret">▾</span>' +
              '<span class="ratingCount">(8.6K)</span>'
          }

          meta.appendChild(rating)
        }

        // Grade line (Screen 1) placed below rating.
        if (it.key === "mm" || it.key === "ntc") {
          const grade = document.createElement("div")
          grade.className = "storeRating"
          grade.textContent = (it.key === "mm") ? "Math: Grade 3" : "Geography: Grade 7"
          meta.appendChild(grade)
        }

        // Funds lines (Screen 1) replace the single KBU cost for the two games.
        if (it.key === "ntc") {
                    const spacer = document.createElement("div")

                    spacer.className = "eduFundsSpacer"

                    meta.appendChild(spacer)



          const BLANK = "\u00A0"

          const parentStr = fmtOtherU(parentU)

          const sponsorStr = fmtOtherU(sponsorU)

          const availStr = fmtOtherU(kbAvailableToEarnNtcU())

          const hideFunds = parentStr === "0.00" && sponsorStr === "0.00" && availStr === "0.00"


          const kb = document.createElement("div")

          kb.className = "eduFundsLine"

          kb.style.fontWeight = "700"

          kb.textContent = hideFunds ? BLANK : "K-Bucks"

          meta.appendChild(kb)


          const p = document.createElement("div")

          p.className = "eduFundsLine"

          p.textContent = hideFunds ? BLANK : ("Parent: " + parentStr)

          meta.appendChild(p)


          const s = document.createElement("div")

          s.className = "eduFundsLine"

          s.textContent = hideFunds ? BLANK : ("Sponsors: " + sponsorStr)

          meta.appendChild(s)


          const a = document.createElement("div")

          a.className = "eduFundsLine"

          a.textContent = hideFunds ? BLANK : ("Available: " + availStr)

          meta.appendChild(a)        } else if (it.key === "mm") {
                    const spacer = document.createElement("div")

                    spacer.className = "eduFundsSpacer"

                    meta.appendChild(spacer)



          const BLANK = "\u00A0"

          const parentStr = fmtOtherU(kbBingoParentU)

          const sponsorStr = fmtOtherU(kbBingoSponsorU)

          const availStr = fmtOtherU(kbAvailableToEarnBingoU())

          const hideFunds = parentStr === "0.00" && sponsorStr === "0.00" && availStr === "0.00"


          const kb = document.createElement("div")

          kb.className = "eduFundsLine"

          kb.style.fontWeight = "700"

          kb.textContent = hideFunds ? BLANK : "K-Bucks"

          meta.appendChild(kb)


          const p = document.createElement("div")

          p.className = "eduFundsLine"

          p.textContent = hideFunds ? BLANK : ("Parent: " + parentStr)

          meta.appendChild(p)


          const s = document.createElement("div")

          s.className = "eduFundsLine"

          s.textContent = hideFunds ? BLANK : ("Sponsors: " + sponsorStr)

          meta.appendChild(s)


          const a = document.createElement("div")

          a.className = "eduFundsLine"

          a.textContent = hideFunds ? BLANK : ("Available: " + availStr)

          meta.appendChild(a)        } else {
          const price = document.createElement("div")
          const costStr = Number(it.cost).toFixed(2)
          price.className = "storeCost"
          price.textContent = "KBU " + costStr
          meta.appendChild(price)
        }

        left.appendChild(meta)

        const btn = document.createElement("button")
        btn.type = "button"
        btn.textContent = "Play"

        btn.addEventListener("click", () => {
          if (it.key === "ntc") {
            // Start a new Name That Country game (Screen 3)
            showGameScreen()
            try { kbEnsureLeafletMap("play-ntc") } catch (e) {}
            // Wait for the game screen to be visible and Leaflet to have a stable size.
            requestAnimationFrame(() => {
              try { syncMapHeight() } catch (e) {}
              try { if (map && map.invalidateSize) map.invalidateSize({ animate: false, pan: false }) } catch (e) {}
              try { kbNormalizeMapView("play-ntc-after-invalidate") } catch (e) {}
              requestAnimationFrame(() => {
                try { syncMapHeight() } catch (e) {}
                try { if (map && map.invalidateSize) map.invalidateSize({ animate: false, pan: false }) } catch (e) {}
                try { kbNormalizeMapView("play-ntc-before-startNewGame") } catch (e) {}
                // Always start a fresh game on entry.
                startNewGame()
              })
            })
          } else {
            // Practice Times Tables (Screen 4)
            showBingoScreen()
          }
        })

        row.appendChild(left)
        row.appendChild(btn)
        wrap.appendChild(row)
      }

      eduListEl.appendChild(wrap)
    }


    function openRedeem() {
  if (!redeemPane) return
  if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = ""
  updateAccounts()
  if (mode === "normal" && !gameComplete) pauseTimer()
  renderStore()
  syncMapHeight()
  showStoreScreen()
}

function closeRedeem() {
  if (!redeemPane) return
  if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = ""
  showEduScreen()
}

function openStoreFromEdu() {
  if (!redeemPane) return
  if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = ""
  updateAccounts()
  renderStore()
  showStoreScreen()
}

function quitGameToEdu() {
  if (mode === "normal" && !gameComplete) pauseTimer()
  showEduScreen()
}


    function toggleRedeem() {
      if (!redeemPane) return
      if (currentScreen === "store") closeRedeem()
      else openRedeem()
    }


    function syncMapHeight() {
      if (!mapDiv) return
      const slot = mapSlotEl || document.getElementById("mapSlot")
      const h = slot ? slot.clientHeight : (sideEl ? sideEl.offsetHeight : 0)
      try { kbDbg("syncMapHeight h", { h: h, now: kbMapState() }) } catch (e) {}
      if (!h || h <= 0) return

      const desired = h + "px"
      const seq = (map && map._kbSeq) ? map._kbSeq : 0
      const forceForNewMap = seq && window.kbLastSyncMapSeq !== seq

      // Only touch layout, and invalidate Leaflet, when the height actually changes,
      // or when the Leaflet map was just recreated.
      if (window.kbLastSyncMapH === desired && !forceForNewMap) return
      window.kbLastSyncMapH = desired
      if (seq) window.kbLastSyncMapSeq = seq

      mapDiv.style.height = desired

      try {
        // Avoid panning during invalidate, which can interact badly with an in-flight fitBounds.
        if (map && map.invalidateSize) {
          try { map.invalidateSize({ animate: false, pan: false }) } catch (e) { map.invalidateSize() }
        }
      } catch (e) {}
      try {
        const backBuf = kbGetBackBuffer()
        if (backBuf && backBuf.map && backBuf.map.invalidateSize) {
          try { backBuf.map.invalidateSize({ animate: false, pan: false }) } catch (e) { backBuf.map.invalidateSize() }
        }
      } catch (e) {}
      try { kbDbg("syncMapHeight invalidateSize", kbMapState()) } catch (e) {}
    }

    function resetUIForNewQuestion() {
      answersEl.innerHTML = ""
      if (messageEl) messageEl.textContent = ""
      nextBtn.disabled = true
      locked = false
      try { kbUpdateNextBtnEnabled() } catch (e) {}
    }

    // Double-buffer prebuild state for Name That Country
    let kbPrebuildJobId = 0
    let kbPrebuilt = null
    let kbPrebuildReady = true

    function kbResetPrebuild(reason) {
      kbPrebuildJobId += 1
      kbPrebuilt = null
      kbPrebuildReady = true
      try { kbUpdateNextBtnEnabled() } catch (e) {}
      try { kbDbg("resetPrebuild", { reason: reason }) } catch (e) {}
    }

    function kbUpdateNextBtnEnabled() {
      if (!nextBtn) return
      // Next question is enabled immediately after an answer is selected.
      // We still prebuild the next map in the background, but we do not gate the button on prebuild readiness.
      if (!locked) {
        nextBtn.disabled = true
        return
      }
      nextBtn.disabled = false
    }

    function kbIsMapVisibleForPrebuild() {
      try {
        if (!mapDiv) return false
        return !(mapDiv.offsetWidth === 0 || mapDiv.offsetHeight === 0)
      } catch (e) {
        return false
      }
    }

    function kbClearLayerOn(buf) {
      try {
        if (buf && buf.map && buf.currentLayer) {
          buf.map.removeLayer(buf.currentLayer)
        }
      } catch (e) {}
      try { if (buf) buf.currentLayer = null } catch (e) {}
    }

    function kbSetCountryOnBuffer(buf, feature) {
      if (!buf || !buf.map) return null
      kbClearLayerOn(buf)
      try {
        buf.currentLayer = L.geoJSON(feature, { style: ORANGE_STYLE }).addTo(buf.map)
        try { buf.currentLayer.bringToFront() } catch (e) {}
      } catch (e) {
        buf.currentLayer = null
      }
      return buf.currentLayer
    }

    function kbFitBoundsOnBuffer(buf, layer) {
      try {
        if (!buf || !buf.map || !layer) return
        const b = layer.getBounds()
        if (!b || !b.isValid()) return

        const size = buf.map.getSize()
        const padY = Math.round(size.y * 0.25)
        const padX = Math.round(size.x * 0.10)

        try { kbZoomOutAfterNextMoveEnd(buf.map, KB_ZOOM_OUT_AFTER_FIT) } catch (e) {}
        buf.map.fitBounds(b, {
          paddingTopLeft: [padX, padY],
          paddingBottomRight: [padX, padY],
          maxZoom: 13,
          animate: false
        })
      } catch (e) {}
    }

    function kbStartPrebuildForIndex(nextIndex, reason) {
      if (mode !== "normal" && mode !== "practice") return
      if (!deck || nextIndex == null || nextIndex >= deck.length) {
        kbPrebuildReady = true
        kbPrebuilt = null
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      kbPrebuildJobId += 1
      const jobId = kbPrebuildJobId

      const pick = deck[nextIndex]
      if (!pick) {
        kbPrebuildReady = true
        kbPrebuilt = null
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      kbPrebuilt = { index: nextIndex, key: pick.key }
      kbPrebuildReady = false
      try { kbUpdateNextBtnEnabled() } catch (e) {}
      try { kbDbg("prebuild start", { reason: reason, nextIndex: nextIndex, key: pick.key }) } catch (e) {}

      try { kbEnsureLeafletMap("prebuild") } catch (e) {}

      const buf = kbGetBackBuffer()
      if (!buf || !buf.map) {
        kbPrebuildReady = true
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      if (!kbIsMapVisibleForPrebuild()) {
        kbPrebuildReady = true
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      // Build the next country's layer on the hidden buffer
      let layer = null
      try { layer = kbSetCountryOnBuffer(buf, pick.feature) } catch (e) {}
      try { kbFitBoundsOnBuffer(buf, layer) } catch (e) {}
      try { kbHealTilesOnBuffer(buf, "prebuild") } catch (e) {}

      let finished = false
      const finish = (why) => {
        if (finished) return
        finished = true
        if (jobId !== kbPrebuildJobId) return
        kbPrebuildReady = true
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        try { kbDbg("prebuild ready", { why: why, nextIndex: nextIndex }) } catch (e) {}
      }

      try {
        if (buf.map && buf.map.once) {
          buf.map.once("moveend", () => {
            const moveEndAt = Date.now()
            let initial = null
            try {
              if (buf.tileLayer && typeof buf.tileLayer._tilesToLoad === "number") initial = buf.tileLayer._tilesToLoad
            } catch (e) {}

            const thrFor = (init) => Math.max(2, Math.ceil(init * 0.30))

            let tries = 0
            const poll = () => {
              if (finished) return
              if (jobId !== kbPrebuildJobId) return
              tries += 1

              let remaining = null
              try {
                if (buf.tileLayer && typeof buf.tileLayer._tilesToLoad === "number") remaining = buf.tileLayer._tilesToLoad
              } catch (e) {}

              if (remaining != null) {
                if (remaining <= 0) return finish("tiles ready")
                if (initial == null) initial = remaining
                if (initial != null && remaining <= thrFor(initial)) return finish("tiles soft ready")
              }

              if (tries < 10) setTimeout(poll, 80)
            }

            try {
              if (buf.tileLayer && buf.tileLayer.once) {
                buf.tileLayer.once("tileload", () => {
                  const delay = Math.max(120, 180 - (Date.now() - moveEndAt))
                  setTimeout(() => finish("first tile"), delay)
                })
                buf.tileLayer.once("load", () => finish("tileLayer load"))
              }
            } catch (e) {}

            setTimeout(poll, 60)

            // Short timeout after moveend so Next question does not wait for full tile completion.
            setTimeout(() => finish("timeout-after-moveend"), 650)
          })
        }
      } catch (e) {}

      // Safety timeout so we never deadlock the Next question button
      setTimeout(() => finish("timeout"), 1600)
    }


    function renderAnswers(options) {
      answersEl.innerHTML = ""

      for (const opt of options) {
        const li = document.createElement("li")
        const btn = document.createElement("button")
        btn.className = "ansBtn"
        btn.type = "button"

        const bullet = document.createElement("span")
        bullet.className = "bullet"
        bullet.textContent = "•"

        const label = document.createElement("span")
        label.className = "label"
        label.textContent = opt.displayName

        const mark = document.createElement("span")
        mark.className = "mark"
        mark.textContent = ""

        btn.appendChild(bullet)
        btn.appendChild(label)
        btn.appendChild(mark)

        btn.addEventListener("click", () => onGuess(opt.key, btn))

        li.appendChild(btn)
        answersEl.appendChild(li)
      }
    }

    function lockAnswers() {
      const allButtons = Array.from(document.querySelectorAll("#quizPane .ansBtn"))
      for (const b of allButtons) b.disabled = true
      return allButtons
    }

    function onGuess(chosenKey, chosenBtn) {
  if (locked) return
  locked = true
  kbUpdateNextBtnEnabled()

  rounds += 1

  let kbTelemetryIsCorrect = false
  let kbTelemetryTotalPayU = 0
  let kbTelemetryParentPayU = 0
  let kbTelemetrySponsorPayU = 0

  const correctKey = current.key
  const correctDisplay = current.displayName
  const allButtons = lockAnswers()

  if (chosenKey === correctKey) {
    kbTelemetryIsCorrect = true
    correctCount += 1
    chosenBtn.classList.add("correct")
    chosenBtn.querySelector(".mark").textContent = "✓"

    if (mode === "normal") {
      // Reward payout on a correct answer is the sum of the parent and sponsor flow rates.
      // That sum is distributed 75% to Child, 12.5% to Developer, 12.5% to Platform.
      const parentFlowU = Math.min(flowU, parentU)
      const parentPayU = parentFlowU > 0 ? parentFlowU : 0

      let sponsorPayU = 0
      const m = Number(sponsorMatch)
      if (parentFlowU > 0 && Number.isFinite(m) && m > 0 && sponsorU > 0) {
        const sponsorFlowU = Math.floor(Number(parentFlowU) / m)
        if (sponsorFlowU > 0) sponsorPayU = Math.min(sponsorFlowU, sponsorU)
      }

      const totalPayU = parentPayU + sponsorPayU

      kbTelemetryParentPayU = parentPayU
      kbTelemetrySponsorPayU = sponsorPayU
      kbTelemetryTotalPayU = totalPayU

      if (totalPayU > 0) {
        // Split: 75% child, 12.5% content developer, 12.5% platform.
        // Use carry remainders (denominator 8) to avoid systematic rounding bias.
        const devNumer = totalPayU + devCarry
        const platNumer = totalPayU + platCarry

        const devAdd = Math.floor(devNumer / 8)
        const platAdd = Math.floor(platNumer / 8)

        devCarry = devNumer % 8
        platCarry = platNumer % 8

        const childAdd = totalPayU - devAdd - platAdd

        parentU -= parentPayU
        sponsorU -= sponsorPayU
        kbGlobalChildU += childAdd
        devU += devAdd
        kbGlobalPlatformU += platAdd

        saveWallet()
        clampFlowRate()
        updateAccounts()
      } else {
        if (messageEl) messageEl.textContent = ""
      }
    } else {
      // Practice misses mode, no money flows.
      if (messageEl) messageEl.textContent = ""
    }
  } else {
    chosenBtn.classList.add("wrong")
    chosenBtn.querySelector(".mark").textContent = "✕"

    const correctBtn = allButtons.find(b => b.querySelector(".label").textContent === correctDisplay)
    if (correctBtn) {
      correctBtn.classList.add("correct")
      correctBtn.querySelector(".mark").textContent = "✓"
    }

    if (mode === "normal") {
      // Record a miss (unique countries) for Practice misses mode.
      if (!missesSet.has(correctKey)) {
        missesSet.add(correctKey)
        misses.push(correctKey)
      }
      if (quitBtn) quitBtn.disabled = misses.length === 0
    }
  }

  if (mode === "practice") {
    nextBtn.textContent = "Next question"
    updateScoreDisplay(false)
  } else {
    const done = rounds >= deck.length
    if (done) {
      gameComplete = true
      stopTimer()
      nextBtn.textContent = "Game over"
      nextBtn.disabled = true
      updateScoreDisplay(true)
    } else {
      nextBtn.textContent = "Next question"
      updateScoreDisplay(false)
    }
  }

  try {
    if (window.KB_TELEMETRY) {
      const toKbu = (u) => {
        const n = Number(u) || 0
        return n > 0 ? (n / SCALE) : 0
      }
      window.KB_TELEMETRY.event("kb_answer", {
        kb_game: "name_that_country",
        kb_mode: mode,
        kb_correct: kbTelemetryIsCorrect ? 1 : 0,
        kb_round: rounds,
        kb_total_pay_kbu: toKbu(kbTelemetryTotalPayU),
        kb_parent_pay_kbu: toKbu(kbTelemetryParentPayU),
        kb_sponsor_pay_kbu: toKbu(kbTelemetrySponsorPayU)
      })
    }
  } catch (e) {}

  syncMapHeight()
}



    function nextQuestion() {
      try { kbDbg("nextQuestion", kbMapState()) } catch (e) {}

  resetUIForNewQuestion()

  if (mode === "practice") {
    // Practice misses: infinite loop over missed countries.
    if (misses.length === 0) {
      if (messageEl) messageEl.textContent = "No misses yet. Play a New game first."
      nextBtn.disabled = true
      if (quitBtn) quitBtn.disabled = true
      syncMapHeight()
      return
    }

    if (!deck || deck.length === 0 || deckIndex >= deck.length) {
      buildPracticeDeck()
    }

    const currentIndex = deckIndex
    const pickOne = deck[deckIndex]
    deckIndex += 1
    current = pickOne

    let usedPrebuilt = false
    try {
      if (kbPrebuildReady && kbPrebuilt && kbPrebuilt.index === currentIndex && kbPrebuilt.key === pickOne.key) {
        kbSwapMapBuffers("use-prebuilt")
        usedPrebuilt = true
        kbPrebuilt = null
        kbPrebuildReady = true
      }
    } catch (e) {}

    if (!usedPrebuilt) {
      setCountryOnMap(pickOne.feature)

    try { kbResetPrebuild("practice") } catch (e) {}
    }

    const others = pickNOther(9, pickOne.key)
    const options = shuffle([pickOne, ...others])

    renderAnswers(options)

    try { kbStartPrebuildForIndex(deckIndex, "after-render") } catch (e) {}

    nextBtn.textContent = "Next question"
    updateScoreDisplay(false)

    syncMapHeight()
    return
  }

  if (gameComplete) return

  if (deckIndex >= deck.length) {
    gameComplete = true
    nextBtn.textContent = "Game over"
    nextBtn.disabled = true
    updateScoreDisplay(true)
    syncMapHeight()
    return
  }

  const currentIndex = deckIndex
  const pickOne = deck[deckIndex]
  deckIndex += 1
  current = pickOne

  let usedPrebuilt = false
  try {
    if (kbPrebuildReady && kbPrebuilt && kbPrebuilt.index === currentIndex && kbPrebuilt.key === pickOne.key) {
      kbSwapMapBuffers("use-prebuilt-normal")
      usedPrebuilt = true
      kbPrebuilt = null
      kbPrebuildReady = true
    }
  } catch (e) {}

  if (!usedPrebuilt) {
    setCountryOnMap(pickOne.feature)
  }

  const others = pickNOther(9, pickOne.key)
  const options = shuffle([pickOne, ...others])

  renderAnswers(options)
  updateScoreDisplay(false)

  try { kbStartPrebuildForIndex(deckIndex, "after-render-normal") } catch (e) {}

  syncMapHeight()
}




    function startNewGame() {
      try { kbNormalizeMapView("startNewGame") } catch (e) {}

      try { kbDbg("startNewGame", kbMapState()) } catch (e) {}

      overlay.classList.remove("show")

      rounds = 0
      correctCount = 0
      gameComplete = false

      mode = "normal"

      try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_game_start", { kb_game: "name_that_country" }) } catch (e) {}

      try { kbResetPrebuild("startNewGame") } catch (e) {}
      try { kbClearLayerOn(kbGetFrontBuffer()) } catch (e) {}
      try { kbClearLayerOn(kbGetBackBuffer()) } catch (e) {}

      setTimerVisible(true)
      resetAndStartTimer()
      misses = []
      missesSet = new Set()
      if (quitBtn) quitBtn.disabled = true

      deck = shuffle(countries)
      deckIndex = 0

      nextBtn.textContent = "Next question"
      updateScoreDisplay(false)

      updateAccounts()
      if (messageEl) messageEl.textContent = ""

      nextQuestion()
    }

    

function startPracticeMisses() {
  overlay.classList.remove("show")

  pauseTimer()
  setTimerVisible(false)

  if (misses.length === 0) {
    if (messageEl) messageEl.textContent = "No misses yet. Play a New game first."
    if (quitBtn) quitBtn.disabled = true
    return
  }

  mode = "practice"
  rounds = 0
  correctCount = 0
  gameComplete = false

  buildPracticeDeck()

      if (!deck || deck.length === 0) {
        if (messageEl) messageEl.textContent = "No missed countries could be loaded. Start a New game and make a few misses first."
        nextBtn.disabled = true
        if (quitBtn) quitBtn.disabled = true
        return
      }

      nextBtn.textContent = "Next question"
  updateScoreDisplay(false)
  if (messageEl) messageEl.textContent = ""
  nextQuestion()
}

function quitGame() {
      overlay.classList.add("show")
      document.getElementById("finalText").textContent =
        "Final score: " + correctCount + "/" + rounds + "."
    }

    nextBtn.addEventListener("click", () => {
      try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_next_question_press", { kb_game: "name_that_country", kb_mode: mode }) } catch (e) {}
      if (gameComplete) return
      nextQuestion()
    })

    quitBtn.addEventListener("click", startPracticeMisses)
    if (startNewBtn) startNewBtn.addEventListener("click", () => {
      // Reset score and country deck, keep wallets and settings.
      startNewGame()
    })

    restartBtn.addEventListener("click", startNewGame)

    redeemBtn.addEventListener("click", quitGameToEdu)
    closeRedeemBtn.addEventListener("click", closeRedeem)
    if (openStoreBtn) openStoreBtn.addEventListener("click", openStoreFromEdu)
    if (flowRateInput) {
      flowRateInput.addEventListener("change", clampFlowRate)
      flowRateInput.addEventListener("blur", clampFlowRate)
    }
    // Parent wallet parsing should not run on each keystroke.
    // Commit when the user presses Enter or when the field loses focus.
    if (parentInput) {
      parentInput.addEventListener("blur", clampParentInput)
      parentInput.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return
        e.preventDefault()
        // Blur triggers clampParentInput, matching click-outside behavior.
        parentInput.blur()
      })
    }

    if (sponsorInput) {
      sponsorInput.addEventListener("change", clampSponsorInput)
      sponsorInput.addEventListener("blur", clampSponsorInput)
    }

    if (sponsorMatchInput) {
      sponsorMatchInput.addEventListener("change", clampSponsorMatch)


// When user presses Enter in any input, commit parsing (change) and then blur to apply formatting.
for (const el of document.querySelectorAll("input")) {
  el.addEventListener("keydown", (e) => {
    if (el === parentInput) return
    if (e.key !== "Enter") return
    e.preventDefault()
    el.dispatchEvent(new Event("change", { bubbles: true }))
    el.blur()
  })
}
      sponsorMatchInput.addEventListener("blur", clampSponsorMatch)
    }

    // Bingo (Screen 4) wallet controls.
    if (bingoFlowRateInput) {
      bingoFlowRateInput.addEventListener("change", kbBingoClampFlowRate)
      bingoFlowRateInput.addEventListener("blur", kbBingoClampFlowRate)
    }
    if (bingoParentInput) {
      bingoParentInput.addEventListener("blur", kbBingoClampParentInput)
      bingoParentInput.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return
        e.preventDefault()
        bingoParentInput.blur()
      })
    }
    if (bingoSponsorInput) {
      bingoSponsorInput.addEventListener("change", kbBingoClampSponsorInput)
      bingoSponsorInput.addEventListener("blur", kbBingoClampSponsorInput)
    }
    if (bingoSponsorMatchInput) {
      bingoSponsorMatchInput.addEventListener("change", kbBingoClampSponsorMatch)
      bingoSponsorMatchInput.addEventListener("blur", kbBingoClampSponsorMatch)
    }
    try { kbBingoUpdateAccounts() } catch (e) {}


    const ro = new ResizeObserver(() => syncMapHeight())
    ro.observe(sideEl)
    window.addEventListener("resize", () => syncMapHeight())

    async function loadCountries() {
      updateScoreDisplay(false)

      const [unRes, geoRes] = await Promise.all([
        fetch(UN_MEMBERS_URL),
        fetch("countries.geojson")
      ])

      if (!unRes.ok) throw new Error("Could not load UN members list")
      if (!geoRes.ok) throw new Error("Could not load countries.geojson")

      const unRaw = await unRes.json()
      const gj = await geoRes.json()

      const unArr = Array.isArray(unRaw) ? unRaw : []

      const unByA2 = new Map()
      const unByA3 = new Map()
      const unByCanonName = new Map()

      for (const x of unArr) {
        if (!x || (x.unMember !== true && String(x.cca3 || "").toUpperCase() !== "GNB")) continue

        const cca2 = String(x.cca2 || "").toUpperCase()
        const cca3 = String(x.cca3 || "").toUpperCase()
        const common = x.name && x.name.common ? String(x.name.common) : ""
        const official = x.name && x.name.official ? String(x.name.official) : ""

        const key = cca3 || cca2 || canon(common) || canon(official)
        const entry = { key, cca2, cca3, common, official }

        if (cca2) unByA2.set(cca2, entry)
        if (cca3) unByA3.set(cca3, entry)

        if (common) unByCanonName.set(canon(common), entry)
        if (official) unByCanonName.set(canon(official), entry)
      }

      const feats = (gj && gj.features) ? gj.features : []

      const matched = []
      for (const f of feats) {
        const props = f.properties || {}
        const name = geoName(props)
        if (!name) continue

        const iso2u = String(getISO2(props) || "").toUpperCase()
        const iso3u = String(getISO3(props) || "").toUpperCase()

        let entry = null

        if (iso3u && unByA3.has(iso3u)) entry = unByA3.get(iso3u)
        else if (iso2u && unByA2.has(iso2u)) entry = unByA2.get(iso2u)
        else {
          const cn = canon(name)
          if (unByCanonName.has(cn)) entry = unByCanonName.get(cn)
        }

        if (!entry) continue

        let displayName = entry.common || entry.official || name

        // Fix diacritics for consistent display
        if (normNameKey(displayName) === "sao tome and principe") displayName = "Sao Tome and Principe"

        matched.push({
          key: entry.key,
          displayName,
          feature: f
        })
      }

      const seen = new Set()
      countries = matched.filter(x => {
        if (!x.key) return false
        if (seen.has(x.key)) return false
        seen.add(x.key)
        return true
      })

      if (countries.length < 150) {
        throw new Error("UN filter left too few countries")
      }

// Build a lookup map so Practice misses can quickly map keys to country objects.
countryByKey = new Map()
for (const c of countries) countryByKey.set(c.key, c)

    }

    // Ensure Screen 1 content is rendered on initial load
    try { showEduScreen() } catch (e) {}

    loadCountries()
      .then(() => {
        resetWalletDefaults()
flowDec = 2
        if (flowRateInput) flowRateInput.value = fmtFlowInputU(flowU)
        clampFlowRate()
        updateAccounts()
        // Do not auto-start Name That Country on initial load.
        // The game starts when the user presses Play.
        syncMapHeight()
      })
      .catch(err => {
        if (messageEl) messageEl.textContent = "Error: " + err.message
        syncMapHeight()
      })
  
  
  
  
  
  
  
  
  
  </script>

</body>
</html>