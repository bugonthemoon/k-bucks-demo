<!DOCTYPE html>

<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FC0XXR6EFQ"></script>
<script>
      window.dataLayer = window.dataLayer || []
      function gtag(){dataLayer.push(arguments)}
      gtag("js", new Date())

      function kbGetOrCreateAnonUserId() {
        try {
          const k = "kb_anon_user_id_v1"
          const existing = localStorage.getItem(k)
          if (existing && existing.length > 6) return existing
          const id =
            (window.crypto && typeof window.crypto.randomUUID === "function")
              ? window.crypto.randomUUID()
              : ("kb-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16))
          localStorage.setItem(k, id)
          return id
        } catch (e) {
          return "kb-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16)
        }
      }

      window.KB_BUILD_VERSION = "0.2.0";

  // Leaflet seam mitigations

  function kbIsNearlyInteger(n) {
    return Math.abs(n - Math.round(n)) < 1e-6
  }

  function kbUpdateDprClass() {
    const dpr = window.devicePixelRatio || 1
    const html = document.documentElement
    const nonInt = !kbIsNearlyInteger(dpr)
    const lowFrac = nonInt && dpr > 1 && dpr < 1.3
    html.classList.toggle("kb-nonIntegerDpr", nonInt)
    html.classList.toggle("kb-lowFracDpr", lowFrac)
    html.style.setProperty("--kb-device-pixel-ratio", String(dpr))
  }

  let kbDprClassRaf = 0
  function kbScheduleDprClassUpdate() {
    if (kbDprClassRaf) return
    kbDprClassRaf = requestAnimationFrame(() => {
      kbDprClassRaf = 0
      kbUpdateDprClass()
    })
  }

  let kbDprBurstSeq = 0
  function kbScheduleDprClassUpdateBurst() {
    kbScheduleDprClassUpdate()
    const seq = ++kbDprBurstSeq
    setTimeout(() => { if (seq === kbDprBurstSeq) kbScheduleDprClassUpdate() }, 160)
    setTimeout(() => { if (seq === kbDprBurstSeq) kbScheduleDprClassUpdate() }, 360)
  }

  window.addEventListener("resize", kbScheduleDprClassUpdateBurst)
  window.addEventListener("orientationchange", kbScheduleDprClassUpdateBurst)
  if (window.visualViewport) window.visualViewport.addEventListener("resize", kbScheduleDprClassUpdateBurst)
  kbUpdateDprClass()

  function kbInstallLeafletWheelZoomHeal(map) {
    if (!map || map._kbWheelHealInstalled) return
    map._kbWheelHealInstalled = true

    const container = map.getContainer()
    let timer = 0
    let lastWheelAt = 0
    const delayMs = 160

    function scheduleHeal() {
      if (timer) clearTimeout(timer)
      timer = setTimeout(() => {
        timer = 0
        try {
          kbHealTiles("wheel_zoom_settled", { invalidate: true, redraw: true })
        } catch (e) {}
      }, delayMs)
    }

    container.addEventListener("wheel", () => {
      lastWheelAt = performance.now()
      scheduleHeal()
    }, { passive: true })

    map.on("zoomend", () => {
      if (performance.now() - lastWheelAt < 900) scheduleHeal()
    })
  }
      const KB_GA_MEASUREMENT_ID = "G-FC0XXR6EFQ"
      const KB_ANON_USER_ID = kbGetOrCreateAnonUserId()

      gtag("config", KB_GA_MEASUREMENT_ID, {
        user_id: KB_ANON_USER_ID,
        send_page_view: true
      })

      window.KB_TELEMETRY = (function () {
        function safe(fn) {
          try { fn() } catch (e) {}
        }

        function ready() {
          return typeof window.gtag === "function"
        }

        function event(name, params) {
          safe(() => {
            if (!ready()) return
            const base = { kb_build_version: window.KB_BUILD_VERSION || "" }
            if (typeof name === "string" && name.indexOf("kb_") === 0) base.kb_anon_user_id = KB_ANON_USER_ID
            const p = Object.assign(base, params || {})
            window.gtag("event", name, p)
          })
        }

        function screen(name) {
          event("kb_screen_view", { kb_screen: name })
        }

        function sessionStart() {
          safe(() => {
            const k = "kb_session_started_v1"
            if (sessionStorage.getItem(k)) return
            sessionStorage.setItem(k, "1")
            event("kb_session_start", { kb_anon_user_id: KB_ANON_USER_ID })
          })
        }

        return {
          event,
          screen,
          sessionStart,
          uid: () => KB_ANON_USER_ID
        }
      })()

      try { window.KB_TELEMETRY.sessionStart() } catch (e) {}

    // Footer placement is pure CSS (no JS transforms).
    // This prevents zoom or resize feedback loops that can freeze the page.

</script>
<!-- KB_BUILD_VERSION: 0.1.519 -->
<!--
      - 0.1.357 (2026-01-28): Remove NTC footer pin JS and rely on CSS only to prevent zoom freezes.
      - 0.1.251 (2026-01-26): Set global wrap horizontal padding to 8px and keep NTC row height 32px.
      - 0.1.238 (2026-01-26): Screen 3 layout test. Set map slot to 512x512, move game buttons under answers, and move account panes into a right-side column.
      - 0.1.237 (2026-01-25): Call KB_TELEMETRY.screen only from show*Screen functions.
      - 0.1.236 (2026-01-24): Attach kb_anon_user_id to all kb_* GA4 events.
CHANGELOG:
- 0.2.0 (2026-01-31): Version bump only.
  



  


- 0.1.533 (2026-01-31): Add non-integer DPR tile seam masking, stronger low-fraction DPR mask, and post-resize DPR class update burst.
- 0.1.519 (2026-01-31): Move EDU KBU blocks 1 px left.
- 0.1.518 (2026-01-31): Educational Content KBU block header is no longer bold.
- 0.1.517 (2026-01-31): Remove trailing period from redeem toast message.
- 0.1.514 (2026-01-31): Remove tooltip period, unify borders to #ddd, set KBU input borders to #888, and match tooltip background to button.
- 0.1.516 (2026-01-31): Add loading and empty states for EDU and Store lists. Show unified user-facing data load error message in EDU and Store panes.
- 0.1.515 (2026-01-31): Tooltip background matches attribution background.

- 0.1.513 (2026-01-31): Make ⓘ glyph non-bold, match glyph and tooltip colors to the (75%) label, and tighten glyph spacing.

- 0.1.512 (2026-01-31): Match global balance tooltip styling to footer color, and set tooltip rounding to 4px.

- 0.1.511 (2026-01-31): Use ⓘ glyph for global-balance tooltip icon and position tooltip to the right, vertically centered.

- 0.1.510 (2026-01-31): Refine scope tooltip icon to a small circled i, update tooltip text, left align tooltip, remove shadow and bolding, and match tooltip border to mega panes.

- 0.1.509 (2026-01-31): Refine scope tooltips for Child and K-Bucks Platform balances, use superscript (i), and use a custom tooltip with 2 px rounding.

- 0.1.507 (2026-01-30): Add scope tooltips for Child and K-Bucks Platform balances, and add thousands separators to displayed KBU values in store prices.

- 0.1.505 (2026-01-31): Move EDU KBU funds blocks right by 1 px more.

- 0.1.504 (2026-01-31): Move EDU KBU funds blocks right by 1 px.

- 0.1.503 (2026-01-31): Move EDU KBU funds blocks right by 70 px. Apply the indent to the EDU funds block wrappers, since eduFundsCol uses display contents.
- 0.1.502 (2026-01-31): Apply the wallet formatter, min two and up to nine decimals, to all displayed KBU values, including Content Developer and EDU funds blocks. Format Sponsors flow rate with the same precision. Move EDU KBU blocks right by 134 px based on screenshot alignment.

- 0.1.502 (2026-01-31): Apply the wallet formatter, min two and up to nine decimals, to all displayed KBU values, including Content Developer and EDU funds blocks. Format Sponsors flow rate with the same precision. Move EDU KBU blocks right by 134 px based on screenshot alignment.

- 0.1.501 (2026-01-31): Always show at least 2 decimals and up to 9 decimals when needed for spigot flow rate, KBU per hour estimate, and balances. Move EDU funds blocks 100 px further right.

- 0.1.500 (2026-01-31): Spigot flow rate now shows at least 2 decimals. EDU funds blocks: rename Education Sponsors line to Sponsors. Shift EDU funds blocks right to align with the KBU header.

- 0.1.499 (2026-01-30): Revert ratio label and map attribution text. Shorten spigot flow rate label to Parent + Sponsors. Update redemption store available line. Remove global tag from game balance labels.

- 0.1.498 (2026-01-31): UI copy polish. Select an answer, use × in PTT, standardize Sponsors labels, simplify ratio range text, change EDU funds header to KBU, rename Available to Available to earn, and tidy map attribution.

- 0.1.497 (2026-01-31): Label only global balances as KBU balance (global). Keep other balances as KBU balance.

- 0.1.496 (2026-01-31): Add scope hints to KBU balance labels, this content for Parent, Education Sponsors, and Content Developer, global for Child and K-Bucks Platform.

- 0.1.495 (2026-01-31): Rename all account pane labels from KBU deposit and KBU account to KBU balance in both games.

- 0.1.494 (2026-01-31): Rename K-Bucks labels to KBU in both game account panes, adjust match ratio suffix spacing, and update spigot labels.

- 0.1.493 (2026-01-31): Copy polish for practice messages, overlay title, spigot K-Bucks per hour label, and Parent-to-Sponsors match ratio formatting. Replace technical load errors with a user friendly message. Fix storeThumb CSS width and height properties.

- 0.1.492 (2026-01-30): Leaflet tile seam mitigations. Apply mix-blend-mode plus-lighter to Leaflet tiles when devicePixelRatio is non-integer. Heal after wheel zoom settles by invalidating size and redrawing tiles.

- 0.1.491 (2026-01-30): Screen 2, set Plastic Spider Ring brand to Generic. Rename Gift Card to Baskin-Robbins Gift Card and set brand to Baskin-Robbins.

- 0.1.479 (2026-01-29): Screen 2, rename Classic Sheepskin Boots to UGG Classic Boots.

- 0.1.478 (2026-01-29): Screen 2, rename Eraser to STAEDTLER Eraser.

- 0.1.477 (2026-01-29): Screen 2, match redemption item text spacing and alignment to Educational Content. Rename Plastic Vinyl Eraser to Eraser.

- 0.1.476 (2026-01-29): Screen 2, add Brand line under redemption item names. Update item names and brands.
- 0.1.475 (2026-01-29): Screen 2, restore Available-to-redeem header font to match Screen 1. Limit 13px storePrice styling to redemption item prices only.
- 0.1.474 (2026-01-29): Screen 2, Redemption Store item typography matches Educational Content card fonts.
- 0.1.473 (2026-01-29): Screen 2, keep Redemption Store item list full width. Column 2 is collapsed for now.
- 0.1.472 (2026-01-29): Screen 2, Redemption Store uses a two-column grid wrapper, column 2 is empty for now.
- 0.1.397: Add favicon.ico links (cache-busted).
- 0.1.396 (2026-01-28): Spigot padding left 12px to 8px, spigot text gap 8px to 12px.
- 0.1.393 (2026-01-28): NTC attribution flush to map edge (remove Leaflet control margins and corner padding).
- 0.1.396 (2026-01-28): Round NTC attribution box corners to 4px.
- 0.1.392 (2026-01-28): NTC attribution: font size 11, background #f4f4f4, right-aligned to map edge.
- 0.1.392 (2026-01-28): NTC attribution: font size 13, transparent background, centered at bottom.
- 0.1.392 (2026-01-28): NTC attribution: font size 10, right-aligned (not centered), keep square box.
- 0.1.388 (2026-01-28): Leaflet attribution box: remove border, set font size 13, add © Leaflet.
- 0.1.387 (2026-01-28): Style Leaflet attribution to match footer (font, colors, rounded box).
- 0.1.385 (2026-01-28): Column-2 mega pane for NTC + MTN, merged Select-your-answer and bottom controls, removed inter-pane gaps.
- 0.1.384 (2026-01-28): Spigot row, moved 12 px right by padding on the spigot section wrapper.
      - 0.1.383 (2026-01-28): Move spigot image 12px to the right.
      - 0.1.383 (2026-01-28): Mega-pane padding tune: -2px bottom on five non-spigot sections, +5px bottom on spigot section.
      - 0.1.381 (2026-01-28): Reduce spigot bottom padding by ~40px and redistribute +6px bottom padding to each non-spigot section.
      - 0.1.379 (2026-01-28): Mega-pane top-five sections bottom padding +20px for visibility test.
      - 0.1.377 (2026-01-28): Mega-pane spigot flush-left. Add 2px m
      - 0.1.378 (2026-01-28): Mega-pane top-five sections bottom padding +1px.ore bottom padding to top five mega sections.
      - 0.1.376 (2026-01-28): Spigot 52px and closer left. Add 1px more bottom padding to top five mega sections.
      - 0.1.375 (2026-01-28): Add 1px more bottom padding to top five mega sections.
      - 0.1.374 (2026-01-28): Mega-pane spigot larger, add 1px bottom padding to top five mega sections.
- 0.1.373 (2026-01-28): Mega-pane spigot icon larger and text vertically centered. Harmonize Platform section spacing.
- 0.1.372 (2026-01-28): Consolidated accounts pane: hide scrollbars and size to 384x512 content with 1 px border.
- 0.1.372 (2026-01-28): Tighten consolidated accounts pane spacing to remove scrollbar.
- 0.1.370 (2026-01-28): NTC and MTN: Reduce consolidated accounts pane padding to eliminate scrollbar.
- 0.1.370 (2026-01-28): NTC and MTN: Consolidate the accounts column into a single 384x512 pane.
- 0.1.367 (2026-01-28): MTN: Remove #bingoPane padding and border so 514x514 board frame fits without clipping.
- 0.1.366 (2026-01-28): MTN: Fix board edge clipping by removing global bingoPairBtn padding inside the MTN grid.
- 0.1.366 (2026-01-28): MTN: Remove unintended inner offset by anchoring the 512x512 grid to the frame content box.
- 0.1.362 (2026-01-28): Center MTN 512x512 board inside a 514x514 stage so footer position matches other screens.
- 0.1.363 (2026-01-28): MTN: Add a 1px border frame around the 512x512 board so the board area totals 514x514 like NTC.
- 0.1.361 (2026-01-28): Make MTN layout width and height match NTC so the copyright footer does not shift between screens.
- 0.1.360 (2026-01-28): Fix NTC and MTN footer alignment by removing forced footer width and setting per-screen widths.
- 0.1.359 (2026-01-28): Stabilize footer position across screens by removing per-screen width overrides.
- 0.1.358 (2026-01-28): Set copyright top-gap to 8px.
- 0.1.355 (2026-01-28): Set .scoreInline and .acctLine to 13px. Set copyright text to 13px and 6px top-gap.
- 0.1.353 (2026-01-27): Rename multiplication game to "Multiply Two Numbers".
- 0.1.352 (2026-01-27): Rename "Multiply Two Numbers" everywhere (was "Practice Times Tables").
- 0.1.351 (2026-01-27): Educational Content screen order: Name That Country first, Multiply Two Numbers second.
- 0.1.350 (2026-01-27): Align answer bullets so the dot is vertically aligned under the 'S' in 'Select your answer' in both NTC and PTT.
- 0.1.350 (2026-01-27): Unify NTC and PTT "Select your answer" panes styling and layout to match pre-PTT NTC pane.
- 0.1.348 (2026-01-27): PTT header buttons to 15px, ensure AxB label spacing and 13px label font apply (override fixes).
- 0.1.346 (2026-01-27): PTT AxB label: reintroduce spaces as "A × B" and set AxB label font size to 13px.
- 0.1.345 (2026-01-27): PTT grid: set cell size to 44×44 px, keep 2px gaps, add 4px padding each side inside 512×512.
- 0.1.342 (2026-01-27): PTT grid: make all 11×11 board cells exactly 46×46 px by switching to fixed 46px tracks and resizing the board to fit.
- 0.1.341 (2026-01-27): PTT: enforce 14 px on AxB cells and remove spacing around x so it renders as AxB.
- 0.1.340 (2026-01-27): PTT: increase AxB pair button font size to 14px and render labels as "AxB" (no spaces).
- 0.1.339 (2026-01-27): PTT Misses mode: mark answered cells with red or green results like normal mode, and clear the board when the misses loop restarts.
- 0.1.338 (2026-01-27): PTT: highlight the current A x B pair button in orange while the question is being shown.
- 0.1.337 (2026-01-27): Fix PTT blank-start. Hide A x B labels when blank or showing results, prevent text concatenation, and keep current-pair cell unhighlighted.
- 0.1.336 (2026-01-27): PTT reveals. Pair buttons start blank, show "A × B" only for the current question, then replace with the correct result number and keep red or green marking.
- 0.1.334 (2026-01-27): PTT polish. Pair buttons are 12px with visible "A × B" spacing. Current pair highlight is list-gray. Keep header highlights until Next question, then reset headers for the new pair.
- 0.1.332 (2026-01-27): PTT polish. Fix AxB rendering to remove added spacing, set pair font to 14px, restore NTC-matching answer bullet alignment and spacing, and enforce non-interactive board cursor.
- 0.1.330 (2026-01-27): Multiply Two Numbers board polish. Make header cells match pair cell sizing, add top-left X, disable board clicks, restore compact A × B rendering, and highlight row and column headers for the current pair.
- 0.1.331 (2026-01-27): PTT UI polish. Tighten AxB labels to "AxB" style, change corner to lowercase "x", and align answer bullets and row sizing to match NTC.
- 0.1.328 (2026-01-27): Fix PTT answer rendering by restoring bingoPairBtn buttons, and harden NTC answer click handling to prevent runtime crashes.
- 0.1.327 (2026-01-27): Polish Multiply Two Numbers UI to match Name That Country, fix versioning, tighten board cell sizing, and align list and footer styling.
- 0.1.326 (2026-01-27): Multiply Two Numbers screen UI now matches Name That Country layout, with a 512x512 multiplication-board slot and aligned panes.
- 0.1.325 (2026-01-27): Align Educational Content and Redemption Store message-slot behavior, so card start position matches when the message line is empty.
- 0.1.324 (2026-01-27): Educational Content now reserves a one-line message slot under the Available line, matching Redemption Store, so the list starts at the same vertical position.
- 0.1.323 (2026-01-27): Redemption Store list now always starts 10px below the Redeemed line, even when no redeemed message is shown, by reserving a one-line message slot.
- 0.1.322 (2026-01-27): Fix main-pane header spacing so the list starts exactly 10px below the last header line (including Redeemed message) by removing the extra header-block bottom margin.
- 0.1.321 (2026-01-27): Main panes: list now starts 10px below the last header line (Available or Redeemed message) and store list keeps its scrollbar without card size shifting.
- 0.1.320 (2026-01-27): Leaflet minZoom now adapts to the map slot size so you can zoom out to see the full world map, which helps with countries like New Zealand and Fiji.
- 0.1.319 (2026-01-27): Name That Country practice-mode: show Misses in the Progress slot so it lines up with Progress.
- 0.1.318 (2026-01-27): Name That Country practice mode header: align "Misses" to start where "Progress" starts.
- 0.1.317 (2026-01-27): Name That Country header: rename "Practice misses" label to "Misses".
- 0.1.316 (2026-01-27): Remove trailing footer dot. Make edu and store cards match by setting card padding top and bottom to 8 px.
- 0.1.314 (2026-01-27): Set all content and store thumbs to 144 px. Restore the canonical demo footer text on all screens.
- 0.1.312 (2026-01-27): Unify Screen 1 and Screen 2 list spacing. Match Screen 2 for top offset below the 'Available' line and for card-to-card spacing.
- 0.1.313 (2026-01-27): Reduce Screen 1 and Screen 2 card list gap from 8 px to 4 px.
- 0.1.311 (2026-01-27): Screen 1: match Screen 2 header and list spacing so first content card aligns consistently below the 'Available' line.
- 0.1.308 (2026-01-27): Screen 2: align first redemption item border with Screen 1 by removing the extra header bottom margin.
      - 0.1.309 (2026-01-27): Screen 2: match Screen 1 header spacing by removing default paragraph margins on the redeem balance line.
- 0.1.307 (2026-01-27): Screen 2: restore internal store list scrollbar, align list top to 10px below header and keep 10px gap above the bottom button. Footer: remove the extra best-viewed text.
- 0.1.306 (2026-01-27): Screen 2: Mirror Screen 1 list spacing so the store list starts 10px below the redeem balance line and ends 10px above the bottom button, while keeping scrolling enabled.
- 0.1.305 (2026-01-27): Screen 1: Ensure the first content card border starts 10px below the earn line by hiding the empty #eduPaneMessage spacer and tightening Screen 1 spacing, while keeping scrolling enabled.
- 0.1.302 (2026-01-26): Resize Screen 2 Redemption Store white pane (#redeemPane) to 1166x514 with 10px 10px padding to match Screen 1 and NTC footprint.
- 0.1.301 (2026-01-26): Make the Misses-style button formatting apply to all buttons automatically via CSS (button:not(.ansBtn)), so dynamically generated Play and Redeem buttons get the same size.
- 0.1.300 (2026-01-26): Standardize non-answer buttons across all screens using a global .kbBtn style based on the NTC Misses button. Keep NTC answer rows (.ansBtn) unchanged.
- 0.1.299 (2026-01-26): Screen 1: set Educational Content pane padding to 10px 10px to match NTC pane padding.
- 0.1.298 (2026-01-26): Resize Screen 1 Educational Content white pane to 1166x514 to match NTC (map-to-parent width and map height).
- 0.1.297 (2026-01-26): Pin the NTC footer under the map using DOM-measured positioning (transform) to remove the persistent bottom gap.
- 0.1.296 (2026-01-26): Fix the large blank gap above the footer in NTC by locking the grid row height to --ntcMapSize with a final CSS override.
- 0.1.295 (2026-01-26): In NTC, tie the layout height (--kb-main-h) to the map pane size (--ntcMapSize) so the footer sits close to the map instead of leaving a tall blank area.
- 0.1.294 (2026-01-26): Restore the original Progress-to-map spacing behavior and set the footer-to-map spacing to 10px to match the 0.1.284 look.
- 0.1.293 (2026-01-26): Fix footer spacing not applying by adding a final #screenGame .copyrightLine override that sets margin-top (matches header spacing) and prevents later .copyrightLine rules from overriding it.
- 0.1.292 (2026-01-26): Make footer gap match the current header spacing by setting .copyrightLine margin-top to calc(20px + --ntcHeaderExtraPad). Disable the JS footer-gap experiment.
- 0.1.290 (2026-01-26): Fix JS syntax in footer gap sync (remove stray brace) and keep sync applied to the visible footer.
- 0.1.289 (2026-01-26): Fix footer gap sync by applying the measured gap to the visible footer element (there are multiple footer nodes in the DOM).
- 0.1.288 (2026-01-26): Make footer-to-map spacing match Progress-to-map spacing by measuring the actual gap and applying it to the footer on load and resize.
- 0.1.287 (2026-01-26): Increase footer-to-map spacing to visually match the Progress-to-map gap by adding --ntcFooterMatchPad (14px).
- 0.1.286 (2026-01-26): Match footer-to-map spacing to header-to-map spacing by replacing fixed header height with padding and tying footer margin to the same value.
- 0.1.285 (2026-01-26): Increase footer spacing by setting .copyrightLine margin-top to 10px.
- 0.1.284 (2026-01-26): Simplify footer by removing the legacy best-viewed note. Center footer within NTC layout width.
- 0.1.283 (2026-01-26): Set quiz header margin-bottom to 6px and answers padding-bottom to 6px.
- 0.1.282 (2026-01-26): Restore NTC answer line-height to 1.3 (button and label) to prevent descender clipping.
- 0.1.281 (2026-01-26): Set quiz header margin-bottom to 8px and answers padding-bottom to 8px.
- 0.1.280 (2026-01-26): Reduce NTC answer line-height to 1.25 (button and label) for tighter vertical spacing.
- 0.1.279 (2026-01-26): Adjust NTC quiz spacing by reducing header margin and adding bottom padding to the answers list.
- 0.1.278 (2026-01-26): Use min-height 34px and padding 0px 10px for NTC answer rows for stable height without extra vertical padding.
- 0.1.277 (2026-01-26): Adjust NTC answer row padding to 10px 10px.
- 0.1.276 (2026-01-26): Adjust NTC answer row padding to 0px 10px for tightest vertical spacing.
- 0.1.275 (2026-01-26): Adjust NTC answer row padding to 4px 10px for tighter vertical spacing.
- 0.1.274 (2026-01-26): Set NTC answer line-height to 1.3 (button and label) to prevent descender clipping.
- 0.1.273 (2026-01-26): Set NTC answer option rows (#screenGame .ansBtn) min-height to 34px to prevent descender clipping.
- 0.1.272 (2026-01-26): Bump version to match the file-name version suffix guardrail.
- 0.1.271 (2026-01-26): Make Education Sponsors pane absorb zoom rounding by flex-growing, remove visible breathing gap.
- 0.1.270 (2026-01-26): Remove visible 1fr spacer gap in NTC column 3, instead anchor top and bottom using flex and let spacing below spigot absorb rounding.
- 0.1.269 (2026-01-26): Lock NTC column 3 top and bottom to map using grid with a 1fr spacer row, fix footer version.
- 0.1.268 (2026-01-26): In NTC, set the game grid row to 1fr and lock the grid height to the map size so column 3 stays top and bottom aligned when browser zoom changes.
- 0.1.260 (2026-01-26): In NTC, set column 2 and 3 pane padding to 10px on all sides for a layout comparison.
- 0.1.259 (2026-01-26): In NTC, set column 2 and 3 pane padding to 12px on all sides for a layout comparison.
- 0.1.257 (2026-01-27): Fix NTC column overlap by locking left side column width to 258px and preventing overflow.
- 0.1.253 (2026-01-27): Lock NTC grid, restore bullet sizing and dot alignment, set global padding to 8px.
      - 0.1.235 (2026-01-24): Fix missing kbHealTiles wrapper and sync redemption store manifest expected hash.
      - 0.1.234 (2026-01-23): Add GA4 telemetry hooks (games, questions, rewards, redemptions) and persistent anonymous user ID.
      - 0.1.233 (2026-01-22): Update footer text across screens to 2025-2026 range, include viewing recommendation, and bump version.
      - 0.1.231 (2026-01-17): Reduce Leaflet tile seam artifacts and make footer version updates consistent across screens.
      - 0.1.226 (2026-01-17): Rename browser tab title to 'K-Bucks Demo'.
      - 0.1.225 (2025-12-27): Screen 2 wording, 'Available to Redeem' -> 'Available to redeem'.
      - 0.1.224 (2025-12-27): Restore Leaflet zoomSnap 0.2, zoomDelta 0.2, minZoom 2.2, and setView zoom 2.2. Fix footer version placeholders.
      - 0.1.223 (2025-12-27): Screen 1 wording, 'Child can earn' -> 'Available for the Child to earn'.
      - 0.1.222 (2025-12-27): Add K-Bucks/Hour (estimate) to Multiply Two Numbers spigot, keep version fields consistent.
      - 0.1.221 (2025-12-27): Restore Leaflet zoomSnap 0.2, zoomDelta 0.2, minZoom 2.2.
    -->
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>K-Bucks Demo</title>
<link crossorigin="" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" rel="stylesheet"/>
<style>


























    *, *::before, *::after { box-sizing: border-box; }

    * { box-sizing: border-box; }

    /* Hide number input spinners (Chrome, Safari, Edge) */
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button{
      -webkit-appearance: none;
      margin: 0;
    }
    /* Hide number input spinners (Firefox) */
    input[type=number]{
      -moz-appearance: textfield;
      appearance: textfield;
    }

    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;   --ntcHeaderExtraPad: 8px;
}



/* 0.1.321: Main-pane header/list spacing consistency.
   The first gray card starts 10px below the last header line (Available, or Redeemed message). */
.kbMainHeaderBlock { margin-bottom: 0; display: flex; flex-direction: column; }
#redeemBalance, #earnBalance { margin: 0; }

#redeemPaneMessage, #eduPaneMessage{
  margin-top: 8px;
  margin-bottom: 0;
}

#eduPaneMessage:empty{
  display: none;
  margin-top: 0;
  min-height: 0;
}

/* Force a stable flex layout for both main panes, regardless of earlier experimental CSS blocks. */
#screenStore #redeemPane, #screenEdu #eduPane{
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#screenStore #store, #screenEdu #eduList{
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  margin: 0;
}

#screenStore #store .storeList, #screenEdu #eduList .storeList{
  margin-top: 0;
  margin-bottom: 0;
  gap: 4px;
}

#screenStore #redeemPane .controls.mainSlotNav, #screenEdu #eduPane .controls.mainSlotNav{
  margin-top: 10px;
  margin-bottom: 0;
  justify-content: flex-end;
}


    :root{
      --kb-header-h: 27px;
      --kb-footer-h: 23px;
      --kb-main-w: 2142px;
      --kb-main-h: 1184px;
      --kb-side-w: 360px;
      --kb-gap: 18px;
    }
    .screen{
      width: calc(var(--kb-main-w) + var(--kb-side-w) + var(--kb-gap));
      margin: 0;
    }

    .headerBar{
      display: flex;
      align-items: flex-start;
      padding: 0;
      margin: 0 0 10px;
      height: var(--kb-header-h);}

    .headerLine{
      display: flex;
      align-items: baseline;
      gap: 14px;
      width: 100%;
      font-size: 14px;
      white-space: nowrap;
      overflow: visible;
    }

    .screenTitle{
      font-size: 24px;
      line-height: 24px;
      font-weight: 700;
      margin-right: 0;

    }

    .storeMain{
      width: var(--kb-main-w);
      height: var(--kb-main-h);
    }

    .footerBar{
      height: var(--kb-footer-h);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 6px;
      font-size: 12px;
      color: #444;
    }
body { margin: 0; background: #f6f6f6; color: #111; overflow: hidden; }
    .wrap {  padding: 8px 8px;  }
    .title { font-size: 20px; margin: 0; }

    
    .topHeader{
      display: flex;
      align-items: baseline;
      justify-content: flex-start;
      gap: 10px;
      margin: 0 0 10px;
      flex-wrap: wrap;
    }
    .topStatus{
      display: flex;
      align-items: baseline;
      gap: 10px;
      flex-wrap: wrap;
    }
    

    

    .topStatus .scoreInline{
      width: auto;
      flex: 0 0 auto;
      margin-right: 0;
      text-align: left;
    
      font-size: 13px;}

    
    .kbFlexBreak{
      flex: 0 0 100%;
      height: 0;
      margin: 0;
      padding: 0;
      border: 0;
      line-height: 0;
      overflow: hidden;
    }
.scoreInline{
      width: auto;
      flex: 0 0 auto;
      margin-right: 0;
      text-align: left;
    }

    .scoreInline {
      font-size: 12px;
  color: #444;
      white-space: nowrap;
      width: 20ch;
      text-align: right;
      margin-right: 10px;
      flex: 0 0 20ch;
    }
.copyrightLine{
      width: 100%;
      text-align: center;
      margin-top: 8px;
      padding-bottom: 0px;
      color: #444;
    
      font-size: 13px;
      transform: none;
      will-change: auto;
    }

    #screenGame .copyrightLine{ width: 100%; text-align: center; margin-top: 8px; }

.layout {
      display: grid;
      grid-template-columns: var(--kb-main-w) var(--kb-side-w);
      gap: var(--kb-gap);
      align-items: stretch;
      height: var(--kb-main-h);
      width: calc(var(--kb-main-w) + var(--kb-side-w) + var(--kb-gap));
    }
#bingoSlot { width: var(--kb-main-w); height: var(--kb-main-h); }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    #mapSlot {
      position: relative;
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #e9eef5;
      width: var(--pttBoardSize);
      height: var(--pttBoardSize);
      min-height: 0;
      overflow: hidden;
    }
    
    /* Leaflet attribution styling to match K-Bucks footer */
    #screenGame .leaflet-container { font-family: var(--kbFontStack); }

        #screenGame .leaflet-control-attribution {
      font-family: var(--kbFontStack);
      font-size: 11px;
      color: #444;
      background: #f4f4f4;
      border-radius: 4px;
      padding: 2px 6px;
      box-shadow: none;
    }

    /* Right-align attribution to the bottom-right edge of the 512x512 map */
    #screenGame .leaflet-bottom.leaflet-right {
      left: auto;
      right: 0;
      text-align: right;
      padding-right: 0;
      padding-left: 0;
      padding-bottom: 0;
    }
    #screenGame .leaflet-right .leaflet-control { margin-right: 0 !important; }
    #screenGame .leaflet-bottom .leaflet-control { margin-bottom: 0; }
    #screenGame .leaflet-control-attribution { float: none; display: inline-block; }
    #screenGame .leaflet-control-attribution a { color: #444; }
/* Screen 3 layout experiment: 512x512 map slot and two right columns */
    #screenGame { --ntcMapSize: 514px; --kb-main-h: var(--ntcMapSize); width: calc(var(--ntcMapSize) + 258px + 386px + (2 * 4px)); }

    #screenGame .layout.gameLayout.kbNtcLayout {
      grid-template-columns: var(--ntcMapSize) 258px 386px;
      width: calc(var(--ntcMapSize) + 258px + 386px + (2 * 4px));
      align-items: stretch;
      column-gap: 4px;
      row-gap: 4px;
    
      height: var(--ntcMapSize);
      grid-template-rows: 1fr;
      justify-items: stretch;
}

    #screenGame #mapSlot {
      width: var(--ntcMapSize);
      height: var(--ntcMapSize);
    }

    #screenGame #ntcAccounts { justify-content: flex-start; height: 100%; display: flex; flex-direction: column; gap: 4px;
      min-height: 0;
}

    /* NTC: increase bottom padding so the Next question button sits lower */
    #screenGame #quizPane { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; padding-bottom: 11px; }
#screenGame #quizPane .answers { flex: 1 1 auto; min-height: 0;
      padding-bottom: 6px;}
#screenGame #quizPane .controls { margin-top: auto; }

    /* PTT: match the NTC "Select your answer" pane layout behavior */
    #screenBingo #bingoQuizPane { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; padding-bottom: 11px; }
    #screenBingo #bingoQuizPane .answers { flex: 1 1 auto; min-height: 0; padding-bottom: 6px; }
    #screenBingo #bingoQuizPane .controls { margin-top: auto; }


    #screenGame .kbNtcSideLeft,
    #screenGame .kbNtcSideRight {
      height: var(--kb-main-h);
      overflow: auto;
    }

    /* NTC column widths, prevent overflow overlap */
    #screenGame #side.kbNtcSideLeft {width: 258px;
      overflow: hidden;
      gap: 0px;
  height: var(--ntcMapSize);

      min-height: 0;
}

    #screenGame #ntcAccounts.kbNtcSideRight {width: 386px;
      height: var(--ntcMapSize);
      display: flex;
      flex-direction: column;
      gap: 4px;
      overflow: hidden;
      min-height: 0;
    }

    #screenGame #ntcAccounts.kbNtcSideRight .pane {
      width: 100%;
      box-sizing: border-box;
    }

    /* NTC + PTT answer rows */
    #screenGame .ansBtn,
    #screenBingo .ansBtn {
      font-size: 16px;
      min-height: 34px;
      line-height: 1.3;
      padding: 0px 10px;
    }

    /* MTN only: slightly taller answer rows to match NTC spacing above Next question */
    #screenBingo .ansBtn { min-height: 36px; }




    /* Fix A: reduce Leaflet tile seam artifacts */
    #mapSlot img.leaflet-tile {
      outline: 1px solid transparent;
    }

    /* Leaflet seam workaround on non-integer device pixel ratios in Chrome and WebKit */
    html.kb-nonIntegerDpr #mapSlot img.leaflet-tile {
      outline: 2px solid transparent;
      mix-blend-mode: plus-lighter;
      will-change: transform;
      backface-visibility: hidden;
    }

    /* Stronger seam mask for low fractional DPR (e.g. 110%, 125%) */
    html.kb-lowFracDpr #mapSlot img.leaflet-tile {
      outline: 4px solid transparent;
    }

/* Double-buffered Leaflet map containers */
    .kbMapBuffer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      min-height: 0;
    }

    .kbMapFront {
      opacity: 1;
      pointer-events: auto;
      z-index: 2;
    }

    .kbMapBack {
      opacity: 0;
      pointer-events: none;
      z-index: 1;
    }

    #redeemPane {
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #fff;
      width: 100%;
      height: 100%;
      min-height: 0;
      padding: 14px;
      overflow: auto;
      display: block;
    }
    
    #bingoPane {
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: var(--kb-ocean-gray);
      width: 100%;
      height: 100%;
      min-height: 0;
      padding: 14px;
      overflow: hidden;
      display: block;
    }

    /* MTN: remove outer padding and border so the 514x514 board frame fits without clipping */
    #screenBingo #bingoPane{
      padding: 0;
      border: 0;
      background: transparent;
      border-radius: 0;
    }

#redeemPane .redeemHeader {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    #redeemPane h2 {
      margin: 0;
      font-size: 18px;
    }
    #redeemBalance {
      margin-top: 8px;
      color: #333;
      font-size: 16px;
      white-space: pre-wrap;
    }
    #redeemPaneMessage {
      margin-top: 8px;
      min-height: 18px;
      color: #333;
      font-size: 12px;
      white-space: pre-wrap;
    }

    

    /* Educational Content pane should match Redemption Store styling */
    /* Main-slot bottom nav, no extra scrollbars, D = 14px */
    #redeemPane, #eduPane{
      box-sizing: border-box;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #store, #eduList{
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
    }
    #redeemPane .storeList, #eduPane .storeList{
      margin-bottom: 0;
    }
    .controls.mainSlotNav{
      justify-content: flex-end;
      margin-top: 14px; /* D */
      margin-bottom: 0;
    }



    /* Reserve space so last card never sits under the nav button */
    /* Bottom-right navigation button inside main panes (D = 14px) */
    #eduPane {
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #fff;
      width: 100%;
      height: 100%;
      min-height: 0;
      padding: 14px;
      overflow: auto;
      display: block;
    }
    #eduPane .redeemHeader {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    #eduPane h2 {
      margin: 0;
      font-size: 18px;
    }
    #earnBalance {
      margin-top: 8px;
      color: #333;
      font-size: 16px;
      white-space: pre-wrap;
    }
    #eduPaneMessage {
      min-height: 20px;
      line-height: 20px;
      margin: 0 0 10px 0;
      color: #333;
      font-size: 12px;
      white-space: pre-wrap;
    }

    #eduPaneMessage:empty{
      display: block;
      visibility: hidden;
    }
#side {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: var(--kb-side-w);
      height: var(--kb-main-h);
      overflow: auto;
    }

    #bingoSide {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: var(--kb-side-w);
      height: var(--kb-main-h);
      overflow: auto;
    }

    /* Bingo quiz pane: do not reserve empty space below the button */
    #bingoQuizPane #bingoMessage { margin-top: 8px; min-height: 0; }
    #bingoQuizPane #bingoMessage:empty { display: none; }

    /* Bingo pair highlighting */
/* Answered pairs, green for correct, red for incorrect. Matches Select your answer colors. */
.bingoPairBtn.kbBingoDoneCorrect,
.bingoPairBtn.kbBingoDoneCorrect:hover,
.bingoPairBtn.kbBingoDoneCorrect:active,
.bingoPairBtn.kbBingoDoneCorrect:focus {
  background: #c8f3c8;
  border-color: #7bd47b;
  color: #333333;
}

.bingoPairBtn.kbBingoDoneWrong,
.bingoPairBtn.kbBingoDoneWrong:hover,
.bingoPairBtn.kbBingoDoneWrong:active,
.bingoPairBtn.kbBingoDoneWrong:focus {
  background: #f6c1c1;
  border-color: #e18a8a;
  color: #333333;
}

/* Current question pair: highlighted in orange while the question is being shown */
.bingoPairBtn.kbBingoCurrent,
.bingoPairBtn.kbBingoCurrent:hover,
.bingoPairBtn.kbBingoCurrent:active,
.bingoPairBtn.kbBingoCurrent:focus {
  background: orange;
  border-color: rgba(199, 111, 0, 0.75);
  outline: none;
}
.pane {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 14px;
    }

    .paneHeader {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }

    .pane h3 {
      margin: 0;
      font-size: 16px;
    }
    .pct { font-weight: 400; }

.kbInfoIcon{
  display: inline-block;
  margin-left: 2px;
  font-size: 12px;
  line-height: 1;
  color: inherit;
  font-weight: 400;
  cursor: help;
  user-select: none;
  vertical-align: super;
  position: relative;
  top: -0.15em;
  padding: 0 1px;
}
.kbInfoIcon:focus{
  outline: 2px solid #9ec1ff;
  outline-offset: 1px;
}
.kbInfoIcon::after{
  content: attr(data-tooltip);
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  background: #f4f4f4;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 6px 8px;
  white-space: nowrap;
  font-size: 12px;
  color: inherit;
  font-weight: 400;
  text-align: left;
  opacity: 0;
  pointer-events: none;
  z-index: 9999;
  box-shadow: none;
  text-shadow: none;
}
.kbInfoIcon:hover::after,
.kbInfoIcon:focus::after{
  opacity: 1;
}

.arrowDivider{
      display:flex;
      justify-content:flex-start;
      padding:0;
      margin:0;
      width: 100%;
    }

    .spigotPane{
  width: 100%;
  display:flex;
      box-sizing: border-box;
    
    
  padding: 8px 8px 0px 8px;
}
.spigotInner{
  width: 100%;
  height: 100%;
  display:flex;
  flex-wrap: nowrap;
  gap: 12px;
  align-items: center;
}
.spigotImg{
  flex: 0 0 auto;
  height: 52px;
  max-height: 52px;
  max-width: 52%;
  width: auto;
  display:block;
  object-fit: contain;
  object-position: left center;
  align-self: center;
}
.spigotText{
  flex: 1;
  min-width: 0;
  display:flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  text-align: left;
}
.copyrightLine{
      width: 100%;
      text-align: center;
      margin-top: 8px;
      padding-bottom: 0px;
      color: #444;
    }
.answers { list-style: none; padding: 0; margin: 0; }
    .answers li { margin: 1px 0; }

    .ansBtn {
      width: 100%;
      text-align: left;
      border: 1px solid transparent;
      background: transparent;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font: inherit;
      font-size: 15px;
          line-height: 1.2;
}
    .ansBtn:hover { background: #f3f3f3; }
    /* Ensure correctness highlighting overrides hover/press states immediately */
    .ansBtn.correct,
    .ansBtn.correct:hover,
    .ansBtn.correct:active,
    .ansBtn.correct:focus { background: #c8f3c8; border-color: #7bd47b; }

    .ansBtn.wrong,
    .ansBtn.wrong:hover,
    .ansBtn.wrong:active,
    .ansBtn.wrong:focus { background: #f6c1c1; border-color: #e18a8a; }

    /* Keep disabled answer buttons readable, but do not gray out correct or wrong */
    .ansBtn:disabled {
      color: #666;
      -webkit-text-fill-color: #666;
      opacity: 1;
      cursor: default;
    }
    .ansBtn.correct:disabled,
    .ansBtn.wrong:disabled {
      color: #111;
      -webkit-text-fill-color: #111;
      opacity: 1;
    }
    .ansBtn:disabled .label,
    .ansBtn:disabled .mark { color: inherit; -webkit-text-fill-color: inherit; }

    .bullet { width: 16px; text-align: center; color: #111; }
    .label { flex: 1; }
    .mark { width: 18px; text-align: center; font-weight: 700; }

    .correct { background: #c8f3c8; border-color: #7bd47b; }
    .wrong { background: #f6c1c1; border-color: #e18a8a; }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: flex-start;
      margin-top: 12px;
    }

    .controls button,
    .bottomBar button,
    .modal .controls button,
    .storeItem button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #888;
      background: #f4f4f4;
      cursor: pointer;
      white-space: nowrap;
    }

    .storeItem button:disabled { opacity: 0.45; cursor: not-allowed; }

    .controls button:disabled { opacity: 0.55; cursor: not-allowed; }

    .status {
      margin-top: 10px;
      min-height: 18px;
      color: #333;
      font-size: 12px;
      white-space: pre-wrap;
    }

    
    /* Quiz pane: do not reserve empty space below the button */
    #quizPane #message { margin-top: 8px; min-height: 0; }
    #quizPane #message:empty { display: none; }


    /* PTT quiz pane: match NTC behavior for empty message */
    #bingoQuizPane #bingoMessage { margin-top: 8px; min-height: 0; }
    #bingoQuizPane #bingoMessage:empty { display: none; }
.acctLine{
      margin-top: 8px;
      line-height: 1.35;
      font-size: 13px;
      color: #333;
      white-space: nowrap;
    }

    .kbHourLine{ color: #555; }

    .flowInput {
      width: 12ch;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #888;
      font: inherit;
      font-size: 12px;
      margin-left: 6px;
    }

    
    #sponsorMatchInput, #bingoSponsorMatchInput{ text-align: center; width: 2.2em; height: 2.2em; padding: 0; }
.moneyInput {
      width: 12.5ch;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #888;
      font: inherit;
      font-size: 12px;
      margin-left: 6px;
    }
    /* Empty-wallet highlight disabled for now
    .moneyInput.emptyWallet {
      background: #fffbe6;
    }
    */
    .bottomBar {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      align-items: center;
      padding: 10px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .overlay.show { display: flex; }

    .modal {
      background: #fff;
      border-radius: 10px;
      padding: 18px;
      max-width: 640px;
      width: 100%;
      border: 1px solid #ddd;
    }
    .modal h2 { margin: 0 0 8px; font-size: 18px; }
    .modal p { margin: 0 0 14px; color: #333; }

    .storeList { display: grid; gap: 4px; margin: 12px 0; }

    .kbListState{
      padding: 12px 4px;
      color: #666;
      font-size: 13px;
      text-align: center;
    }
    .storeItem {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: #fafafa;
    }
    .storeItem strong { font-weight: 600; }
  
  
    

.storeLeft{
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;
}



/* Screen 1 (Educational Content): fixed column container to the right of the thumb */
:root{
  --eduColTitle: 234px;
  --eduColKB: 220px;
  --eduColGap: 20px;
  --eduFundsIndent: 71px;
}
.eduLeft{
  display: flex;
  flex: 1;
  align-items: flex-start;
  gap: 10px;
  min-width: 0;
}
.eduMid{
  display: grid;
  grid-template-columns: var(--eduColTitle) var(--eduColKB);
  column-gap: var(--eduColGap);
  align-items: start;
  min-width: 0;
}
.eduFundsCol{
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: flex-start;
  min-width: 0;
  padding-left: var(--eduFundsIndent);
}
.eduFundsTitle{
  font-weight: 600;
  font-size: inherit;
  line-height: 1.2;
  margin-top: 0;
}

.storeThumb{
  width: 128px;
  height: 128px;
  border-radius: 10px;
  object-fit: contain;
  flex: 0 0 auto;
  border: 1px solid #ddd;
  background: #fff;
}
.storeMeta{ min-width: 0; }
.storePrice{ font-size: 16px; }

.eduFundsLine{ font-size: 12px; line-height: 1.25; color: #333; white-space: nowrap; }
.eduFundsSpacer{ height: 10px; }
.ansBtn { box-sizing: border-box; min-height: 38px; }
    .ansBtn .bullet { flex: 0 0 14px; width: 14px; }
    .ansBtn .mark { flex: 0 0 18px; width: 18px; text-align: right; }
    .ansBtn .label { flex: 1 1 auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

  
    .matchSuffix{
      margin-left: 6px;
      font-size: 12px;
      opacity: 0.9;
      white-space: nowrap;
    }

  
  
  
  
  
  



.spigotText .acctLine{ white-space: normal; overflow-wrap: anywhere; }


    
    /* Screen 1: match NTC overall footprint (map-to-parent width x map height) */
    #screenEdu{
      width: 1166px;
    }
    #screenEdu .storeMain{
      width: 1166px;
      height: 514px;
    }
    #screenEdu #eduPane{
      width: 1166px;
      height: 514px;
      padding: 10px 10px;}

/* Screen 1: pin Redemption Store button to bottom-right of the Main Slot */
    #eduPane{
      box-sizing: border-box;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #eduList{
      flex: 1 1 auto;
      min-height: 0;
    }
    #eduPane .controls.mainSlotNav{
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
      margin-bottom: 0;
    }


    /* Screen 1: make the scroll container fill between the earn line and the button (10px gaps) */
    #eduPane .redeemHeader{
      margin-bottom: 0;
    }
    #eduPane h2{
      margin: 0 0 6px 0;
    }
    #eduPane .storePrice{
      margin: 0;
    }
    #eduList{
      margin-top: 10px;
      margin-bottom: 10px;
      overflow-y: auto;
    }
    #eduPane .controls.mainSlotNav{
      margin-top: 0;
    }

    
    /* Screen 2: match NTC overall footprint (map-to-parent width x map height) */
    #screenStore{
      width: 1166px;
    }
    #screenStore .storeMain{
      width: 1166px;
      height: 514px;
    }
    #screenStore #redeemPane{
      width: 1166px;
      height: 514px;
      padding: 10px 10px;
    }

/* Screen 2: redemption items list is non-scrollable (may truncate) */
    #screenStore #redeemPane {
      overflow: hidden;
    }
    #screenStore #store {
      overflow: visible;
    }


    

    
    
      /* padding-bottom is set dynamically in JS to (button height + D) */
    }
    #screenStore #redeemPane .controls.mainSlotNav{
      position: absolute;
      right: 0;            /* 0 from padding edge = D(14px) from border */
      bottom: 0;           /* 0 from padding edge = D(14px) from border */
      margin: 0;
      justify-content: flex-end;
    }


    
    /* Full list up: default .storeList margin-top is 12px, set to 0 */
    #screenStore #store .storeList{
      margin-top: 0;
      margin-bottom: 14px; /* Last item -> button */
    }
    /* Keep button in the normal flow, no extra gap above it */
    #screenStore #redeemPane .controls.mainSlotNav{
      position: static;
      margin-top: 0;
      margin-bottom: 0;
      justify-content: flex-end;
    }


    /* Screen 2: anchor Educational Content button like Screen 1 (flex bottom), list non-scrollable */
    #screenStore #redeemPane{
      box-sizing: border-box;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* list may truncate, no scrollbar */
    }
    #screenStore #store{
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden; /* non-scrollable, may truncate */
    }
    #screenStore #store .storeList{
      margin-top: 0; /* neutralized negative shift */
      margin-bottom: 0;
    }
    #screenStore #redeemPane .controls.mainSlotNav{
      margin-top: 14px;  /* D: list -> button */
      margin-bottom: 0;
      justify-content: flex-end;
    }



/* Screen 2: fit full redemption list without truncation, do not move header */
#screenStore #redeemPane{
  /* Keep header area unchanged */
  overflow: hidden; /* no scrollbar, everything must fit */
}
#screenStore #store{
  overflow: hidden; /* non-scrollable */
}
#screenStore #store .storeList{
  margin-top: 0;      /* was negative in prior experiments, causes top clipping */
  margin-bottom: 0;
  gap: 6px;           /* tighter vertical spacing */
}
#screenStore #store .storeItem{
  padding-top: 8px;   /* tighter item height */
  padding-bottom: 8px;
}
#screenStore #store .storeThumb{
  width: 128px;
  height: 128px;
}



    /* Thumbnails: make images fit the thumb box cleanly */
    .storeThumb {
      overflow: hidden;
    }
    .storeThumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: center;
      display: block;
    }
    /* multiplication_table.png is designed to fill the thumb, so use cover */
    .storeThumb img[src*="multiplication_table.png"] {
      object-fit: cover;
    }

    :root{
      --kb-ocean-gray: #D4DADC; /* matches map background (ocean) */
      --kb-ocean-dark: #6A6D6E; /* 2x darker than ocean gray */
      --kb-map-white: #FAFAF8;  /* matches unselected countries */
    }

        /* Screen 4: Multiply Two Numbers layout mirrors Name That Country */
    #screenBingo { --pttStageSize: 514px; --pttBoardSize: 512px; --pttCellSize: 44px; --pttGap: 2px; --pttPad: 4px; --kb-main-h: var(--pttStageSize); width: calc(var(--pttStageSize) + 258px + 386px + (2 * 4px)); }

    #screenBingo .layout.gameLayout.kbPttLayout {
      grid-template-columns: var(--pttStageSize) 258px 386px;
      width: calc(var(--pttStageSize) + 258px + 386px + (2 * 4px));
      align-items: stretch;
      column-gap: 4px;
      row-gap: 4px;

      height: var(--pttStageSize);
      grid-template-rows: 1fr;
      justify-items: stretch;
    }

    #screenBingo #bingoSlot { width: var(--pttStageSize); height: var(--pttStageSize); }

    #screenBingo #bingoPane {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      min-height: 0;
      overflow: hidden;
      background: transparent;
    }

    /* MTN: 512x512 board framed to 514x514 with a 1px border (matches NTC map slot) */
    #screenBingo #bingoBoardFrame {
      box-sizing: border-box;
      width: var(--pttStageSize);
      height: var(--pttStageSize);
      border: 1px solid #ddd;
      border-radius: 8px;
      background: var(--kb-ocean-gray);
      overflow: hidden;

      /* Anchor the grid to the frame, avoid flex-centering rounding artifacts */
      display: block;
      padding: 0;
    }

    #screenBingo #bingoGrid.pttBoard {
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      padding: var(--pttPad);

      display: grid;
      grid-template-columns: repeat(11, var(--pttCellSize));
      grid-template-rows: repeat(11, var(--pttCellSize));
      gap: var(--pttGap);

      background: var(--kb-ocean-gray);
    }

    #screenBingo .pttHdr,
    #screenBingo .pttCorner {
      box-sizing: border-box;
      background: var(--kb-map-white);
      border: 1px solid #ddd;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      color: #333333;
      user-select: none;
    }

    #screenBingo .pttCorner {
      background: transparent;
      border: 1px solid transparent;
    }

    #screenBingo .pttCell { box-sizing: border-box; }

    #screenBingo .pttCell .bingoLine,
    #screenBingo .pttCell .bingoPairBtn {
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: var(--kb-map-white);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0;
      font-weight: 400;
      font-size: 14px;
      color: #333333;
      padding: 0;
      user-select: none;
    }

    
    /* MTN: match board frame rounding to prevent edge clipping */
    #screenBingo .bingoPairBtn { border-radius: 8px; }
#screenBingo .pttCell .bingoPairBtn { cursor: pointer; }

    #screenBingo .kbPttSideLeft,
    #screenBingo .kbPttSideRight {
      height: var(--pttStageSize);
      overflow: auto;
    }

    #screenBingo #bingoSide.kbPttSideLeft {
      width: 258px;
      overflow: hidden;
      gap: 0px;
      height: var(--pttStageSize);
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    #screenBingo #bingoAccounts.kbPttSideRight {
      width: 386px;
      overflow: hidden;
      gap: 4px;
      height: var(--pttStageSize);
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    #screenBingo #bingoQuizPane { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; padding-bottom: 11px; }
    #screenBingo #bingoQuizPane .answers { flex: 1 1 auto; min-height: 0; padding-bottom: 6px; }
    #screenBingo #bingoQuizPane .controls { margin-top: auto; }

    /* Screen 4: Multiply Two Numbers grid */
    #bingoPane{
      background: var(--kb-ocean-gray);
    }
    #bingoGrid{
      height: 100%;
    }
    .bingoGrid{
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-auto-rows: 1fr;
      gap: 16px;
      align-items: stretch;
    
      background: var(--kb-ocean-gray);
    }
    .bingoCard{
      background: var(--kb-map-white);
      border-radius: 14px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    
      border: 1px solid var(--kb-ocean-gray);
    }
    .bingoCardHeader{
      background: var(--kb-map-white);
      color: #333333;
      text-align: center;
      font-weight: 700;
      font-size: 30px;
      min-height: 56px;
      padding: 12px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .bingoCardBody{
      padding: 0 14px 14px 14px;
      color: #111;
      display: flex;
      flex-direction: column;
      justify-content: space-evenly;
      flex: 1;
      min-height: 0;
    }

    .bingoPairBtn{
      width: 100%;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(106, 109, 110, 0.45);
      background: var(--kb-map-white);
      cursor: default;
      font-size: 24px;
      line-height: 1;
      min-height: 36px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      color: #333333;
    }
    .bingoPairBtn .bingoA{ padding: 0; }
    .bingoPairBtn .bingoX{ padding: 0; }
    .bingoPairBtn .bingoB{ padding: 0; }

.bingoLine{
      width: 100%;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      white-space: nowrap;
    }
    .bingoA{
      justify-self: end;
      text-align: right;
      padding-right: 0.5ch;
    }
    .bingoX{
      justify-self: center;
      text-align: center;
    }
    .bingoB{
      justify-self: start;
      text-align: left;
      padding-left: 0.5ch;
    }


    .storeRating{
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
      font-size: 12px;
      line-height: 1.2;
      user-select: none;
    }
    .storeRating .ratingValue{
      font-weight: 400;
color: #111;
    }
    .storeRating .ratingStars{
      color: #f4b400;
      letter-spacing: 1px;
      font-size: 14px;
      transform: translateY(-0.5px);
    }
    .storeRating .ratingCaret{
      color: #777;
      font-size: 14px;
      transform: translateY(-0.5px);
    }
    .storeRating .ratingCount{
      color: #777;
      font-size: 12px;
    }


    .storeRating .ratingStarsBox{
      position: relative;
      display: inline-block;
      line-height: 1;
      vertical-align: middle;
    }
    .storeRating .starsBase{
      color: #d0d0d0;
      letter-spacing: 1px;
      font-size: 14px;
    }
    .storeRating .starsFill{
      position: absolute;
      left: 0;
      top: 0;
      overflow: hidden;
      white-space: nowrap;
      color: #f4b400;
      letter-spacing: 1px;
      font-size: 14px;
    }



/* ===== NTC layout guardrails (0.1.257) ===== */
#screenGame .layout.gameLayout.kbNtcLayout { grid-template-columns: var(--ntcMapSize) 258px 386px; column-gap: 4px; row-gap: 4px; width: 1166px; }
#screenGame #mapSlot { width: 514px; height: 514px; }
#screenGame #quizPane { width: 100%; box-sizing: border-box; padding-bottom: 18px; }
#screenGame #side.kbNtcSideLeft { width: 258px; box-sizing: border-box; overflow: hidden; gap: 0px; 
      min-height: 0;
}
#screenGame .bottomBar { gap: 10px; }
#screenGame .bottomBar button, #screenGame #nextBtn { font-size: 14px; }

/* Answer rows */
#screenGame .ansBtn { font-size: 16px; line-height: 1.2; min-height: 32px; padding: 6px 10px; gap: 0; }
#screenGame .answers li { margin: 1px 0; }
#screenGame .ansBtn .label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      line-height: 1.3;}

/* Bullet alignment: dot under the 'S' in 'Select' */
#screenGame .ansBtn 
/* Prevent accidental centering gap on screens */
.screen { margin: 0; }
/* ===== end guardrails ===== */
/* NTC pane padding experiment (0.1.260) */
#screenGame #side.kbNtcSideLeft .pane { padding: 10px; }
#screenGame #quizPane { padding: 10px; }
#screenGame #ntcAccounts.kbNtcSideRight .pane { padding: 10px; }
#screenGame #spigotPane { padding: 10px; }



    

    /* NTC: push bottom 3 panes to map bottom, breathing gap sits below spigot */
    

    /* NTC: let Education Sponsors pane absorb zoom rounding instead of a visible gap */
    #screenGame #ntcAccounts.kbNtcSideRight > .pane:nth-child(2) { flex: 1 1 auto; min-height: 0; }
    #screenGame #ntcAccounts.kbNtcSideRight > *:not(.pane:nth-child(2)) { flex: 0 0 auto; }


    /* NTC footer: final authoritative rule to avoid later .copyrightLine overrides */
    #screenGame .copyrightLine{ width: 100%; text-align: center; margin-top: 8px; }


    /* NTC: lock the game grid height to the map size, prevents extra blank space before the footer */
    #screenGame .layout.gameLayout.kbNtcLayout{
      height: var(--ntcMapSize);
      grid-template-rows: var(--ntcMapSize);
      align-content: start;
      max-height: var(--ntcMapSize);
    }
    #screenGame #mapSlot,
    #screenGame #side.kbNtcSideLeft,
    #screenGame #ntcAccounts.kbNtcSideRight{
      height: var(--ntcMapSize);
      max-height: var(--ntcMapSize);
      min-height: 0;
    }


    /* Global button styling (all screens), based on the NTC "Misses" button. Excludes NTC answer rows (.ansBtn). */
    button:not(.ansBtn){
      font-size: 14px;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #888;
      background: #f4f4f4;
      cursor: pointer;
      white-space: nowrap;
      color: #111;
    }
    button:not(.ansBtn):hover:not(:disabled){
      background: #eee;
    }
    button:not(.ansBtn):disabled{
      opacity: 0.55;
      cursor: default;
    }


        /* Screen 1: keep internal scrolling enabled and match Screen 2 spacing */
    #screenEdu #eduPane{
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #screenEdu #eduPane .redeemHeader{
      margin-bottom: 0;
    }
    #screenEdu #eduPane h2{
      margin: 0 0 6px 0;
    }
    #screenEdu #eduPane .storePrice{
      margin: 0;
    }
    #screenEdu #eduList{
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      margin-top: 10px;
      margin-bottom: 0;
      padding-top: 0;
      padding-bottom: 0;
    }
    #screenEdu #eduList .storeList{
      margin-top: 0;
      margin-bottom: 0;
      gap: 4px;
    }
    #screenEdu #eduPane .controls.mainSlotNav{
      margin-top: 10px;
      margin-bottom: 0;
    }

/* Screen 2: keep internal scrollbar and align list to 10px below header line */
    #screenStore #redeemPane{
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #screenStore #redeemPaneMessage{
      min-height: 20px;
      line-height: 20px;
      margin: 0 0 10px 0;
    }
    #redeemPaneMessage:empty{
      display: block;
      visibility: hidden;
    }
#screenStore #store{
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      margin-top: 0;
    }
    #screenStore #store .storeList{
      margin-top: 0;
      margin-bottom: 0;
      gap: 4px;
    }
    #screenStore #redeemPane .controls.mainSlotNav{
      margin-top: 10px;
      margin-bottom: 0;
    }

    #screenStore #redeemPane .redeemHeader{
      margin-bottom: 0;
    }

    #screenStore #redeemPane h2{
      margin: 0 0 6px 0;
    }
    #screenStore #redeemPane .storePrice{
      margin: 0;
    }



/* 0.1.325: Reserve a stable one-line message slot under the Available line on both screens.
   This keeps the first gray card aligned between Educational Content and Redemption Store. */
#screenStore #redeemPaneMessage,
#screenEdu #eduPaneMessage{
  min-height: 20px !important;
  line-height: 20px !important;
  font-size: 13px !important;
  color: #333 !important;
  white-space: pre-wrap !important;
  margin-top: 8px !important;
  margin-bottom: 10px !important;
  display: block !important;
}

#screenStore #redeemPaneMessage:empty,
#screenEdu #eduPaneMessage:empty{
  visibility: hidden !important;
}

/* Ensure list containers do not add their own top spacing. */
#screenStore #store,
#screenEdu #eduList{
  margin-top: 0 !important;
}


    /* PTT: match NTC pane and answer list spacing */
    #screenBingo #bingoQuizPane { padding: 10px; }
    #screenBingo #bingoAccounts.kbPttSideRight .pane { padding: 10px; }
    #screenBingo #bingoSpigotPane { padding: 10px; }

    #screenBingo .ansBtn {
      font-size: 16px;
      min-height: 34px;
      line-height: 1.3;
      padding: 0px 10px 0px 2px;
    }

    /* PTT board: allow grid items to shrink so all columns fit inside 512x512 */
    #screenBingo #bingoGrid.pttBoard > * { min-width: 0; min-height: 0; }
    #screenBingo .pttCell .bingoLine,
    #screenBingo .pttCell .bingoPairBtn { min-width: 0; }

    /* PTT board: tighter text for A × B so it does not force column growth */
    #screenBingo .pttCell .bingoLine,
    #screenBingo .pttCell .bingoPairBtn {
      font-size: 12px;
      gap: 2px;
    }
    #screenBingo .pttHdr { font-size: 12px; }

    /* PTT: render A × B as A space × space B, and do not bold */
    #screenBingo .pttCell .bingoPairBtn .bingoX { margin: 0; font-weight: 400; padding: 0 2px; font-size: 13px; }
    #screenBingo .pttCell .bingoPairBtn .bingoA,
#screenBingo .pttCell .bingoPairBtn .bingoB { font-weight: 400; font-size: 13px; }

    /* PTT: make row/column header cells match pair cell size */
    #screenBingo .pttHdr{
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: var(--kb-map-white);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 12px;
      color: #333333;
      user-select: none;
    }

    /* PTT: ensure orange, green, red highlights win over base button styling */
    #screenBingo .bingoPairBtn.kbBingoDoneCorrect,
    #screenBingo .bingoPairBtn.kbBingoDoneCorrect:hover,
    #screenBingo .bingoPairBtn.kbBingoDoneCorrect:active,
    #screenBingo .bingoPairBtn.kbBingoDoneCorrect:focus {
      background: #c8f3c8;
      border-color: #7bd47b;
      color: #333333;
    }

    #screenBingo .bingoPairBtn.kbBingoDoneWrong,
    #screenBingo .bingoPairBtn.kbBingoDoneWrong:hover,
    #screenBingo .bingoPairBtn.kbBingoDoneWrong:active,
    #screenBingo .bingoPairBtn.kbBingoDoneWrong:focus {
      background: #f6c1c1;
      border-color: #e18a8a;
      color: #333333;
    }

    #screenBingo .bingoPairBtn.kbBingoCurrent,
    #screenBingo .bingoPairBtn.kbBingoCurrent:hover,
    #screenBingo .bingoPairBtn.kbBingoCurrent:active,
    #screenBingo .bingoPairBtn.kbBingoCurrent:focus {
      background: orange;
      border-color: rgba(199, 111, 0, 0.75);
      outline: none;
    }

#screenBingo .bingoPairBtn.kbBingoCurrent,
#screenBingo .bingoPairBtn.kbBingoCurrent:hover,
#screenBingo .bingoPairBtn.kbBingoCurrent:active,
#screenBingo .bingoPairBtn.kbBingoCurrent:focus {
  /* Current pair is shown with the same orange highlight as the header buttons. */
  background: orange;
  border-color: rgba(199, 111, 0, 0.75);
  outline: none;
}

#screenBingo .bingoPairBtn .bingoResult {
  font-size: 14px;
  display: none;
  grid-column: 1 / -1;
  justify-self: center;
  text-align: center;
}

#screenBingo .bingoPairBtn.kbBingoBlank .bingoA,
#screenBingo .bingoPairBtn.kbBingoBlank .bingoX,
#screenBingo .bingoPairBtn.kbBingoBlank .bingoB {
  visibility: hidden;
}

#screenBingo .bingoPairBtn.kbBingoShowResult .bingoA,
#screenBingo .bingoPairBtn.kbBingoShowResult .bingoX,
#screenBingo .bingoPairBtn.kbBingoShowResult .bingoB {
  display: none;
}

#screenBingo .bingoPairBtn.kbBingoShowResult .bingoResult {
  display: block;
}



    /* PTT: match NTC answer list spacing and bullet alignment */
    #screenBingo .answers { list-style: none; padding: 0; margin: 0; flex: 1 1 auto; min-height: 0; padding-bottom: 6px; }
    #screenBingo .answers li { margin: 1px 0; }


    /* PTT footer width match NTC */
    #screenBingo .copyrightLine { width: 100%; text-align: center; margin-top: 8px; }



/* PTT board polish: 11x11 grid, square headers, top-left X, no board clicks, header highlights */
#screenBingo .pttCorner,
#screenBingo .pttHdr{
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(0,0,0,0.25);
  border-radius: 8px;
  background: #ffffff;
  font-size: 14px;
  font-weight: 700;
  user-select: none;
  pointer-events: none;
  cursor: default;
}

#screenBingo .pttCorner{
  font-weight: 700;
}

#screenBingo .pttCell .bingoPairBtn .bingoA,
#screenBingo .pttCell .bingoPairBtn .bingoB{ padding: 0; }

#screenBingo .pttHdr.kbBingoHdrCurrent,
#screenBingo .pttCorner.kbBingoHdrCurrent{
  background: orange;
  border-color: rgba(199, 111, 0, 0.75);
}


    /* 0.1.338 PTT board text, sizing, and non-interactive guardrails */
    #screenBingo #bingoGrid .bingoPairBtn,
    #screenBingo #bingoGrid .pttHdr,
    #screenBingo #bingoGrid .pttCorner{
      cursor: default;
      pointer-events: none;
    }

    #screenBingo #bingoGrid .pttCell .bingoPairBtn{
      font-size: 14px;
      gap: 0;
      font-weight: 400;
    }

    #screenBingo #bingoGrid .pttCell .bingoX{ padding: 0 3px; }
    #screenBingo #bingoGrid .pttCell .bingoPairBtn{ font-size: 14px; gap: 0; }
    #screenBingo #bingoGrid .pttCell .bingoPairBtn .bingoA,
    #screenBingo #bingoGrid .pttCell .bingoPairBtn .bingoX,
    #screenBingo #bingoGrid .pttCell .bingoPairBtn .bingoB{
      font-size: 13px;
      line-height: 1;
    }




    #screenBingo #bingoGrid .pttHdr,
    #screenBingo #bingoGrid .pttCorner{
      font-size: 15px;
      font-weight: 600;
    }

    #screenBingo #bingoGrid .pttCell .bingoPairBtn .bingoA,
    #screenBingo #bingoGrid .pttCell .bingoPairBtn .bingoX,
    #screenBingo #bingoGrid .pttCell .bingoPairBtn .bingoB{
      font-weight: 400;
    }

    #screenBingo #bingoGrid .pttCell .bingoPairBtn .bingoX{
      margin: 0;
    }

    /* PTT answer list should match NTC spacing */
    #screenBingo #bingoQuizPane .answers{
      padding-bottom: 6px;
    }

/* Answer bullet alignment: dot under the 'S' in 'Select' (match 0.1.325 look) */
#screenGame .ansBtn .bullet,
#screenBingo .ansBtn .bullet {
  flex: 0 0 0;
  width: 0;
  margin-left: -8px;
  margin-right: 12px;
  text-align: left;
}

/* Keep PTT answer-row left padding consistent with NTC so bullet alignment matches */
#screenBingo .ansBtn {
  padding-left: 10px;
}

/* 0.1.358: Set footer spacing to 8px. */
#screenGame .copyrightLine { margin-top: 8px !important; }

/* 0.1.359: Keep footer position stable across screens, prevent tiny width-based shifts. */
#screenEdu .copyrightLine,
#screenStore .copyrightLine{
  width: 100% !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
}


    /* MTN: prevent global .bingoPairBtn padding from overflowing 44x44 grid cells */
    #screenBingo #bingoGrid .bingoPairBtn{
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      padding: 0 !important;
      display: flex !important;
      align-items: center;
      justify-content: center;
    }


/* Consolidated accounts pane for NTC and MTN */
.acctMegaPane {
  width: 386px;
  height: 514px;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #fff;
  box-sizing: border-box;
  overflow: hidden;
}
.acctMegaScroll {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
  overflow-y: hidden;
  scrollbar-width: none;
  -ms-overflow-style: none;
}
.acctMegaScroll::-webkit-scrollbar { width: 0; height: 0; }

/* In the consolidated accounts pane, tighten vertical rhythm to avoid scrollbars */
.acctMegaPane .acctLine { margin-top: 6px; }
.acctMegaPane .acctSubPane {
  border: 0;
  background: transparent;
  box-shadow: none;
  margin: 0;
  border-radius: 0;
  padding: 9px 12px;
}


.acctMegaPane .acctMegaScroll > .pane.acctSubPane { padding-bottom: 13px !important; }
.acctMegaPane .acctSubPane + .acctSubPane {
  border-top: 1px solid #ddd;
}
.acctMegaPane .arrowDivider {
  margin: 0;
}
.acctMegaPane .arrowDivider.acctSubPane {
  padding-top: 9px;
  padding-bottom: 5px !important;
  padding-left: 8px;
  padding-right: 12px;
  margin-bottom: 0px !important;
}

.acctMegaPane .spigotPane {
  border: 0;
  background: transparent;
  box-shadow: none;
  padding: 0 !important;
  margin: 0 !important;
}


/* Mega-pane spigot: match 0.1.237 look (bigger icon, vertically-centered text) */
.acctMegaPane .spigotInner { align-items: center; }
.acctMegaPane .spigotImg { height: 56px; max-height: 56px; max-width: none; width: auto; align-self: center; }
.acctMegaPane .spigotText { justify-content: center; }
.acctMegaPane .spigotText .acctLine { margin-top: 0; }
.acctMegaPane .spigotText .acctLine + .acctLine { margin-top: 4px; }

/* Fix slight top-spacing discrepancy in Platform section */
.acctMegaPane #platformAcct,
.acctMegaPane #bingoPlatformAcct { margin-top: 8px; }


/* Column 2 mega panes (NTC + MTN): merge answer pane and bottom bar into one bordered container */
.quizMegaPane{
  box-sizing: border-box;
  width: 258px;
  height: var(--kb-main-h);
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #fff;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.quizMegaScroll{
  flex: 1 1 auto;
  min-height: 0;
  display: flex;
  flex-direction: column;
}
.quizSubPane{
  flex: 1 1 auto;
  min-height: 0;
  padding: 14px;
  box-sizing: border-box;
  border: none;
  border-radius: 0;
  background: transparent;
}
.quizSubPane .paneHeader{ margin-bottom: 6px; }
.quizSubPane h3{margin:0; font-size:16px;}
.quizBottomBar{
  border: none;
  border-top: 1px solid #ddd;
  border-radius: 0;
  background: transparent;
  padding: 10px;
  box-sizing: border-box;
  margin: 0;
}

.quizBottomBar.bottomBar{border:none; border-top:1px solid #ddd; border-radius:0; background: transparent; padding:10px;}



#screenGame .leaflet-bar{ border: 1px solid rgba(0,0,0,0.2); box-shadow: none; }
#screenGame .leaflet-control-zoom a{ width: 24px; height: 24px; line-height: 24px; font-size: 16px; }

/* Screen 1 (Educational Content): typography to match Parent (h3) and Flow rate (acctLine) */
.eduMid .storeMeta strong{
  font-size: 16px;
  font-weight: 700;
  line-height: 1.2;
}
.eduMid .storeMeta .storeRating,
.eduMid .storeMeta .storeStarsLine,
.eduMid .storeMeta .storeGradeLine,
.eduMid .eduFundsCol .eduFundsLine{
  font-size: 13px;
  font-weight: 400;
  line-height: 1.35;
  color: #333;
}
.eduMid .eduFundsTitle{
  font-size: 16px;
  font-weight: 400;
  line-height: 1.2;
  color: inherit;
}
/* Ensure consistent vertical rhythm so rows align across the two columns */
.eduMid .storeMeta > div,
.eduMid .eduFundsCol > div{
  margin: 0;
  padding: 0;
}


/* Screen 1 (Educational Content): shift KBU funds blocks right for alignment */
.eduMid .eduFundsCol > div{
  margin-left: var(--eduFundsIndent);
}

/* Screen 2 (Redemption Store): typography to match Educational Content card fonts */
#screenStore .storeMeta strong{
  font-size: 16px;
  font-weight: 700;
  line-height: 1.2;
}
#screenStore .storeMeta .storeRating{
  font-size: 13px;
  font-weight: 400;
  line-height: 1.35;
  color: #333;
}
#screenStore .storeMeta .storePrice,
#screenStore .storeMeta .storeBrand{
  font-size: 13px;
  font-weight: 400;
  line-height: 1.35;
  color: #333;
}

/* Screen 2 (Redemption Store): match Educational Content vertical rhythm and alignment for the four text lines */
#screenStore .storeLeft{
  align-items: flex-start;
}
#screenStore .storeMeta{
  display: flex;
  flex-direction: column;
  gap: 4px;
}
#screenStore .storeMeta > div{
  margin: 0;
  padding: 0;
}

















/* Screen 1 (Educational Content): align title and K-Bucks rows across the two columns */
.eduMid{
  display: grid;
  grid-template-columns: var(--eduColTitle) var(--eduColKB);
  grid-template-rows: repeat(4, min-content);
  column-gap: var(--eduColGap);
  row-gap: 4px;
  align-items: start;
  min-width: 0;
}
/* Let children of the two column wrappers participate in the parent grid */
.eduMid .storeMeta,
.eduMid .eduFundsCol{
  display: contents;
}
/* Grid placement for aligned rows */
.eduRow1Left{ grid-column: 1; grid-row: 1; }
.eduRow2Left{ grid-column: 1; grid-row: 2; }
.eduRow3Left{ grid-column: 1; grid-row: 3; }
.eduRow4Left{ grid-column: 1; grid-row: 4; }

.eduRow1Right{ grid-column: 2; grid-row: 1; }
.eduRow2Right{ grid-column: 2; grid-row: 2; }
.eduRow3Right{ grid-column: 2; grid-row: 3; }
.eduRow4Right{ grid-column: 2; grid-row: 4; }


/* Screen 1: smaller thumbnails for content cards */
#screenEdu .storeThumb{
  width: 128px;
  height: 128px;
}


/* Screen 2 (Redemption Store): constrain thumbnails to 128x128 */
#screenStore .storeThumb,
#screenStore .storeItemThumb,
#screenStore .redeemThumb{
  width: 128px;
  height: 128px;
  flex: 0 0 128px;
  overflow: hidden;
  border-radius: 8px;
}
#screenStore .storeThumb img,
#screenStore .storeItemThumb img,
#screenStore .redeemThumb img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}


/* Color normalization: use #333 for key headings/titles/labels */
#screenEdu h2,
#screenStore h2,
#screenGame .promptLabel,
#screenBingo .promptLabel,
#screenGame h3,
#screenBingo h3,
#screenGame .walletHdr,
#screenBingo .walletHdr,
#screenGame .answersTitle,
#screenBingo .answersTitle{
  color: #333;
}

/* EDU content card titles and K-Bucks header */
#screenEdu .eduCellTitle,
#screenEdu .storeMeta strong,
#screenEdu .eduFundsTitle{
  color: #333;
}

/* Store item titles */
#screenStore .storeMeta strong,
#screenStore .storeTitle,
#screenStore .storeItemTitle{
  color: #333;
}

/* Wallet section headers in NTC/MTN (fallback selectors) */
#screenGame .acctHdr,
#screenBingo .acctHdr,
#screenGame .pane h3,
#screenBingo .pane h3{
  color: #333;
}

/* "Select an answer:" label */
#screenGame .answersPane h3,
#screenBingo .answersPane h3,
#screenGame .answersPaneTitle,
#screenBingo .answersPaneTitle{
  color: #333;
}


/* NTC: re-introduce Leaflet zoom bar shadow */
#screenGame .leaflet-bar{
  box-shadow: 0 1px 3px rgba(0,0,0,0.65);
}


/* Remove unused status line under answers list (NTC + MTN) */
#quizPane #message,
#bingoQuizPane #bingoMessage{
  display: none !important;
  margin: 0 !important;
  padding: 0 !important;
  min-height: 0 !important;
  height: 0 !important;
}


/* MTN: match NTC gap between last answer row and "Next question" */
#screenBingo #bingoQuizPane ul.answers{
  flex: 0 0 auto !important;
}
#screenBingo #bingoQuizPane .controls{
  margin-top: 8px !important;
}


/* MTN spacing parity with NTC:
   1) Restore the original controls push-down behavior (do not pull "Next question" up)
   2) Make MTN answer rows use the same sizing as NTC so the last bullet sits at the same height
*/
#bingoQuizPane .controls{
  margin-top: auto !important;
}

#screenBingo .ansBtn{
  font-size: 16px !important;
  line-height: 1.2 !important;
  min-height: 32px !important;
  padding: 6px 10px !important;
  gap: 0 !important;
}


/* MTN gap parity with NTC:
   - Keep "Next question" in its original pushed-down position
   - Make MTN answer rows match NTC row sizing so the last answer sits lower (smaller gap)
*/
#bingoQuizPane .answers{
  flex: 1 1 auto !important;
}
#bingoQuizPane .controls{
  margin-top: auto !important;
}
#screenBingo .ansBtn{
  font-size: 16px !important;
  line-height: 1.2 !important;
  min-height: 32px !important;
  padding: 6px 10px !important;
  gap: 0 !important;
}


/* FINAL: MTN quiz spacing parity with NTC.
   Goal: restore MTN "Next question" placement (pushed down) and make the LAST answer sit lower
   by forcing MTN answer-row sizing to match NTC.
*/
#screenBingo #bingoQuizPane{
  display: flex !important;
  flex-direction: column !important;
}
#screenBingo #bingoQuizPane #bingoAnswers{
  flex: 1 1 auto !important;
  min-height: 0 !important;
  padding-bottom: 6px !important;
}
#screenBingo #bingoQuizPane .controls{
  margin-top: auto !important;
}
#screenBingo #bingoQuizPane .ansBtn{
  font-size: 16px !important;
  line-height: 1.2 !important;
  min-height: 32px !important;
  padding: 6px 10px !important;
  display: flex !important;
  align-items: center !important;
  gap: 0 !important;
}
#screenBingo #bingoQuizPane .ansBtn .label{
  line-height: 1.2 !important;
}


/* MTN vs NTC answers gap:
   MTN had default UL margin adding extra space between the last answer row and the controls.
   Reset UL margin and padding to match NTC.
*/
#screenBingo #bingoQuizPane ul.answers,
#screenBingo #bingoAnswers{
  margin: 0 !important;
  padding: 0 !important;
}


/* Parity: NTC and MTN answers layout.
   Fixes:
   - Undo accidental global ul.answers flex override
   - Force MTN answers list sizing to match NTC so the last answer and Next question gap matches
   - Force MTN answer button height to match NTC so green and red bars are the same thickness
*/
#screenGame #quizPane ul.answers,
#screenBingo #bingoQuizPane ul.answers{
  flex: 1 1 auto !important;
}
#screenBingo #bingoQuizPane .answers{
  flex: 1 1 auto !important;
  min-height: 0 !important;
  padding-bottom: 6px !important;
}
#screenBingo #bingoQuizPane .controls{
  margin-top: auto !important;
}
#screenBingo #bingoQuizPane .ansBtn{
  font-size: 16px !important;
  line-height: 1.2 !important;
  min-height: 32px !important;
  padding: 6px 10px !important;
  display: flex !important;
  align-items: center !important;
  gap: 0 !important;
}



/* MTN gap parity refinement:
   Match MTN answer-row sizing to NTC (including padding and line-height) and
   use a fractional fixed height to prevent cumulative drift vs NTC.
*/
#screenBingo #bingoQuizPane .ansBtn{
  font-size: 16px !important;
  line-height: 1.2 !important;
  padding: 6px 10px !important;
  gap: 0 !important;
  height: 34.8px !important;
  min-height: 34.8px !important;
  box-sizing: border-box !important;
}



/* Screen 2: two-column grid wrapper for the Redemption Store body, column 2 is reserved for future text blocks. */
#screenStore #storeGrid.kbStoreGrid2Col{
  flex: 1 1 auto;
  min-height: 0;
  min-width: 0;
  display: grid;

  /* Keep the redemption-item list width unchanged by collapsing column 2 for now. */
  --kbStoreCol2W: 0px;
  --kbStoreGridGap: 0px;

  grid-template-columns: minmax(0, 1fr) var(--kbStoreCol2W);
  column-gap: var(--kbStoreGridGap);
  row-gap: 0;
  overflow: hidden;
}
#screenStore #storeGrid.kbStoreGrid2Col > #store{
  min-height: 0;
  min-width: 0;
  width: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  margin: 0;
}
#screenStore #storeGrid.kbStoreGrid2Col > #storeCol2{
  min-height: 0;
  min-width: 0;
  width: 0;
  padding: 0;
  margin: 0;
  overflow: hidden;
}
</style>

    <!-- Favicons -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico" sizes="any">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
</head>
<body>
<div class="wrap">
<div class="screen" id="screenGame" style="display:none;">
<div class="headerBar">
<div class="topHeader">
<p class="title">Name That Country</p>
<div aria-live="polite" class="topStatus">
<div class="scoreInline" id="progress">Progress: 0/0</div>
<div class="scoreInline" id="status">Score: 0/0 (0%)</div>
<div class="scoreInline" id="timer">Time: 00:00:00</div>
</div>
</div>
</div>
<div class="layout gameLayout kbNtcLayout">
<div id="mapSlot">
<div class="kbMapBuffer kbMapFront" id="mapA"></div>
<div class="kbMapBuffer kbMapBack" id="mapB"></div>
</div>
<div class="side kbNtcSideLeft" id="side">
<div class="quizMegaPane" id="ntcQuizMegaPane">
<div class="quizMegaScroll">
<div class="quizSubPane" id="quizPane">
<div class="paneHeader">
<h3>Select an answer:</h3>
</div>
<ul class="answers" id="answers"></ul>
<div class="status" id="message"></div>
<div class="controls">
<button disabled="" id="nextBtn" type="button">Next question</button>
</div>
</div>
<div class="bottomBar quizBottomBar">
<button disabled="" id="quitBtn" type="button">Misses</button>
<button id="startNewBtn" type="button">New game</button>
<button id="redeemBtn" type="button">Quit</button>
</div>
</div>
</div>
</div>
<div class="side kbNtcSideRight" id="ntcAccounts">
<div class="acctMegaPane" id="ntcAcctMegaPane">
<div class="acctMegaScroll">
<div class="pane acctSubPane">
<h3>Parent</h3>
<div class="acctLine">
            KBU balance:
            <input class="moneyInput" id="parentInput" inputmode="decimal" min="0" step="0.01" type="text" value="0.00"/>
</div>
<div class="acctLine">
            Flow rate (KBU per correct answer):
            <input class="flowInput moneyInput" id="flowRateInput" inputmode="decimal" min="0" step="any" type="text" value="0.00"/>
</div>
</div>
<div class="pane acctSubPane">
<h3>Education Sponsors</h3>
<div class="acctLine">
            KBU balance:
            <input class="moneyInput" id="sponsorInput" inputmode="decimal" min="0" step="any" type="text" value="0.00"/>
</div>
<div class="acctLine">
            Parent-to-Sponsors match ratio (3 ≤ x ≤ 7):
            <input class="flowInput" id="sponsorMatchInput" max="7" min="3" step="any" type="number" value="5"/><span class="matchSuffix">: 1</span></div>
</div>
<div aria-hidden="true" class="arrowDivider acctSubPane"><div class="pane spigotPane" id="spigotPane">
<div class="spigotInner">
<img alt="" class="spigotImg" src="spigot.png?v=3"/>
<div class="spigotText">
<div class="acctLine">Flow rate (KBU, Parent + Sponsors): <span id="spigotFlowRateOut">0.00</span></div>
<div class="acctLine kbHourLine">KBU per hour (estimate): <span id="spigotKbucksPerHourOut">0.00</span></div>
</div>
</div>
</div></div>
<div class="pane acctSubPane" id="childPane">
<h3>Child <span class="pct">(75%)</span><span class="kbInfoIcon" data-tooltip="This balance is global" tabindex="0">ⓘ</span></h3>
<div class="acctLine" id="childAcct">KBU balance: 0.00</div>
</div>
<div class="pane acctSubPane">
<h3>Content Developer <span class="pct">(12.5%)</span></h3>
<div class="acctLine" id="devAcct">KBU balance: 0.00</div>
</div>
<div class="pane acctSubPane">
<h3>K-Bucks Platform <span class="pct">(12.5%)</span><span class="kbInfoIcon" data-tooltip="This balance is global" tabindex="0">ⓘ</span></h3>
<div class="acctLine" id="platformAcct">KBU balance: 0.00</div>
<div class="acctLine" id="platformInfo"></div>
</div>
</div>
</div>
</div>
</div>
<div class="copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.2.0</span></div>
</div>
<div class="screen" id="screenStore" style="display:none;">
<div class="headerBar">
<div class="topHeader">
<p class="title">K-Bucks: Learn &amp; Earn!</p>
</div>
</div>
<div class="storeMain">
<div aria-live="polite" id="redeemPane">
<div class="redeemHeader">
<div>
<h2>Redemption Store</h2>
<div class="kbMainHeaderBlock"><p class="storePrice" id="redeemBalance">Available for the Child to redeem: KBU 0.00</p>
<div id="redeemPaneMessage"></div></div>
</div>
</div>
<div id="storeGrid" class="kbStoreGrid2Col">
<div id="store"><div class="kbListState">Loading...</div></div>
<div id="storeCol2"></div>
</div>
<div class="controls mainSlotNav">
<button id="closeRedeemBtn" type="button">Educational Content</button>
</div>
</div>
</div>
<div class="copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.2.0</span></div>
</div>
<div class="screen" id="screenEdu">
<div class="headerBar">
<div class="topHeader">
<p class="title">K-Bucks: Learn &amp; Earn!</p>
</div>
</div>
<div class="storeMain">
<div aria-live="polite" id="eduPane">
<div class="redeemHeader">
<div>
<h2>Educational Content</h2>
<div class="kbMainHeaderBlock"><p class="storePrice" id="earnBalance">Available for the Child to earn (from Parent + Education Sponsors): KBU 0.00</p>
<div id="eduPaneMessage"></div></div>
</div>
</div>
<div id="eduList"><div class="kbListState">Loading...</div></div>
<div class="controls mainSlotNav">
<button id="openStoreBtn" type="button">Redemption Store</button>
</div>
</div>
</div>
<div class="copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.2.0</span></div>
</div>
<div class="screen" id="screenBingo" style="display:none;">
<div class="headerBar">
<div class="topHeader">
<p class="title">Multiply Two Numbers</p>
<div aria-live="polite" class="topStatus">
<div class="scoreInline" id="bingoProgress">Progress: 0/100 (0%)</div>
<div class="scoreInline" id="bingoStatus">Score: 0/0 (0%)</div>
<div class="scoreInline" id="bingoTimer">Time: 00:00:00</div>
</div>
</div>
</div>
<div class="layout gameLayout kbPttLayout">
<div id="bingoSlot">
<div aria-live="polite" id="bingoPane">
<div id="bingoBoardFrame">
<div class="pttBoard" id="bingoGrid">
<div class="pttCorner">×</div>
<div class="pttHdr">1</div>
<div class="pttHdr">2</div>
<div class="pttHdr">3</div>
<div class="pttHdr">4</div>
<div class="pttHdr">5</div>
<div class="pttHdr">6</div>
<div class="pttHdr">7</div>
<div class="pttHdr">8</div>
<div class="pttHdr">9</div>
<div class="pttHdr">10</div>
<div class="pttHdr">1</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">1</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">2</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">2</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">3</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">3</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">4</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">4</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">5</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">5</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">6</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">6</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">7</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">7</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">8</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">8</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">9</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">9</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
<div class="pttHdr">10</div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">1</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">2</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">3</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">4</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">5</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">6</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">7</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">8</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">9</span></button></div>
<div class="pttCell"><button class="bingoPairBtn" type="button"><span class="bingoA">10</span><span class="bingoX">x</span><span class="bingoB">10</span></button></div>
</div>
</div>
</div>
</div>
<div class="side kbPttSideLeft" id="bingoSide">
<div class="quizMegaPane" id="bingoQuizMegaPane">
<div class="quizMegaScroll">
<div class="quizSubPane" id="bingoQuizPane">
<div class="paneHeader">
<h3>Select an answer:</h3>
</div>
<ul class="answers" id="bingoAnswers"></ul>
<div class="status" id="bingoMessage"></div>
<div class="controls">
<button disabled="" id="bingoNextBtn" type="button">Next question</button>
</div>
</div>
<div class="bottomBar quizBottomBar">
<button disabled="" id="bingoQuitBtn" type="button">Misses</button>
<button id="bingoStartNewBtn" type="button">New game</button>
<button id="bingoRedeemBtn" type="button">Quit</button>
</div>
</div>
</div>
</div>
<div class="side kbPttSideRight" id="bingoAccounts">
<div class="acctMegaPane" id="bingoAcctMegaPane">
<div class="acctMegaScroll">
<div class="pane acctSubPane">
<h3>Parent</h3>
<div class="acctLine">
              KBU balance:
               <input class="moneyInput" id="bingoParentInput" inputmode="decimal" min="0" step="0.01" type="text" value="0.00"/>
</div>
<div class="acctLine">
              Flow rate (KBU per correct answer):
              <input class="flowInput moneyInput" id="bingoFlowRateInput" inputmode="decimal" min="0" step="any" type="text" value="0.00"/>
</div>
</div>
<div class="pane acctSubPane">
<h3>Education Sponsors</h3>
<div class="acctLine">
              KBU balance:
               <input class="moneyInput" id="bingoSponsorInput" inputmode="decimal" min="0" step="any" type="text" value="0.00"/>
</div>
<div class="acctLine">
              Parent-to-Sponsors match ratio (3 ≤ x ≤ 7):
              <input class="flowInput" id="bingoSponsorMatchInput" max="7" min="3" step="any" type="number" value="5"/><span class="matchSuffix">: 1</span>
</div>
</div>
<div aria-hidden="true" class="arrowDivider acctSubPane">
<div class="pane spigotPane" id="bingoSpigotPane">
<div class="spigotInner">
<img alt="" class="spigotImg" src="spigot.png?v=3"/>
<div class="spigotText">
<div class="acctLine">Flow rate (KBU, Parent + Sponsors): <span id="bingoSpigotFlowRateOut">0.00</span></div>
<div class="acctLine kbHourLine">KBU per hour (estimate): <span id="bingoSpigotKbucksPerHourOut">0.00</span></div>
</div>
</div>
</div>
</div>
<div class="pane acctSubPane" id="bingoChildPane">
<h3>Child <span class="pct">(75%)</span><span class="kbInfoIcon" data-tooltip="This balance is global" tabindex="0">ⓘ</span></h3>
<div class="acctLine" id="bingoChildAcct">KBU balance: 0.00</div>
</div>
<div class="pane acctSubPane">
<h3>Content Developer <span class="pct">(12.5%)</span></h3>
<div class="acctLine" id="bingoDevAcct">KBU balance: 0.00</div>
</div>
<div class="pane acctSubPane">
<h3>K-Bucks Platform <span class="pct">(12.5%)</span><span class="kbInfoIcon" data-tooltip="This balance is global" tabindex="0">ⓘ</span></h3>
<div class="acctLine" id="bingoPlatformAcct">KBU balance: 0.00</div>
<div class="acctLine" id="bingoPlatformInfo"></div>
</div>
</div>
</div>
</div>
</div>
<div class="copyrightLine">Copyright © 2025-2026 Vladimir Kravtchenko. All rights reserved. Version <span class="kbBuildVersion">0.2.0</span></div>
</div>
</div>
<div class="overlay" id="overlay">
<div class="modal">
<h2>Game over</h2>
<p id="finalText">Thanks for playing.</p>
<div class="controls">
<button id="restartBtn" type="button">Restart</button>
</div>
</div>
</div>
<script crossorigin="" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
</script>
<script>









    const SCALE = 1000000000  
    const KB_BUILD_VERSION = (window.KB_BUILD_VERSION || "0.1.379")
    try { window.KB_BUILD_VERSION = KB_BUILD_VERSION } catch (e) {}
    // Screen 4, Multiply Two Numbers tables
    // productPairs, all 100 A x B pairs, 1..10 by 1..10
    // productResults, all unique products from those pairs
    const KB_BINGO_TABLES = (() => {
      const productPairs = []
      const productsSet = new Set()
      for (let a = 1; a <= 10; a++) {
        for (let b = 1; b <= 10; b++) {
          const product = a * b
          productPairs.push({ a, b, product })
          productsSet.add(product)
        }
      }
      const productResults = Array.from(productsSet).sort((x, y) => x - y)
      const tables = { productPairs, productResults }
      try { window.KB_BINGO_TABLES = tables } catch (e) {}
      return tables
    })()
// Keep footer version in sync with KB_BUILD_VERSION
    try {
      document.querySelectorAll(".kbBuildVersion").forEach((el) => {
        try { el.textContent = KB_BUILD_VERSION } catch (e) {}
      })
    } catch (e) {}
// Footer debug info (shows fixed target header and footer heights).
function kbReadCssPxVar(varName) {
  try {
    const raw = getComputedStyle(document.documentElement).getPropertyValue(varName) || ""
    const n = parseInt(String(raw).trim().replace("px", ""), 10)
    return Number.isFinite(n) ? n : 0
  } catch (e) {
    return 0
  }
}

// Wallet display formatter:
// - comma separators for integer part
// - at least 2 decimals
// - more decimals only when they contain non-zero digits
// - no rounding
function fmtWalletMin2U(u) {
  const x = Number(u)
  if (!Number.isFinite(x) || x <= 0) return "0.00"

  const intPart = Math.floor(x / SCALE)
  const fracUnits = Math.floor(x % SCALE)

  const intStr = String(intPart).replace(/\B(?=(\d{3})+(?!\d))/g, ",")

  // Build 9 digits of fractional precision.
  let frac = String(fracUnits).padStart(9, "0")
  // Trim trailing zeros, but keep at least 2 digits.
  frac = frac.replace(/0+$/, "")
  if (frac.length < 2) frac = frac.padEnd(2, "0")

  // If everything was zeros, show .00
  if (!frac || /^0+$/.test(frac)) return intStr + ".00"

  return intStr + "." + frac
}
// 1 unit = 0.000000001 K-Bucks

    const ORANGE_STYLE = {
      color: "#d08a00",
      weight: 3,
      fill: true,
      fillColor: "#f2a400",
      fillOpacity: 1.0
    }



    // Show countries slightly smaller than a tight fit. Fractional zoom remains enabled.
    const KB_ZOOM_OUT_AFTER_FIT = 0.25

    function kbZoomOutAfterNextMoveEnd(targetMap, delta) {
      try {
        if (!targetMap || !Number.isFinite(delta) || delta <= 0) return
        targetMap.once("moveend", () => {
          try {
            const z = targetMap.getZoom()
            if (!Number.isFinite(z)) return
            targetMap.setZoom(z - delta, { animate: false })
          } catch (e) {}
        })
      } catch (e) {}
    }
    const UN_MEMBERS_URL = "https://restcountries.com/v3.1/all?fields=name,cca2,cca3,unMember"

    const WORLD_BOUNDS = L.latLngBounds(
  L.latLng(-85.05112878, -180),
  L.latLng(85.05112878, 180)
)


let map = null
let kbBaseTileLayer = null

const kbMapBuffers = {
  front: { id: "mapA", div: null, map: null, tileLayer: null, currentLayer: null },
  back: { id: "mapB", div: null, map: null, tileLayer: null, currentLayer: null }
}

let kbFrontKey = "front"
let kbBackKey = "back"

function kbGetFrontBuffer() { return kbMapBuffers[kbFrontKey] }
function kbGetBackBuffer() { return kbMapBuffers[kbBackKey] }

function kbSetBufferClasses() {
  const f = kbGetFrontBuffer()
  const b = kbGetBackBuffer()
  try {
    if (f && f.div) {
      f.div.classList.add("kbMapFront")
      f.div.classList.remove("kbMapBack")
    }
    if (b && b.div) {
      b.div.classList.add("kbMapBack")
      b.div.classList.remove("kbMapFront")
    }
  } catch (e) {}
}

function kbCreateLeafletMap(containerId) {
  // Allow zooming out far enough to see the full world map even in smaller slots (e.g., 512x512).
  // We compute the "fit-world" zoom for the container and set that as minZoom.
  let kbMinZoom = 2.2
  try {
    const el = document.getElementById(containerId)
    const w = el ? (el.clientWidth || 0) : 0
    const h = el ? (el.clientHeight || 0) : 0
    const size = Math.min(w, h)
    if (size >= 256) {
      const fitZoom = Math.log(size / 256) / Math.log(2)
      // Leaflet uses zoomSnap 0.2, so snap down to the nearest 0.2 to guarantee the world fits.
      kbMinZoom = Math.max(0, Math.min(2.2, Math.floor(fitZoom / 0.2) * 0.2))
    }
  } catch (e) {}

  const m = L.map(containerId, {
    zoomControl: true,
    attributionControl: false,
    minZoom: kbMinZoom,
    maxBounds: WORLD_BOUNDS,
    maxBoundsViscosity: 1.0,
    worldCopyJump: false,
    zoomSnap: 0.2,
    zoomDelta: 0.2,
    preferCanvas: false
  }).setView([20, 0], 2.2)

  try {
    window.kbMapSeq = (window.kbMapSeq || 0) + 1
    m._kbSeq = window.kbMapSeq
  } catch (e) {}

  L.control.attribution({ prefix: "" }).addTo(m)

  const tileLayer = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png", {
    subdomains: "abcd",
    detectRetina: true,
    maxZoom: 19,
    attribution: "© OpenStreetMap contributors © CARTO © Leaflet",
    noWrap: true,
    bounds: WORLD_BOUNDS,
    updateWhenIdle: true,
    keepBuffer: 4,
    // Avoid showing gray "missing tile" blocks if a tile request fails or is throttled.
    errorTileUrl: "data:image/gif;base64,R0lGODlhAQABAAAAACwAAAAAAQABAAA="
  }).addTo(m)

  return { map: m, tileLayer: tileLayer }
}

function kbHealTilesOnBuffer(buf, reason, opts) {
  const o = opts || {}
  const doRedraw = !!o.redraw
  try {
    if (buf && buf.map && buf.map.invalidateSize) {
      try { buf.map.invalidateSize({ animate: false, pan: false }) } catch (e) {
        try { buf.map.invalidateSize() } catch (e2) {}
      }
    }
  } catch (e) {}
  if (doRedraw) {
    try { if (buf && buf.tileLayer && buf.tileLayer.redraw) buf.tileLayer.redraw() } catch (e) {}
  }
  try { if (typeof kbDbg === "function") kbDbg("healTiles", { reason: reason, redraw: doRedraw }) } catch (e) {}
}

function kbHealTiles(reason, opts) {
  // Wrapper for legacy calls. Heal both front and back Leaflet buffers if present.
  try { kbHealTilesOnBuffer(kbGetFrontBuffer(), reason || "heal", opts) } catch (e) {}
  try { kbHealTilesOnBuffer(kbGetBackBuffer(), reason || "heal", opts) } catch (e) {}
}


function kbDestroyLeafletMap(reason) {
  try { if (typeof kbDbg === "function") kbDbg("destroyLeafletMap", { reason: reason }) } catch (e) {}

  const bufs = [kbMapBuffers.front, kbMapBuffers.back]
  for (const buf of bufs) {
    try {
      if (buf && buf.map) {
        try { buf.map.off() } catch (e) {}
        try { buf.map.remove() } catch (e) {}
      }
    } catch (e) {}
    try {
      if (buf && buf.div) {
        try { delete buf.div._leaflet_id } catch (e) {}
      }
    } catch (e) {}
    try {
      if (buf) {
        buf.map = null
        buf.tileLayer = null
        buf.currentLayer = null
      }
    } catch (e) {}
  }

  map = null
  kbBaseTileLayer = null
}

function kbEnsureLeafletMap(reason) {
  if (map) return map

  kbMapBuffers.front.div = document.getElementById(kbMapBuffers.front.id)
  kbMapBuffers.back.div = document.getElementById(kbMapBuffers.back.id)

  const frontPair = kbCreateLeafletMap(kbMapBuffers.front.id)
  kbMapBuffers.front.map = frontPair.map
  kbMapBuffers.front.tileLayer = frontPair.tileLayer

  const backPair = kbCreateLeafletMap(kbMapBuffers.back.id)
  kbMapBuffers.back.map = backPair.map
  kbMapBuffers.back.tileLayer = backPair.tileLayer

  kbFrontKey = "front"
  kbBackKey = "back"
  kbSetBufferClasses()

  map = kbMapBuffers.front.map
  kbBaseTileLayer = kbMapBuffers.front.tileLayer

  // Keep mapDiv pointing to the visible buffer
  try { if (kbMapBuffers.front.div) mapDiv = kbMapBuffers.front.div } catch (e) {}
  try { if (typeof kbDebug !== "undefined" && kbDebug && mapDiv) mapDiv.appendChild(kbDebug) } catch (e) {}

  try { if (typeof kbDbg === "function") kbDbg("ensureLeafletMap", { reason: reason }) } catch (e) {}
  return map
}

function kbSwapMapBuffers(reason) {
  try { if (typeof kbDbg === "function") kbDbg("swapBuffers", { reason: reason }) } catch (e) {}

  const tmp = kbFrontKey
  kbFrontKey = kbBackKey
  kbBackKey = tmp
  kbSetBufferClasses()

  const f = kbGetFrontBuffer()
  if (f) {
    map = f.map
    kbBaseTileLayer = f.tileLayer
    try { if (f.div) mapDiv = f.div } catch (e) {}
    try { if (typeof kbDebug !== "undefined" && kbDebug && mapDiv) mapDiv.appendChild(kbDebug) } catch (e) {}
    try { currentLayer = f.currentLayer } catch (e) {}
    try { kbHealTilesOnBuffer(f, "swap") } catch (e) {}
  }

  const b = kbGetBackBuffer()
  try { kbHealTilesOnBuffer(b, "swap-back") } catch (e) {}
}


let mapDiv = document.getElementById("mapA")
    const redeemPane = document.getElementById("redeemPane")
    const sideEl = document.getElementById("side")
    // Debug overlay and logging (disabled by default)
    const KB_DEBUG = false
    const mapSlotEl = document.getElementById("mapSlot")
    const gameScreenForDebugEl = document.getElementById("screenGame")
    const headerEl = gameScreenForDebugEl ? gameScreenForDebugEl.querySelector(".headerBar") : null
    const footerEl = gameScreenForDebugEl ? gameScreenForDebugEl.querySelector(".copyrightLine") : null

    let kbDebug = null
    if (KB_DEBUG) {
      kbDebug = document.createElement("div")
      kbDebug.id = "kbDebug"
      kbDebug.style.cssText = "position:absolute;top:8px;left:8px;z-index:1000;background:rgba(255,255,255,0.95);border:1px solid #ddd;border-radius:6px;padding:6px 8px;font-size:12px;line-height:1.25;pointer-events:none;white-space:pre;"
      try { mapDiv.style.position = "relative" } catch (e) {}
      try { mapDiv.appendChild(kbDebug) } catch (e) {}
    }

    const kbDbgLines = []
    function kbDbg(msg, obj) {
      if (!KB_DEBUG) return
      const t = (performance.now() / 1000).toFixed(3)
      let line = "[KBDBG " + t + "] " + msg
      if (obj !== undefined) {
        try { line += " " + JSON.stringify(obj) } catch (e) {}
      }
      try { console.log(line) } catch (e) {}
      kbDbgLines.push(line)
      if (kbDbgLines.length > 60) kbDbgLines.shift()
      try { kbScheduleDebugUpdate() } catch (e) {}
    }
    try { window.kbDbg = kbDbg } catch (e) {}


    
    function kbMapState() {
      const rect = mapDiv ? mapDiv.getBoundingClientRect() : { width: 0, height: 0 }
      let size = { x: 0, y: 0 }
      let center = null
      let zoom = null
      try { size = map.getSize() } catch (e) {}
      try { center = map.getCenter() } catch (e) {}
      try { zoom = map.getZoom() } catch (e) {}
      return {
        screen: (typeof currentScreen !== "undefined") ? currentScreen : "unknown",
        mapRect: { w: Math.round(rect.width), h: Math.round(rect.height) },
        mapOffset: { w: mapDiv ? mapDiv.offsetWidth : 0, h: mapDiv ? mapDiv.offsetHeight : 0 },
        leafletSize: { x: size.x, y: size.y },
        center: center ? { lat: +center.lat.toFixed(5), lng: +center.lng.toFixed(5) } : null,
        zoom: zoom
      }
    }

    function kbNormalizeMapView(reason) {
      if (!map || !map.getCenter) return false
      let c = null
      try { c = map.getCenter() } catch (e) {}
      if (!c) return false

      const bad = (Math.abs(c.lat) > 80) || (Math.abs(c.lng) > 180) || (!isFinite(c.lat)) || (!isFinite(c.lng))
      if (!bad) return false

      try { kbDbg("normalizeMapView", { reason: reason, before: kbMapState() }) } catch (e) {}
      try { if (map.stop) map.stop() } catch (e) {}
      try { map.setView([20, 0], 2.2, { animate: false }) } catch (e) {}
      try { if (map.invalidateSize) map.invalidateSize({ animate: false, pan: false }) } catch (e) {}
      try { kbDbg("normalizeMapView done", { reason: reason, after: kbMapState() }) } catch (e) {}
      return true
    }

    function kbAttachMapDebugListeners() {
      if (!map) return
      try {
        map.whenReady(() => kbDbg("map whenReady", kbMapState()))

        map.on("resize", (e) => {
          kbDbg("map resize", {
            old: e && e.oldSize ? { x: e.oldSize.x, y: e.oldSize.y } : null,
            now: kbMapState()
          })
        })

        map.on("moveend", () => {
          if (!currentLayer) return
          let pt = null
          let ll = null
          try {
            const b = currentLayer.getBounds()
            ll = b.getCenter()
            pt = map.latLngToContainerPoint(ll)
          } catch (e) {}
          kbDbg("map moveend", {
            now: kbMapState(),
            layerCenterPx: pt ? { x: Math.round(pt.x), y: Math.round(pt.y) } : null,
            layerCenterLatLng: ll ? { lat: +ll.lat.toFixed(5), lng: +ll.lng.toFixed(5) } : null
          })
        })
      } catch (e) {}
    }

let kbDebugRaf = null
    function kbScheduleDebugUpdate() {
      if (kbDebugRaf) cancelAnimationFrame(kbDebugRaf)
      kbDebugRaf = requestAnimationFrame(kbUpdateDebugOverlay)
    }

    function kbPx(n) {
      return Math.max(0, Math.round(n || 0))
    }

    function kbUpdateDebugOverlay() {
      if (!KB_DEBUG || !kbDebug) return
      try {
        const mapRect = mapDiv.getBoundingClientRect()
        const slotRect = mapSlotEl ? mapSlotEl.getBoundingClientRect() : { width: 0, height: 0 }
        const sideRect = sideEl ? sideEl.getBoundingClientRect() : { height: 0 }
        const headerRect = headerEl ? headerEl.getBoundingClientRect() : { height: 0 }
        const footerRect = footerEl ? footerEl.getBoundingClientRect() : { height: 0 }

        kbDebug.textContent =
          "Map pane: " + kbPx(mapRect.width) + " x " + kbPx(mapRect.height) + " px\n" +
          "Map slot: " + kbPx(slotRect.width) + " x " + kbPx(slotRect.height) + " px\n" +
          "Right span height: " + kbPx(sideRect.height) + " px\n" +
          "Header height: " + kbPx(headerRect.height) + " px\n" +
          "Footer height: " + kbPx(footerRect.height) + " px" +
          "\n\nScreen: " + ((typeof currentScreen !== "undefined") ? currentScreen : "unknown") +
          "\nMap offset: " + (mapDiv ? mapDiv.offsetWidth : 0) + " x " + (mapDiv ? mapDiv.offsetHeight : 0) +
          "\nLeaflet size: " + (function(){ try { const s = map.getSize(); return s.x + " x " + s.y } catch(e){ return "n/a" } })() +
          (kbDbgLines && kbDbgLines.length ? ("\n\nLast logs:\n" + kbDbgLines.slice(-8).join("\n")) : "")
      } catch (e) {
        // ignore
      }
    }

    // Keep this passive, never call map.invalidateSize from debug
    const kbDebugRO = new ResizeObserver(() => kbScheduleDebugUpdate())
    if (mapSlotEl) kbDebugRO.observe(mapSlotEl)
    if (sideEl) kbDebugRO.observe(sideEl)
    if (headerEl) kbDebugRO.observe(headerEl)
    if (footerEl) kbDebugRO.observe(footerEl)
    kbDebugRO.observe(mapDiv)
    window.addEventListener("resize", () => kbScheduleDebugUpdate())
    document.addEventListener("visibilitychange", () => kbScheduleDebugUpdate())
    kbScheduleDebugUpdate()

    const answersEl = document.getElementById("answers")
    const nextBtn = document.getElementById("nextBtn")
    const quitBtn = document.getElementById("quitBtn")
    const statusEl = document.getElementById("status")
    const timerEl = document.getElementById("timer")
    
    const progressEl = document.getElementById("progress")
const messageEl = document.getElementById("message")

    const bingoAnswersEl = document.getElementById("bingoAnswers")
    const bingoNextBtn = document.getElementById("bingoNextBtn")
    const bingoMessageEl = document.getElementById("bingoMessage")
    const bingoProgressEl = document.getElementById("bingoProgress")
    const bingoStatusEl = document.getElementById("bingoStatus")
    const bingoTimerEl = document.getElementById("bingoTimer")
    const bingoQuitBtn = document.getElementById("bingoQuitBtn")
    const bingoStartNewBtn = document.getElementById("bingoStartNewBtn")
    const bingoRedeemBtn = document.getElementById("bingoRedeemBtn")

    const bingoParentInput = document.getElementById("bingoParentInput")
    const bingoSponsorInput = document.getElementById("bingoSponsorInput")
    const bingoSponsorMatchInput = document.getElementById("bingoSponsorMatchInput")
    const bingoFlowRateInput = document.getElementById("bingoFlowRateInput")
    const bingoSpigotFlowRateOut = document.getElementById("bingoSpigotFlowRateOut")
    const bingoSpigotKbucksPerHourOut = document.getElementById("bingoSpigotKbucksPerHourOut")

    const bingoChildAcctEl = document.getElementById("bingoChildAcct")
    const bingoDevAcctEl = document.getElementById("bingoDevAcct")
    const bingoPlatformAcctEl = document.getElementById("bingoPlatformAcct")
    const bingoChildPaneEl = document.getElementById("bingoChildPane")
    const bingoSpigotPaneEl = document.getElementById("bingoSpigotPane")
    const bingoPlatformInfoEl = document.getElementById("bingoPlatformInfo")


    const overlay = document.getElementById("overlay")
    const restartBtn = document.getElementById("restartBtn")

    const parentInput = document.getElementById("parentInput")
    const sponsorInput = document.getElementById("sponsorInput")
    const sponsorMatchInput = document.getElementById("sponsorMatchInput")
    const flowRateInput = document.getElementById("flowRateInput")
    
    const sponsorFlowRateOut = document.getElementById("sponsorFlowRateOut")
    const spigotFlowRateOut = document.getElementById("spigotFlowRateOut")
    const spigotKbucksPerHourOut = document.getElementById("spigotKbucksPerHourOut")

    const childAcctEl = document.getElementById("childAcct")
    const devAcctEl = document.getElementById("devAcct")
    const platformAcctEl = document.getElementById("platformAcct")
    const childPaneEl = document.getElementById("childPane")
    const spigotPaneEl = document.getElementById("spigotPane")

    function syncSpigotPaneSize() {
      if (!childPaneEl || !spigotPaneEl) return
      const r = childPaneEl.getBoundingClientRect()
      const w = Math.round(r.width)
      const h = Math.round(r.height)
      if (!w || !h || w < 120 || h < 40) return
      spigotPaneEl.style.width = w + "px"
      spigotPaneEl.style.height = h + "px"
    }

    window.addEventListener("resize", syncSpigotPaneSize)

    const platformInfoEl = document.getElementById("platformInfo")

    const redeemBtn = document.getElementById("redeemBtn")
    const startNewBtn = document.getElementById("startNewBtn")
    const redeemBalanceEl = document.getElementById("redeemBalance")
    const redeemPaneMessageEl = document.getElementById("redeemPaneMessage")
    const storeEl = document.getElementById("store")
    const closeRedeemBtn = document.getElementById("closeRedeemBtn")

    const earnBalanceEl = document.getElementById("earnBalance")
    const eduPaneMessageEl = document.getElementById("eduPaneMessage")
    const eduListEl = document.getElementById("eduList")
    const openStoreBtn = document.getElementById("openStoreBtn")

    const screenEduEl = document.getElementById("screenEdu")

const screenBingoEl = document.getElementById("screenBingo")

    const screenGameEl = document.getElementById("screenGame")
    const screenStoreEl = document.getElementById("screenStore")
    let currentScreen = "edu"
    function getCssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim()
    }


    function kbRenderListState(containerEl, text) {
      try {
        if (!containerEl) return
        containerEl.innerHTML = ""
        const d = document.createElement("div")
        d.className = "kbListState"
        d.textContent = String(text || "")
        containerEl.appendChild(d)
      } catch (e) {}
    }

    function kbSetUnifiedLoadError(msg) {
      const text = String(msg || "Could not load data. Please refresh.")
      try { if (eduPaneMessageEl) eduPaneMessageEl.textContent = text } catch (e) {}
      try { if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = text } catch (e) {}
      try { if (messageEl) messageEl.textContent = text } catch (e) {}
      try { if (bingoMessageEl) bingoMessageEl.textContent = text } catch (e) {}
    }

    function showGameScreen() {
      try { kbDbg("showGameScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "bingo") {
        if (!bingoTimerStopped && bingoTimerRunning) pauseBingoTimer()
      }
currentScreen = "game"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("name_that_country") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = ""
      if (screenStoreEl) screenStoreEl.style.display = "none"
      if (screenEduEl) screenEduEl.style.display = "none"
      
      if (screenBingoEl) screenBingoEl.style.display = "none"
      
      // Recreate Leaflet map fresh each time we enter the game screen.
      try { kbDestroyLeafletMap("showGameScreen") } catch (e) {}
      try { kbEnsureLeafletMap("showGameScreen") } catch (e) {}

      try { syncMapHeight() } catch (e) {}
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
    }

    function showStoreScreen() {
      try { kbDbg("showStoreScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "bingo") {
        if (!bingoTimerStopped && bingoTimerRunning) pauseBingoTimer()
      }
currentScreen = "store"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("redemption_store") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = "none"
      if (screenStoreEl) screenStoreEl.style.display = ""
      if (screenEduEl) screenEduEl.style.display = "none"
      
      if (screenBingoEl) screenBingoEl.style.display = "none"
      
      try { kbUpdateGlobalBalances() } catch (e) {}
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
    }

    function showEduScreen() {
      try { kbDbg("showEduScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "bingo") {
        if (!bingoTimerStopped && bingoTimerRunning) pauseBingoTimer()
      }
currentScreen = "edu"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("educational_content") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = "none"
      if (screenStoreEl) screenStoreEl.style.display = "none"
      if (screenEduEl) screenEduEl.style.display = ""
      
      if (screenBingoEl) screenBingoEl.style.display = "none"
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
      try { updateAccounts() } catch (e) {}
      try { renderEdu() } catch (e) {}
    }
    
    // Bingo (Screen 4) K-Bucks wallets and flow logic.
    // Keep independent from the Name That Country (Screen 3) wallets.
    let kbBingoParentU = 0 * SCALE
    let kbBingoSponsorU = 0 * SCALE
    let kbBingoDevU = 0
    let kbBingoFlowU = toUnits("0.00")
    let kbBingoSponsorMatch = 5
    let kbBingoDevCarry = 0
    let kbBingoPlatCarry = 0

    function kbBingoSpigotFlowRateU() {
      const parentFlowU = Number(kbBingoFlowU)
      if (!Number.isFinite(parentFlowU) || parentFlowU <= 0) return 0

      let sponsorAddU = 0
      const m = Number(kbBingoSponsorMatch)
      const sponsorWalletU = Number(kbBingoSponsorU)

      if (Number.isFinite(sponsorWalletU) && sponsorWalletU > 0 && Number.isFinite(m) && m > 0) {
        sponsorAddU = Math.trunc(parentFlowU / m)
        if (sponsorAddU > sponsorWalletU) sponsorAddU = sponsorWalletU
        if (sponsorAddU < 0) sponsorAddU = 0
      }
      return parentFlowU + sponsorAddU
    }

    function kbBingoFmtSpigotFlowRate() {
      return fmtWalletMin2U(kbBingoSpigotFlowRateU())
    }

    function kbBingoSpigotKbucksPerHourU() {
      // Estimate: flow per answer * 600 (see Screen 3 formula).
      return Math.trunc(kbBingoSpigotFlowRateU() * 600)
    }

    function kbBingoFmtSpigotKbucksPerHour() {
      return fmtWalletMin2U(kbBingoSpigotKbucksPerHourU())
    }


    function kbBingoSyncSpigotPaneSize() {
      if (!bingoChildPaneEl || !bingoSpigotPaneEl) return
      const r = bingoChildPaneEl.getBoundingClientRect()
      const w = Math.round(r.width)
      const h = Math.round(r.height)
      if (!w || !h || w < 120 || h < 40) return
      bingoSpigotPaneEl.style.width = w + "px"
      bingoSpigotPaneEl.style.height = h + "px"
    }

    window.addEventListener("resize", kbBingoSyncSpigotPaneSize)

    function kbBingoUpdateAccounts() {
      if (kbBingoParentU <= 0) kbBingoFlowU = 0

      if (bingoParentInput && document.activeElement !== bingoParentInput) bingoParentInput.value = fmtParentU(kbBingoParentU)
      if (bingoSponsorInput && document.activeElement !== bingoSponsorInput) bingoSponsorInput.value = fmtSponsorU(kbBingoSponsorU)

      if (bingoFlowRateInput && document.activeElement !== bingoFlowRateInput) bingoFlowRateInput.value = fmtFlowInputU(kbBingoFlowU)
      if (bingoSponsorMatchInput && document.activeElement !== bingoSponsorMatchInput) bingoSponsorMatchInput.value = String(kbBingoSponsorMatch)

      if (bingoSpigotFlowRateOut) bingoSpigotFlowRateOut.textContent = kbBingoFmtSpigotFlowRate()
      if (bingoSpigotKbucksPerHourOut) bingoSpigotKbucksPerHourOut.textContent = kbBingoFmtSpigotKbucksPerHour()
      if (bingoChildAcctEl) bingoChildAcctEl.textContent = "KBU balance: " + fmtWalletMin2U(kbGlobalChildU)
      if (bingoDevAcctEl) bingoDevAcctEl.textContent = "KBU balance: " + fmtOtherU(kbBingoDevU)
      if (bingoPlatformAcctEl) bingoPlatformAcctEl.textContent = "KBU balance: " + fmtWalletMin2U(kbGlobalPlatformU)

      kbBingoSyncSpigotPaneSize()
      kbUpdateGlobalBalances()
    }

    function kbBingoClampFlowRate() {
      if (!bingoFlowRateInput) return
      const raw = String(bingoFlowRateInput.value || "")
      let vU = parseUnitsNoRound(raw)
      if (vU < 0) vU = 0
      if (kbBingoParentU <= 0) vU = 0
      kbBingoFlowU = vU
      bingoFlowRateInput.value = fmtFlowInputU(kbBingoFlowU)
      kbBingoUpdateAccounts()
    }

    function kbBingoClampParentInput() {
      if (!bingoParentInput) return
      const raw = String(bingoParentInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      kbBingoParentU = vU
      if (kbBingoParentU <= 0) kbBingoFlowU = 0
      if (bingoFlowRateInput) bingoFlowRateInput.value = fmtFlowInputU(kbBingoFlowU)
      kbBingoUpdateAccounts()
      if (bingoParentInput) bingoParentInput.value = fmtParentU(kbBingoParentU)
    }

    function kbBingoClampSponsorInput() {
      if (!bingoSponsorInput) return
      const raw = String(bingoSponsorInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      kbBingoSponsorU = vU
      kbBingoUpdateAccounts()
      if (bingoSponsorInput && document.activeElement !== bingoSponsorInput) bingoSponsorInput.value = fmtSponsorU(kbBingoSponsorU)
    }

    function kbBingoClampSponsorMatch() {
      if (!bingoSponsorMatchInput) return
      const raw = String(bingoSponsorMatchInput.value || "").trim()
      let v = Number(raw)

      if (!Number.isFinite(v) || v < 3 || v > 7) {
        bingoSponsorMatchInput.value = String(kbBingoSponsorMatch)
        return
      }
      kbBingoSponsorMatch = v
      if (document.activeElement !== bingoSponsorMatchInput) bingoSponsorMatchInput.value = String(kbBingoSponsorMatch)
      kbBingoUpdateAccounts()
    }


    let kbBingoPairsUpgradedToButtons = false
    function kbUpgradeBingoPairsToButtons() {
      if (kbBingoPairsUpgradedToButtons) return
      kbBingoPairsUpgradedToButtons = true
      const lines = document.querySelectorAll('#screenBingo .bingoLine')
      lines.forEach((line) => {
        const btn = document.createElement('button')
        btn.type = 'button'
        btn.className = 'bingoPairBtn'
        // Preserve existing A × B spans and layout
        while (line.firstChild) btn.appendChild(line.firstChild)
        line.replaceWith(btn)
      })
    }

    
    // --- Bingo quiz logic (Screen 4) ---
    const kbBingoUniqueResults = (() => {
      const s = new Set()
      for (let a = 1; a <= 10; a += 1) {
        for (let b = 1; b <= 10; b += 1) s.add(a * b)
      }
      return Array.from(s).sort((x, y) => x - y)
    })()

    let kbBingoPairs = []
    let kbBingoPairByKey = new Map()

    // Normal mode state
    let kbBingoAnsweredKeys = new Set()
    let kbBingoMisses = new Set()

    // Practice misses mode
    let kbBingoMode = "normal" // "normal" or "practice"
    let kbBingoPracticeTotal = 0

    let kbBingoPracticeDeck = []
    let kbBingoPracticeIndex = 0
    let kbBingoPracticeShown = 0

    // Shared state
    let kbBingoCurrentPair = null
    let kbBingoLocked = false
    let kbBingoComplete = false
    let kbBingoRounds = 0
    let kbBingoCorrectCount = 0
    let kbBingoCurrentAnswerKey = null

    function kbShuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1))
        const tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
      }
      return arr
    }

    function kbBingoUpdateHeader(finalMode) {
      const total = kbBingoPairs.length || 100

      if (kbBingoMode === "practice") {
        if (bingoProgressEl) {
          const presented = kbBingoPracticeTotal > 0 ? Math.min(kbBingoPracticeShown, kbBingoPracticeTotal) : 0
          bingoProgressEl.textContent = "Misses: " + presented + "/" + kbBingoPracticeTotal
        }
        if (bingoStatusEl) bingoStatusEl.textContent = ""
        if (bingoTimerEl) bingoTimerEl.textContent = ""
      } else {
        const answered = kbBingoAnsweredKeys.size
        const correct = kbBingoCorrectCount

        if (bingoProgressEl) {
          bingoProgressEl.textContent = "Progress: " + answered + "/" + total + formatScorePct(answered, total)
        }
        if (bingoStatusEl) {
          const prefix = finalMode ? "Final score: " : "Score: "
          bingoStatusEl.textContent = prefix + correct + "/" + answered + (answered <= 0 ? " (0%)" : formatScorePct(correct, answered))
        }
      }

      if (bingoQuitBtn) bingoQuitBtn.disabled = kbBingoMisses.size === 0
    }


    function kbBingoEnsurePttHeaderMeta() {
      const grid = document.getElementById("bingoGrid")
      if (!grid) return
      const kids = Array.from(grid.children || [])
      if (kids.length < 121) return
    
      for (let r = 0; r < 11; r += 1) {
        for (let c = 0; c < 11; c += 1) {
          const el = kids[r * 11 + c]
          if (!el) continue
    
          if (r === 0 && c === 0) {
            try { if (!el.textContent || !el.textContent.trim()) el.textContent = "×" } catch (e) {}
            continue
          }
    
          if (r === 0 && el.classList && el.classList.contains("pttHdr")) {
            try { el.dataset.col = String(c) } catch (e) {}
          }
    
          if (c === 0 && el.classList && el.classList.contains("pttHdr")) {
            try { el.dataset.row = String(r) } catch (e) {}
          }
        }
      }
    }
    
    function kbBingoClearHeaderHighlights() {
      const els = document.querySelectorAll("#screenBingo .pttHdr.kbBingoHdrCurrent, #screenBingo .pttCorner.kbBingoHdrCurrent")
      for (const el of els) {
        try { el.classList.remove("kbBingoHdrCurrent") } catch (e) {}
      }
    }
    
    function kbBingoSetHeaderHighlights(pair) {
      kbBingoClearHeaderHighlights()
      if (!pair) return
      const a = Number(pair.a)
      const b = Number(pair.b)
      if (!a || !b) return
    
      const rowHdr = document.querySelector(`#screenBingo .pttHdr[data-row="${a}"]`)
      const colHdr = document.querySelector(`#screenBingo .pttHdr[data-col="${b}"]`)
      try { if (rowHdr) rowHdr.classList.add("kbBingoHdrCurrent") } catch (e) {}
      try { if (colHdr) colHdr.classList.add("kbBingoHdrCurrent") } catch (e) {}
    }
    

    // PTT pair button text: blank, question (A x B), or result (number)
    function kbBingoEnsurePairResultSpan(btn) {
      if (!btn) return null
      let r = null
      try { r = btn.querySelector('.bingoResult') } catch (e) { r = null }
      if (!r) {
        r = document.createElement('span')
        r.className = 'bingoResult'
        r.textContent = ''
        try { btn.appendChild(r) } catch (e) {}
      }
      return r
    }

    function kbBingoSetPairDisplay(btn, mode, resultText) {
      if (!btn) return
      const r = kbBingoEnsurePairResultSpan(btn)
      if (mode === 'blank') {
        btn.classList.add('kbBingoBlank')
        btn.classList.remove('kbBingoShowResult')
        if (r) r.textContent = ''
        try { btn.dataset.kbResult = '' } catch (e) {}
        return
      }
      if (mode === 'result') {
        btn.classList.remove('kbBingoBlank')
        btn.classList.add('kbBingoShowResult')
        const t = String(resultText == null ? '' : resultText)
        if (r) r.textContent = t
        try { btn.dataset.kbResult = t } catch (e) {}
        return
      }
      // question (A x B)
      btn.classList.remove('kbBingoBlank')
      btn.classList.remove('kbBingoShowResult')
      if (r) r.textContent = ''
      try { btn.dataset.kbResult = '' } catch (e) {}
    }

    function kbBingoBlankAllPairs() {
      for (const p of kbBingoPairs) {
        try { kbBingoSetPairDisplay(p.btn, 'blank') } catch (e) {}
      }
    }

function kbBingoEnsurePairs() {
      kbBingoEnsurePttHeaderMeta()
      const btns = Array.from(document.querySelectorAll('#screenBingo .bingoPairBtn'))
      kbBingoPairs = []
      kbBingoPairByKey = new Map()
      for (const btn of btns) {
        // Ensure the result span exists, even if the inner label is later hidden.
        try { kbBingoEnsurePairResultSpan(btn) } catch (e) {}

        const aEl = btn.querySelector('.bingoA')
        const bEl = btn.querySelector('.bingoB')

        let a = aEl ? parseInt(String(aEl.textContent || '').trim(), 10) : NaN
        let b = bEl ? parseInt(String(bEl.textContent || '').trim(), 10) : NaN

        // If the label spans were removed or altered, fall back to persisted dataset values.
        if (!Number.isFinite(a) || !Number.isFinite(b)) {
          a = parseInt(String(btn.dataset.a || ''), 10)
          b = parseInt(String(btn.dataset.b || ''), 10)
        }

        if (!Number.isFinite(a) || !Number.isFinite(b)) continue
        const key = String(a) + 'x' + String(b)
        btn.dataset.a = String(a)
        btn.dataset.b = String(b)
        btn.dataset.key = key
        const pair = { key, a, b, btn }
        kbBingoPairs.push(pair)
        kbBingoPairByKey.set(key, pair)
      }
    }

function kbBingoClearHighlights() {
      for (const p of kbBingoPairs) {
        p.btn.classList.remove("kbBingoDoneCorrect")
        p.btn.classList.remove("kbBingoDoneWrong")
        p.btn.classList.remove("kbBingoCurrent")
      }
    }

    function kbBingoResetUIForNewQuestion() {
      if (bingoAnswersEl) bingoAnswersEl.innerHTML = ""
      if (bingoMessageEl) bingoMessageEl.textContent = ""
      if (bingoNextBtn) {
        bingoNextBtn.textContent = "Next question"
        bingoNextBtn.disabled = true
      }
      kbBingoLocked = false
    }

    function kbBingoRenderAnswers(options) {
      if (!bingoAnswersEl) return
      bingoAnswersEl.innerHTML = ""

      for (const opt of options) {
        const li = document.createElement("li")
        const btn = document.createElement("button")
        btn.className = "ansBtn"
        btn.type = "button"

        const bullet = document.createElement("span")
        bullet.className = "bullet"
        bullet.textContent = "•"

        const label = document.createElement("span")
        label.className = "label"
        label.textContent = opt.displayName

        const mark = document.createElement("span")
        mark.className = "mark"
        mark.textContent = ""

        btn.appendChild(bullet)
        btn.appendChild(label)
        btn.appendChild(mark)

        btn.addEventListener("click", () => kbBingoOnGuess(opt.key, btn))

        li.appendChild(btn)
        bingoAnswersEl.appendChild(li)
      }
    }

    function kbBingoLockAnswers() {
      const btns = Array.from((bingoAnswersEl || document).querySelectorAll(".ansBtn"))
      for (const b of btns) b.disabled = true
      return btns
    }

    function kbBingoBuildOptions(correctValue) {
      const correctKey = String(correctValue)
      const pool = kbBingoUniqueResults.map(v => String(v)).filter(v => v !== correctKey)
      kbShuffleInPlace(pool)
      const picked = pool.slice(0, 9)
      const allKeys = [correctKey, ...picked]
      kbShuffleInPlace(allKeys)
      return allKeys.map(k => ({ key: k, displayName: k }))
    }

    function kbBingoSetCurrentPair(pair) {
      for (const p of kbBingoPairs) {
        try { p.btn.classList.remove('kbBingoCurrent') } catch (e) {}
      }

      kbBingoCurrentPair = pair
      if (pair && pair.btn) {
        try { pair.btn.classList.add('kbBingoCurrent') } catch (e) {}
      }

      // For the current question, highlight row and column headers and the current A x B pair button.
      kbBingoSetHeaderHighlights(pair)

      // Display rules:
      // - unanswered non-current pairs: blank
      // - current pair: show A x B
      // - answered pairs: show the correct result number (red or green)
      for (const p of kbBingoPairs) {
        const btn = p.btn
        if (!btn) continue

        const done = btn.classList.contains('kbBingoDoneCorrect') || btn.classList.contains('kbBingoDoneWrong')
        if (done) {
          const t = String(btn.dataset.kbResult || (Number(p.a) * Number(p.b)))
          kbBingoSetPairDisplay(btn, 'result', t)
          continue
        }

        if (pair && p.key === pair.key) {
          kbBingoSetPairDisplay(btn, 'question')
        } else {
          kbBingoSetPairDisplay(btn, 'blank')
        }
      }
    }

function kbBingoPresentRandomPair() {
      kbBingoEnsurePairs()
      if (kbBingoPairs.length === 0) return

      if (kbBingoMode === "practice") {
        if (!kbBingoPracticeDeck || kbBingoPracticeDeck.length === 0) {
          if (bingoMessageEl) bingoMessageEl.textContent = "No misses yet. Press \"New game\" first."
          if (bingoNextBtn) {
            bingoNextBtn.textContent = "Next question"
            bingoNextBtn.disabled = true
          }
          kbBingoUpdateHeader(false)
          return
        }

        // Infinite loop. After showing all misses, start again at 0/FFF.
        if (kbBingoPracticeIndex >= kbBingoPracticeDeck.length) {
          kbBingoPracticeIndex = 0
          kbBingoPracticeShown = 0
          kbBingoRounds = 0
          kbBingoCorrectCount = 0
          kbShuffleInPlace(kbBingoPracticeDeck)
          kbBingoUpdateHeader(false)

          // On a new misses cycle, clear the entire board like a New game.
          kbBingoClearHighlights()
          kbBingoClearHeaderHighlights()
          kbBingoBlankAllPairs()
          kbBingoCurrentPair = null
        }

        const key = kbBingoPracticeDeck[kbBingoPracticeIndex]
        const pick = kbBingoPairByKey.get(key)
        if (!pick) {
          // Defensive. Drop unknown keys and continue.
          kbBingoPracticeDeck = kbBingoPracticeDeck.filter(k => k !== key)
          kbBingoPracticeTotal = kbBingoPracticeDeck.length
          kbBingoPracticeIndex = Math.min(kbBingoPracticeIndex, kbBingoPracticeDeck.length)
          kbBingoUpdateHeader(false)
          return kbBingoPresentRandomPair()
        }

        kbBingoSetCurrentPair(pick)

        // Count the miss as soon as it is presented (highlighted in orange).
        kbBingoPracticeShown += 1
        kbBingoPracticeIndex += 1
        kbBingoUpdateHeader(false)

        const correctValue = pick.a * pick.b
        const options = kbBingoBuildOptions(correctValue)
        kbBingoCurrentAnswerKey = String(correctValue)

        kbBingoResetUIForNewQuestion()
        kbBingoRenderAnswers(options)
        return
      }

      // Normal mode
      const candidates = kbBingoPairs.filter(p => !kbBingoAnsweredKeys.has(p.key))
      if (candidates.length === 0) {
        kbBingoComplete = true
        if (bingoNextBtn) {
          bingoNextBtn.textContent = "Game over"
          bingoNextBtn.disabled = true
        }
        stopBingoTimer()
        kbBingoUpdateHeader(true)
        return
      }

      const pick = candidates[Math.floor(Math.random() * candidates.length)]
      kbBingoSetCurrentPair(pick)

      const correctValue = pick.a * pick.b
      const options = kbBingoBuildOptions(correctValue)
      kbBingoCurrentAnswerKey = String(correctValue)

      kbBingoResetUIForNewQuestion()
      kbBingoRenderAnswers(options)
    }

    function kbBingoOnGuess(chosenKey, chosenBtn) {
      if (kbBingoLocked) return
      kbBingoLocked = true

      const correctKey = kbBingoCurrentAnswerKey
      const allButtons = kbBingoLockAnswers()
      const isCorrect = String(chosenKey) === String(correctKey)
      const isPractice = kbBingoMode === "practice"

      let kbTelemetryTotalPayU = 0
      let kbTelemetryParentPayU = 0
      let kbTelemetrySponsorPayU = 0

      if (isPractice) {
        kbBingoRounds += 1
        if (isCorrect) kbBingoCorrectCount += 1
      } else {
        if (kbBingoCurrentPair) {
          kbBingoAnsweredKeys.add(kbBingoCurrentPair.key)
          if (!isCorrect) kbBingoMisses.add(kbBingoCurrentPair.key)
        }
        kbBingoRounds = kbBingoAnsweredKeys.size
        if (isCorrect) kbBingoCorrectCount += 1
      }

      kbBingoUpdateHeader(false)

      // K-Bucks flow (normal mode only). No flow for incorrect answers.
      if (!isPractice && isCorrect) {
        const parentFlowU = Number(kbBingoFlowU)
        const parentWalletU = Number(kbBingoParentU)

        let parentPayU = 0
        if (Number.isFinite(parentFlowU) && parentFlowU > 0 && Number.isFinite(parentWalletU) && parentWalletU > 0) {
          parentPayU = Math.min(parentFlowU, parentWalletU)
        }

        let sponsorPayU = 0
        const m = Number(kbBingoSponsorMatch)
        const sponsorWalletU = Number(kbBingoSponsorU)
        if (parentFlowU > 0 && Number.isFinite(m) && m > 0 && Number.isFinite(sponsorWalletU) && sponsorWalletU > 0) {
          const sponsorFlowU = Math.floor(Number(parentFlowU) / m)
          if (sponsorFlowU > 0) sponsorPayU = Math.min(sponsorFlowU, sponsorWalletU)
        }

        const totalPayU = parentPayU + sponsorPayU

        kbTelemetryParentPayU = parentPayU
        kbTelemetrySponsorPayU = sponsorPayU
        kbTelemetryTotalPayU = totalPayU

        if (totalPayU > 0) {
          // Split: 75% child, 12.5% content developer, 12.5% platform.
          // Use carry remainders (denominator 8) to avoid systematic rounding bias.
          const devNumer = totalPayU + kbBingoDevCarry
          const platNumer = totalPayU + kbBingoPlatCarry
          const devAdd = Math.floor(devNumer / 8)
          const platAdd = Math.floor(platNumer / 8)
          kbBingoDevCarry = devNumer % 8
          kbBingoPlatCarry = platNumer % 8

          const childAdd = totalPayU - devAdd - platAdd

          kbBingoParentU -= parentPayU
          kbBingoSponsorU -= sponsorPayU
          kbGlobalChildU += childAdd
          kbBingoDevU += devAdd
          kbGlobalPlatformU += platAdd

          if (kbBingoParentU <= 0) kbBingoFlowU = 0
          try { kbBingoUpdateAccounts() } catch (e) {}
        }
      }

      try {
        if (window.KB_TELEMETRY) {
          const toKbu = (u) => {
            const n = Number(u) || 0
            return n > 0 ? (n / SCALE) : 0
          }
          window.KB_TELEMETRY.event("kb_answer", {
            kb_game: "practice_times_tables",
            kb_mode: kbBingoMode,
            kb_correct: isCorrect ? 1 : 0,
            kb_round: kbBingoRounds,
            kb_total_pay_kbu: toKbu(kbTelemetryTotalPayU),
            kb_parent_pay_kbu: toKbu(kbTelemetryParentPayU),
            kb_sponsor_pay_kbu: toKbu(kbTelemetrySponsorPayU)
          })
        }
      } catch (e) {}

      if (isCorrect) {
        chosenBtn.classList.add("correct")
        const m = chosenBtn.querySelector(".mark")
        if (m) m.textContent = "✓"
      } else {
        chosenBtn.classList.add("wrong")
        const m = chosenBtn.querySelector(".mark")
        if (m) m.textContent = "✕"

        const correctBtn = allButtons.find(b => {
          const label = b.querySelector(".label")
          return label && String(label.textContent) === String(correctKey)
        })
        if (correctBtn) {
          correctBtn.classList.add("correct")
          const m2 = correctBtn.querySelector(".mark")
          if (m2) m2.textContent = "✓"
        }
      }

      // Mark the answered A x B pair in the board in both modes.
      try {
        if (kbBingoCurrentPair && kbBingoCurrentPair.btn) {
          const pairBtn = kbBingoCurrentPair.btn
          pairBtn.classList.remove("kbBingoCurrent")
          pairBtn.classList.remove("kbBingoDoneCorrect")
          pairBtn.classList.remove("kbBingoDoneWrong")
          pairBtn.classList.add(isCorrect ? "kbBingoDoneCorrect" : "kbBingoDoneWrong")
          // Replace "A × B" with the correct result number.
          try { kbBingoSetPairDisplay(pairBtn, "result", String(correctKey)) } catch (e) {}
        }
      } catch (e) {}

      // End conditions and Next button behavior differ by mode.
      if (!isPractice) {
        const done = kbBingoAnsweredKeys.size >= kbBingoPairs.length
        if (done) {
          kbBingoComplete = true
          if (bingoNextBtn) {
            bingoNextBtn.textContent = "Game over"
            bingoNextBtn.disabled = true
          }
          stopBingoTimer()
          kbBingoUpdateHeader(true)
        } else {
          if (bingoNextBtn) bingoNextBtn.disabled = false
        }
        return
      }

      // Practice misses mode. Always allow continuing. Wrap happens in kbBingoPresentRandomPair.
      if (bingoNextBtn) bingoNextBtn.disabled = false
    }

    function kbBingoStartNewGame() {
      try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_game_start", { kb_game: "practice_times_tables" }) } catch (e) {}

      kbBingoEnsurePairs()
      kbBingoAnsweredKeys = new Set()
      kbBingoMisses = new Set()
      kbBingoMode = "normal"
      kbBingoPracticeTotal = 0

      kbBingoCurrentPair = null
      kbBingoLocked = false
      kbBingoComplete = false
      kbBingoRounds = 0
      kbBingoCorrectCount = 0
      kbBingoCurrentAnswerKey = null

      kbBingoClearHighlights()
      kbBingoClearHeaderHighlights()
      kbBingoBlankAllPairs()
      try { kbBingoUpdateAccounts() } catch (e) {}

      if (bingoNextBtn) {
        bingoNextBtn.textContent = "Next question"
        bingoNextBtn.disabled = true
      }
      if (bingoMessageEl) bingoMessageEl.textContent = ""
      kbBingoUpdateHeader(false)
      resetAndStartBingoTimer()

      kbBingoPresentRandomPair()
    }

    function kbBingoStartPracticeMisses() {
      if (!kbBingoMisses || kbBingoMisses.size === 0) {
        if (bingoMessageEl) bingoMessageEl.textContent = "No misses yet. Press \"New game\" first."
        if (bingoQuitBtn) bingoQuitBtn.disabled = true
        return
      }

      kbBingoEnsurePairs()
      kbBingoMode = "practice"
      kbBingoComplete = false

      kbBingoPracticeDeck = Array.from(kbBingoMisses)
      kbShuffleInPlace(kbBingoPracticeDeck)
      kbBingoPracticeIndex = 0
      kbBingoPracticeShown = 0
      kbBingoPracticeTotal = kbBingoPracticeDeck.length

      kbBingoRounds = 0
      kbBingoCorrectCount = 0
      kbBingoCurrentAnswerKey = null

      // Clear any red or green markings. In practice mode we only use the yellow current highlight.
      kbBingoClearHighlights()
      kbBingoClearHeaderHighlights()
      kbBingoBlankAllPairs()

      if (bingoNextBtn) {
        bingoNextBtn.textContent = "Next question"
        bingoNextBtn.disabled = true
      }
      if (bingoMessageEl) bingoMessageEl.textContent = ""
      resetAndStartBingoTimer()

      kbBingoPresentRandomPair()
    }

    function quitBingoToEdu() {
      try { kbDbg("quitBingoToEdu", kbMapState()) } catch (e) {}
      if (bingoTimerRunning) pauseBingoTimer()
      showEduScreen()
    }

    if (bingoNextBtn) {
      bingoNextBtn.addEventListener("click", () => {
        try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_next_question_press", { kb_game: "practice_times_tables", kb_mode: kbBingoMode }) } catch (e) {}
        if (kbBingoComplete) return
        kbBingoPresentRandomPair()
      })
    }
    if (bingoQuitBtn) bingoQuitBtn.addEventListener("click", kbBingoStartPracticeMisses)
    if (bingoStartNewBtn) bingoStartNewBtn.addEventListener("click", kbBingoStartNewGame)
    if (bingoRedeemBtn) bingoRedeemBtn.addEventListener("click", quitBingoToEdu)

function showBingoScreen() {
      try { kbDbg("showBingoScreen", kbMapState()) } catch (e) {}

      
      if (currentScreen === "game") {
        if (timerRunning) pauseTimer()
      }
currentScreen = "bingo"
      try { if (window.KB_TELEMETRY) KB_TELEMETRY.screen("practice_times_tables") } catch (e) {}
      if (screenGameEl) screenGameEl.style.display = "none"
      if (screenStoreEl) screenStoreEl.style.display = "none"
      if (screenEduEl) screenEduEl.style.display = "none"
      if (screenBingoEl) screenBingoEl.style.display = ""
      try { updateFooterDebugAll() } catch (e) {}
      try { kbScheduleDebugUpdate() } catch (e) {}
      try { updateAccounts() } catch (e) {}
      try { kbBingoUpdateAccounts() } catch (e) {}
      try { kbUpgradeBingoPairsToButtons() } catch (e) {}
      try { kbBingoStartNewGame() } catch (e) {}
    }




    let countries = []
    let deck = []
    let deckIndex = 0
    let gameComplete = false

    let current = null
    let currentLayer = null
    let pendingBounds = null
    let locked = false
    let rounds = 0
    let correctCount = 0

    // Game mode: "normal" or "practice" (practice misses).
    let mode = "normal"

    // List of unique missed countries (keys) recorded during the current normal game.
    let misses = []
    let missesSet = new Set()

    // Fast lookup for country objects by key.
    let countryByKey = new Map()

    // Timer state (normal game only).
    let timerInterval = null
    let timerStartMs = 0
    let timerElapsedMs = 0
    let timerRunning = false
    let timerStopped = false

    function pad2(n) {
      return String(n).padStart(2, "0")
    }

    function formatTimeHMS(ms) {
      const totalSeconds = Math.max(0, Math.floor(ms / 1000))
      const hours = Math.floor(totalSeconds / 3600)
      const minutes = Math.floor((totalSeconds % 3600) / 60)
      const seconds = totalSeconds % 60
      const hh = String(hours).padStart(2, "0")
      return hh + ":" + pad2(minutes) + ":" + pad2(seconds)
    }

    function setTimerVisible(visible) {
      if (!timerEl) return
      timerEl.style.display = visible ? "" : "none"
    }

    function renderTimer() {
      if (!timerEl) return
      const ms = timerElapsedMs + (timerRunning ? (Date.now() - timerStartMs) : 0)
      timerEl.textContent = "Time: " + formatTimeHMS(ms)
    }

    function startTimer() {
      if (timerStopped) return
      if (mode !== "normal") return
      if (timerRunning) return
      timerRunning = true
      timerStartMs = Date.now()
      if (timerInterval) clearInterval(timerInterval)
      timerInterval = setInterval(renderTimer, 1000)
      renderTimer()
    }

    function pauseTimer() {
      if (!timerRunning) {
        renderTimer()
        return
      }
      timerElapsedMs += Date.now() - timerStartMs
      timerRunning = false
      timerStartMs = 0
      if (timerInterval) clearInterval(timerInterval)
      timerInterval = null
      renderTimer()
    }

    function stopTimer() {
      pauseTimer()
      timerStopped = true
    }

    function resetAndStartTimer() {
      timerElapsedMs = 0
      timerStopped = false
      timerRunning = false
      timerStartMs = 0
      if (timerInterval) clearInterval(timerInterval)
      timerInterval = null
      renderTimer()
      startTimer()
    }
    // Bingo timer (Screen 4)
    let bingoTimerInterval = null
    let bingoTimerStartMs = 0
    let bingoTimerElapsedMs = 0
    let bingoTimerRunning = false
    let bingoTimerStopped = false

    function renderBingoTimer() {
      if (!bingoTimerEl) return
      if (kbBingoMode === "practice") {
        bingoTimerEl.textContent = ""
        return
      }
      const now = Date.now()
      const ms = bingoTimerElapsedMs + (bingoTimerRunning ? (now - bingoTimerStartMs) : 0)
      bingoTimerEl.textContent = "Time: " + formatTimeHMS(ms)
    }

    function startBingoTimer() {
      if (bingoTimerStopped) return
      if (currentScreen !== "bingo") return
      if (bingoTimerRunning) return
      bingoTimerRunning = true
      bingoTimerStartMs = Date.now()
      if (bingoTimerInterval) clearInterval(bingoTimerInterval)
      bingoTimerInterval = setInterval(renderBingoTimer, 1000)
      renderBingoTimer()
    }

    function pauseBingoTimer() {
      if (!bingoTimerRunning) {
        renderBingoTimer()
        return
      }
      const now = Date.now()
      bingoTimerElapsedMs += (now - bingoTimerStartMs)
      bingoTimerRunning = false
      bingoTimerStartMs = 0
      if (bingoTimerInterval) clearInterval(bingoTimerInterval)
      bingoTimerInterval = null
      renderBingoTimer()
    }

    function stopBingoTimer() {
      pauseBingoTimer()
      bingoTimerStopped = true
    }

    function resetAndStartBingoTimer() {
      bingoTimerElapsedMs = 0
      bingoTimerStopped = false
      bingoTimerRunning = false
      bingoTimerStartMs = 0
      if (bingoTimerInterval) clearInterval(bingoTimerInterval)
      bingoTimerInterval = null
      renderBingoTimer()
      startBingoTimer()
    }

    // Pause timers when the tab or window is not active.
    let timerPausedByTab = false
    let bingoTimerPausedByTab = false

    function isRedeemOpen() {
      return currentScreen === "store"
    }

    function handleTabInactive() {
      if (currentScreen === "bingo") {
        if (bingoTimerPausedByTab) return
        if (bingoTimerStopped || kbBingoComplete) return
        bingoTimerPausedByTab = true
        if (bingoTimerRunning) pauseBingoTimer()
        return
      }

      if (timerPausedByTab) return
      if (mode !== "normal") return
      if (timerStopped || gameComplete) return
      timerPausedByTab = true
      if (timerRunning) pauseTimer()
    }

    function handleTabActive() {
      if (currentScreen === "bingo") {
        if (!bingoTimerPausedByTab) return
        bingoTimerPausedByTab = false
        if (bingoTimerStopped || kbBingoComplete) return
        startBingoTimer()
        return
      }

      if (!timerPausedByTab) return
      timerPausedByTab = false
      if (mode !== "normal") return
      if (timerStopped || gameComplete) return
      if (isRedeemOpen()) return
      startTimer()
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) handleTabInactive()
      else handleTabActive()
    })

    window.addEventListener("blur", () => {
      if (document.hidden) return
      handleTabInactive()
    })

    window.addEventListener("focus", () => {
      if (document.hidden) return
      handleTabActive()
    })


    //

    // K-Bucks demo wallet (units = 0.0001 K-Bucks)
    let parentU = 0 * SCALE
    let sponsorU = 0 * SCALE
    let kbGlobalChildU = 0
    let devU = 0
    let kbGlobalPlatformU = 0
    let flowU = toUnits("0.00")  // 0.00
    let flowDec = 2
    let sponsorMatch = 5
    let devCarry = 0
    let platCarry = 0
    function pick(obj, keys) {
      for (const k of keys) {
        if (obj && obj[k] != null && String(obj[k]).trim() !== "") return obj[k]
      }
      return null
    }

    function normNameKey(s) {
      return String(s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase()
        .replace(/&/g, "and")
        .replace(/[^a-z0-9 ]+/g, " ")
        .replace(/\s+/g, " ")
        .trim()
    }

    const NAME_ALIAS_TO_CANON = new Map([
      ["united states of america", "united states"],
      ["russian federation", "russia"],
      ["iran islamic republic of", "iran"],
      ["venezuela bolivarian republic of", "venezuela"],
      ["bolivia plurinational state of", "bolivia"],
      ["tanzania united republic of", "tanzania"],
      ["lao people s democratic republic", "laos"],
      ["viet nam", "vietnam"],
      ["syrian arab republic", "syria"],
      ["moldova republic of", "moldova"],
      ["korea republic of", "south korea"],
      ["korea democratic people s republic of", "north korea"],
      ["czech republic", "czechia"],
      ["cote d ivoire", "cote divoire"],
      ["congo", "republic of the congo"],
      ["congo democratic republic of the", "democratic republic of the congo"],
      ["myanmar burma", "myanmar"],
      ["brunei darussalam", "brunei"],
      ["timor leste", "east timor"],
      ["macedonia", "north macedonia"],
      ["swaziland", "eswatini"],
      ["cape verde", "cabo verde"],
      ["the bahamas", "bahamas"],
      ["turkiye", "turkey"],
      ["türkiye", "turkey"]
])

    function canon(name) {
      const n = normNameKey(name)
      return NAME_ALIAS_TO_CANON.get(n) || n
    }

    function getISO2(props) {
      return pick(props, ["ISO3166-1-Alpha-2", "ISO_A2", "iso_a2", "iso2", "ISO2", "alpha2", "alpha-2", "cca2", "id"])
    }

    function getISO3(props) {
      return pick(props, ["ISO3166-1-Alpha-3", "ISO_A3", "iso_a3", "ADM0_A3", "adm0_a3", "iso3", "ISO3", "alpha3", "alpha-3", "cca3"])
    }

    function geoName(props) {
      if (!props) return null
      return pick(props, [
        "ADMIN", "admin",
        "NAME", "name",
        "NAME_EN", "name_en",
        "SOVEREIGNT", "sovereignt",
        "COUNTRY", "country",
        "Country"
      ])
    }

    function shuffle(arr) {
      const a = arr.slice()
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        const t = a[i]
        a[i] = a[j]
        a[j] = t
      }
      return a
    }

    function pickNOther(n, excludeKey) {
      const pool = countries.filter(c => c.key !== excludeKey)
      return shuffle(pool).slice(0, n)
    }

    function buildPracticeDeck() {
      const arr = []
      for (const k of misses) {
        const c = countryByKey.get(k)
        if (c) arr.push(c)
      }
      deck = shuffle(arr)
      deckIndex = 0
    }


    function clearMapLayer() {
      try {
        const fbuf = (typeof kbGetFrontBuffer === "function") ? kbGetFrontBuffer() : null
        if (fbuf && fbuf.map === map) {
          try { kbClearLayerOn(fbuf) } catch (e) {}
          try { currentLayer = null } catch (e) {}
          return
        }
      } catch (e) {}

      if (currentLayer) {
        try { map.removeLayer(currentLayer) } catch (e) {}
        currentLayer = null
      }
    }

    function setCountryOnMap(feature) {
      clearMapLayer()
      try {
        const nm = feature && feature.properties ? (feature.properties.name || feature.properties.ADMIN || feature.properties.admin || feature.properties.NAME || "") : ""
        kbDbg("setCountryOnMap", { name: nm, now: kbMapState() })
      } catch (e) {}

      currentLayer = L.geoJSON(feature, { style: ORANGE_STYLE }).addTo(map)
      currentLayer.bringToFront()

      try {
        const fbuf = (typeof kbGetFrontBuffer === "function") ? kbGetFrontBuffer() : null
        if (fbuf && fbuf.map === map) fbuf.currentLayer = currentLayer
      } catch (e) {}

      const b = currentLayer.getBounds()
      if (!b || !b.isValid()) return


      // If the map is hidden (for example, the redemption store is open), defer fitBounds
      if (mapDiv && (mapDiv.offsetWidth === 0 || mapDiv.offsetHeight === 0)) {
        pendingBounds = b
        try { kbDbg("setCountryOnMap defer pendingBounds", kbMapState()) } catch (e) {}
        return
      }
      pendingBounds = null

      const size = map.getSize()
      const padY = Math.round(size.y * 0.25)
      const padX = Math.round(size.x * 0.10)

      try {
        kbDbg("setCountryOnMap fitBounds", {
          now: kbMapState(),
          padX: padX,
          padY: padY,
          bounds: (function(){ try { const sw = b.getSouthWest(); const ne = b.getNorthEast(); return { sw: { lat:+sw.lat.toFixed(5), lng:+sw.lng.toFixed(5) }, ne: { lat:+ne.lat.toFixed(5), lng:+ne.lng.toFixed(5) } } } catch(e){ return null } })()
        })
      } catch (e) {}
      try { kbZoomOutAfterNextMoveEnd(map, KB_ZOOM_OUT_AFTER_FIT) } catch (e) {}
      map.fitBounds(b, {
        paddingTopLeft: [padX, padY],
        paddingBottomRight: [padX, padY],
        maxZoom: 13,
        animate: false
      })
      try { setTimeout(() => kbHealTiles("afterFitBounds"), 0) } catch (e) {}
    }

    function fmtParentU(u) {
  return fmtWalletMin2U(u)
}
    function fmtSponsorU(u) {
  return fmtWalletMin2U(u)
}

    function fmtOtherU(u) {
  return fmtWalletMin2U(u)
}

    
function fmtFlow(u, decimals) {
  return fmtUnitsFlex(u)
}

    function fmtMin2Max5(x) {
      const v = Number(x)
      if (!Number.isFinite(v) || v <= 0) return "0.00"
      const parts = v.toFixed(5).split(".")
      let frac = parts[1].replace(/0+$/, "")
      if (frac.length < 2) frac = frac.padEnd(2, "0")
      return parts[0] + "." + frac
    }

// Format an internal-units value (SCALE = 1e9) with comma separators and minimal decimals.
// No rounding, no extra trailing zeros.
function fmtUnitsTrimU(u) {
  const x = Number(u)
  if (!Number.isFinite(x) || x <= 0) return "0.00"

  const intPart = Math.floor(x / SCALE)
  let fracUnits = Math.floor(x % SCALE)

  const intStr = String(intPart).replace(/\B(?=(\d{3})+(?!\d))/g, ",")

  if (!fracUnits) return intStr

  let frac = String(fracUnits).padStart(9, "0")
  frac = frac.replace(/0+$/, "")
  if (!frac) return intStr

  return intStr + "." + frac
}

// Combined Parent + Sponsors flow per correct answer, returned in internal units.
// We keep full internal precision (up to 9 decimals) and avoid rounding.
function spigotFlowRateU() {
  const parentU = Number(flowU)
  if (!Number.isFinite(parentU) || parentU <= 0) return 0

  let sponsorAddU = 0
  const m = Number(sponsorMatch)
  const sponsorWalletU = Number(sponsorU)

  if (Number.isFinite(sponsorWalletU) && sponsorWalletU > 0 && Number.isFinite(m) && m > 0) {
    // Convert parentU / m into units, truncating (not rounding).
    sponsorAddU = Math.trunc(parentU / m)
    if (sponsorAddU > sponsorWalletU) sponsorAddU = sponsorWalletU
    if (sponsorAddU < 0) sponsorAddU = 0
  }

  return parentU + sponsorAddU
}


    function sponsorFlowRateU() {
  // Sponsors pay a rate derived from the parent flow and the match ratio.
  // Returned in internal units, truncated, never rounded.
  if (Number(sponsorU) <= 0) return 0

  const m = Number(sponsorMatch)
  if (!Number.isFinite(m) || m <= 0) return 0

  let u = Math.trunc(Number(flowU) / m)

  const sU = Number(sponsorU)
  if (!Number.isFinite(sU) || sU <= 0) return 0

  if (u > sU) u = sU
  if (u < 0) u = 0

  return u
}

function fmtSponsorFlowRate() {
  return fmtWalletMin2U(sponsorFlowRateU())
}

function spigotFlowRateK() {
  // Combined Parent + Sponsors flow per correct answer, in K-Bucks.
  const parentK = Number(flowU) / SCALE
  if (!Number.isFinite(parentK) || parentK <= 0) return 0

  let sponsorK = 0
  const m = Number(sponsorMatch)
  const sponsorWalletK = Number(sponsorU) / SCALE

  if (Number.isFinite(sponsorWalletK) && sponsorWalletK > 0 && Number.isFinite(m) && m > 0) {
    sponsorK = parentK / m
    if (sponsorK > sponsorWalletK) sponsorK = sponsorWalletK
  }

  return parentK + sponsorK
}

function fmtSpigotFlowRate() {
  return fmtWalletMin2U(spigotFlowRateU())
}

function spigotKbucksPerHourU() {
  // Estimate: flow per answer * (193 questions * 3600 sec/hour) / (1158 sec per full game) = flow * 600.
  return Math.trunc(spigotFlowRateU() * 600)
}

function fmtSpigotKbucksPerHour() {
  return fmtWalletMin2U(spigotKbucksPerHourU())
}



    function toUnits(val) {
      const raw = String(val == null ? "" : val)
      const cleaned = raw.replace(/,/g, "").trim()
      const x = Number(cleaned)
      if (!Number.isFinite(x)) return 0
      return Math.max(0, Math.round(x * SCALE))
    }

// Parse a money input string into internal units, truncating (not rounding) to 2 decimals.
function toMoneyUnits(val) {
  const raw0 = String(val == null ? "" : val)
  const cleaned = raw0.replace(/,/g, "").trim()
  if (!cleaned) return 0

  let sign = 1
  let s = cleaned
  if (s[0] === "-") { sign = -1; s = s.slice(1) }
  if (s[0] === "+") { s = s.slice(1) }

  const parts = s.split(".")
  const intStr = parts[0] || "0"
  if (!/^[0-9]+$/.test(intStr)) {
    const x = Number(cleaned)
    if (!Number.isFinite(x)) return 0
    const truncated = Math.trunc(x * 100) / 100
    return Math.max(0, Math.trunc(truncated * SCALE))
  }

  let frac = parts.length > 1 ? parts[1] : ""
  // Keep only digits, then keep at most 2, then pad to 2 for cents math.
  frac = String(frac).replace(/[^0-9]/g, "").slice(0, 2)
  while (frac.length < 2) frac += "0"

  const intPart = Number(intStr)
  const cents = Number(frac || "0")

  const units = sign * (intPart * SCALE + cents * (SCALE / 100))
  return Math.max(0, units)
}

// Parse a decimal string into internal units without rounding.
// Keeps up to 9 fractional digits (SCALE = 1e9). Extra digits are dropped.
function parseUnitsNoRound(val) {
  const raw0 = String(val == null ? "" : val)
  const cleaned = raw0.replace(/,/g, "").trim()
  if (!cleaned) return 0

  let s = cleaned
  let sign = 1
  if (s[0] === "-") { sign = -1; s = s.slice(1) }
  if (s[0] === "+") { s = s.slice(1) }

  const parts = s.split(".")
  const intStr = (parts[0] || "0").replace(/[^0-9]/g, "")
  let fracStr = parts.length > 1 ? parts[1] : ""
  fracStr = String(fracStr).replace(/[^0-9]/g, "")

  if (!intStr) return 0

  fracStr = fracStr.slice(0, 9)
  while (fracStr.length < 9) fracStr += "0"

  const intPart = Number(intStr)
  const fracPart = Number(fracStr)

  if (!Number.isFinite(intPart) || !Number.isFinite(fracPart)) return 0

  const u = sign * (intPart * SCALE + fracPart)
  return Math.max(0, u)
}

// Format internal units with comma separators and minimal decimals.
// No padding zeros, no rounding.
function fmtUnitsFlex(u) {
  const x = Number(u)
  if (!Number.isFinite(x) || x <= 0) return "0.00"

  const intPart = Math.floor(x / SCALE)
  let frac = String(Math.floor(x % SCALE)).padStart(9, "0")
  frac = frac.replace(/0+$/, "")

  const intStr = String(intPart).replace(/\B(?=(\d{3})+(?!\d))/g, ",")

  if (!frac) return intStr
  return intStr + "." + frac
}


// Format flow rate for the input box.
// At least 2 decimals, keep extra precision (up to 9 decimals), no rounding.
function fmtFlowInputU(u) {
  return fmtWalletMin2U(u)
}


    
function clampFlowRate() {
  if (!flowRateInput) return

  const raw = String(flowRateInput.value || "")
  let vU = parseUnitsNoRound(raw)
  if (vU < 0) vU = 0
  if (parentU <= 0) vU = 0

  flowU = vU
  flowRateInput.value = fmtFlowInputU(flowU)

  saveWallet()
  updateAccounts()
}

    function clampParentInput() {
      if (!parentInput) return
      const raw = String(parentInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      parentU = vU
      if (parentU <= 0) flowU = 0
      saveWallet()
      // Re-render flow after clamp
      if (flowRateInput) flowRateInput.value = fmtFlowInputU(flowU)
      updateAccounts()
      if (parentInput) parentInput.value = fmtParentU(parentU)}

    function clampSponsorInput() {
      if (!sponsorInput) return
      const raw = String(sponsorInput.value || "")
      let vU = toMoneyUnits(raw)
      if (vU < 0) vU = 0
      sponsorU = vU

      saveWallet()
      updateAccounts()
      if (sponsorInput && document.activeElement !== sponsorInput) sponsorInput.value = fmtSponsorU(sponsorU)
    }

            function clampSponsorMatch() {
      if (!sponsorMatchInput) return
      const raw = String(sponsorMatchInput.value || "").trim()
      let v = Number(raw)

      // Reject non-numeric or out of range. Keep last valid sponsorMatch.
      if (!Number.isFinite(v) || v < 3 || v > 7) {
        sponsorMatchInput.value = String(sponsorMatch)
        return
      }

      sponsorMatch = v

      // Keep whatever the user typed while focused. Otherwise show the numeric value.
      if (document.activeElement !== sponsorMatchInput) sponsorMatchInput.value = String(sponsorMatch)

      saveWallet()
      updateAccounts()
    }

    function formatScorePct(correct, total) {
      if (!total || total <= 0) return ""
      const pct = (correct / total) * 100
      const pct1 = Math.round(pct * 10) / 10
      const pctStr = (pct1 % 1 === 0) ? String(Math.round(pct1)) : String(pct1)
      return " (" + pctStr + "%)"
    }

    function updateScoreDisplay(finalMode) {
      if (progressEl) progressEl.classList.remove("kbFlexBreak")
      const total = (deck && deck.length) ? deck.length : (countries && countries.length ? countries.length : 0)

      if (mode === "practice") {
        setTimerVisible(false)
        if (progressEl) progressEl.classList.remove("kbFlexBreak")
        const b = total
        const a = Math.min(Math.max(deckIndex || 0, 0), b)
        if (progressEl) progressEl.textContent = "Misses: " + a + "/" + b
        if (statusEl) statusEl.textContent = ""
        return
      }

      setTimerVisible(true)

      if (progressEl) {
        const shown = Math.min(Math.max(rounds || 0, 0), total)
        progressEl.textContent = "Progress: " + shown + "/" + total + formatScorePct(shown, total)
      }

      if (finalMode) {
        statusEl.textContent = "Final score: " + correctCount + "/" + rounds + formatScorePct(correctCount, rounds)
        return
      }

      if (rounds <= 0) {
        statusEl.textContent = "Score: 0/0 (0%)"
        return
      }

      statusEl.textContent = "Score: " + correctCount + "/" + rounds + formatScorePct(correctCount, rounds)
    }


    function loadWallet() {
      try {
        const raw = localStorage.getItem("kbucks_wallet_v14")
        if (!raw) return
        const obj = JSON.parse(raw)
        if (Number.isFinite(obj.parentU)) parentU = obj.parentU
        if (Number.isFinite(obj.sponsorU)) sponsorU = obj.sponsorU
        if (Number.isFinite(obj.sponsorMatch)) sponsorMatch = Math.max(0, Number(obj.sponsorMatch))
        if (Number.isFinite(obj.kbGlobalChildU)) kbGlobalChildU = obj.kbGlobalChildU
        if (Number.isFinite(obj.devU)) devU = obj.devU
        if (Number.isFinite(obj.kbGlobalPlatformU)) kbGlobalPlatformU = obj.kbGlobalPlatformU
        if (Number.isFinite(obj.flowU)) flowU = obj.flowU
        if (Number.isFinite(obj.flowDec)) flowDec = obj.flowDec
        if (Number.isFinite(obj.devCarry)) devCarry = obj.devCarry
        if (Number.isFinite(obj.platCarry)) platCarry = obj.platCarry
      } catch (e) {}
    }

    function saveWallet() {
      try {
        localStorage.setItem("kbucks_wallet_v14", JSON.stringify({ parentU, kbGlobalChildU, devU, kbGlobalPlatformU, flowU, flowDec, devCarry, platCarry , sponsorU , sponsorMatch}))
      } catch (e) {}
    }

    function resetWalletDefaults() {
      // Defaults on every refresh
      parentU = 0 * SCALE
      sponsorU = 0
      sponsorMatch = 5
      kbGlobalChildU = 0
      devU = 0
      kbGlobalPlatformU = 0
      flowU = toUnits("0.00")  // 0.00
      flowDec = 2
      devCarry = 0
      platCarry = 0
      if (flowRateInput) flowRateInput.value = "0.00"
      if (parentInput) parentInput.value = "0.00"
      if (sponsorInput) sponsorInput.value = "0.00"
      if (sponsorMatchInput) sponsorMatchInput.value = "5"
      saveWallet()
      updateAccounts()
    }

    

    // Global helpers, shared across games
    function kbSponsorTagAlongU(parentUVal, sponsorUVal, matchRatioVal) {
      const p = Number(parentUVal) || 0
      const s = Number(sponsorUVal) || 0
      const r = Number(matchRatioVal) || 0
      if (p <= 0) return 0
      if (s <= 0) return 0
      if (r <= 0) return 0
      const want = Math.floor(p / r)
      return Math.min(s, want)
    }

    // "Child can earn (from Parent + Sponsors)" is global and sums both games.
    function kbAvailableToEarnForGameU(flowRateUVal, parentUVal, sponsorUVal, matchRatioVal) {
      const flow = Number(flowRateUVal) || 0
      if (!Number.isFinite(flow) || flow <= 0) return 0

      const p = Number(parentUVal) || 0
      if (!Number.isFinite(p) || p <= 0) return 0

      const sponsorAdd = kbSponsorTagAlongU(p, sponsorUVal, matchRatioVal)
      return (p + sponsorAdd) * 0.75
    }

    function kbAvailableToEarnNtcU() {
      return kbAvailableToEarnForGameU(flowU, parentU, sponsorU, sponsorMatch)
    }

    function kbAvailableToEarnBingoU() {
      return kbAvailableToEarnForGameU(kbBingoFlowU, kbBingoParentU, kbBingoSponsorU, kbBingoSponsorMatch)
    }

    function kbComputeAvailableToEarnU() {
      return kbAvailableToEarnNtcU() + kbAvailableToEarnBingoU()
    }
function kbUpdateGlobalBalances() {
      if (redeemBalanceEl) {
        redeemBalanceEl.textContent =
          "Available for the Child to redeem: " + "KBU " + fmtWalletMin2U(kbGlobalChildU)
      }
      if (earnBalanceEl) {
        earnBalanceEl.textContent =
          "Available for the Child to earn (from Parent + Education Sponsors): " + "KBU " + fmtWalletMin2U(kbComputeAvailableToEarnU())
      }
    }

function updateAccounts() {
      if (parentU <= 0) flowU = 0
      if (parentInput && document.activeElement !== parentInput) parentInput.value = fmtParentU(parentU)
      if (sponsorInput && document.activeElement !== sponsorInput) sponsorInput.value = fmtSponsorU(sponsorU)

      if (flowRateInput && document.activeElement !== flowRateInput) flowRateInput.value = fmtFlowInputU(flowU)
      if (sponsorMatchInput && document.activeElement !== sponsorMatchInput) sponsorMatchInput.value = String(sponsorMatch)
      
      if (sponsorFlowRateOut) sponsorFlowRateOut.textContent = fmtSponsorFlowRate()
      if (spigotFlowRateOut) spigotFlowRateOut.textContent = fmtSpigotFlowRate()
      if (spigotKbucksPerHourOut) spigotKbucksPerHourOut.textContent = fmtSpigotKbucksPerHour()
      if (childAcctEl) childAcctEl.textContent = "KBU balance: " + fmtWalletMin2U(kbGlobalChildU)
      if (devAcctEl) devAcctEl.textContent = "KBU balance: " + fmtWalletMin2U(devU)
      if (platformAcctEl) platformAcctEl.textContent = "KBU balance: " + fmtWalletMin2U(kbGlobalPlatformU)
      // Empty-wallet highlight disabled for now
      // if (parentInput) parentInput.classList.toggle("emptyWallet", parentU <= 0)
      // if (sponsorInput) sponsorInput.classList.toggle("emptyWallet", sponsorU <= 0)
      kbUpdateGlobalBalances()
      syncSpigotPaneSize()


    }
        // REDEMPTION_STORE_START
        const STORE_ITEMS = [
              { name: "Plastic Spider Ring", brand: "Generic", cost: 0.05, image: "plastic_spider_ring.jpg", rating: 4.5, reviews: "1.2M" },
              { name: "STAEDTLER Eraser", brand: "STAEDTLER", cost: 0.10, image: "eraser.png", rating: 4.9, reviews: "123.7K" },
              { name: "Baskin-Robbins Gift Card", brand: "Baskin-Robbins", cost: 25.00, image: "baskin_robbins_gift_card.jpg", rating: 3.2, reviews: "46.9K" },
              { name: "UGG Classic Boots", brand: "UGG", cost: 199.00, image: "ugg_boots.jpg", rating: 4.1, reviews: "23.8K" },
              { name: "PlayStation 5 Digital", brand: "Sony", cost: 399.00, image: "ps5_digital.jpg", rating: 4.7, reviews: "36.1K" },
              { name: "iPhone 17", brand: "Apple", cost: 799.00, image: "iphone_17.png", rating: 4.9, reviews: "18.5K" }
            ]

// REDEMPTION_STORE_END
            // KB_STORE_MANIFEST_EXPECTED: count=6, minCost=0.05, maxCost=799.00, hash=80dbce7d
            const KB_STORE_MANIFEST_EXPECTED = {
              count: 6,
              minCost: "0.05",
              maxCost: "799.00",
              hash: "80dbce7d"
            }

            function kbFNV1a32(str) {
              let h = 0x811c9dc5
              for (let i = 0; i < str.length; i++) {
                h ^= (str.charCodeAt(i) & 0xff)
                h = Math.imul(h, 0x01000193) >>> 0
              }
              return ("00000000" + h.toString(16)).slice(-8)
            }

            function kbNormalizeStore(items) {
              return (items || []).map(it => {
                const name = String(it && it.name || "").trim()
                const image = String(it && it.image || "").trim()
                const costNum = Number(it && it.cost)
                const cost = Number.isFinite(costNum) ? costNum.toFixed(2) : ""
                return { name, cost, image }
              })
            }

            function kbComputeStoreHash(items) {
              const normalized = kbNormalizeStore(items)
              const json = JSON.stringify(normalized)
              return kbFNV1a32(json)
            }

            function kbVerifyStoreManifest() {
              try {
                const normalized = kbNormalizeStore(STORE_ITEMS)
                const count = normalized.length
                const costs = normalized.map(x => Number(x.cost)).filter(Number.isFinite)
                const minCost = costs.length ? Math.min(...costs).toFixed(2) : ""
                const maxCost = costs.length ? Math.max(...costs).toFixed(2) : ""
                const hash = kbComputeStoreHash(STORE_ITEMS)

                const exp = KB_STORE_MANIFEST_EXPECTED
                const problems = []
                if (count !== exp.count) problems.push(`count expected ${exp.count} got ${count}`)
                if (minCost !== exp.minCost) problems.push(`minCost expected ${exp.minCost} got ${minCost}`)
                if (maxCost !== exp.maxCost) problems.push(`maxCost expected ${exp.maxCost} got ${maxCost}`)
                if (hash !== exp.hash) problems.push(`hash expected ${exp.hash} got ${hash}`)

                if (problems.length) {
                  console.warn("[K-Bucks] Redemption store manifest changed:", problems.join(", "))
                }
              } catch (e) {}
            }

            function kbWarnIfStoreNotSorted() {
              try {
                for (let i = 1; i < STORE_ITEMS.length; i++) {
                  if (Number(STORE_ITEMS[i].cost) < Number(STORE_ITEMS[i - 1].cost)) {
                    console.warn("[K-Bucks] Redemption store is not sorted by increasing KB price at index", i)
                    return
                  }
                }
              } catch (e) {}
            }

            function kbWarnIfStoreHasDuplicates() {
              try {
                const seen = new Set()
                for (const it of STORE_ITEMS) {
                  const key = String(it && it.name || "").trim().toLowerCase()
                  if (!key) continue
                  if (seen.has(key)) {
                    console.warn("[K-Bucks] Duplicate redemption store item name detected:", it.name)
                    return
                  }
                  seen.add(key)
                }
              } catch (e) {}
            }

            function kbWarnIfBannedStoreItems() {
              try {
                const bannedSubstrings = ["lululemon gift card", "lululemon"]
                for (const it of STORE_ITEMS) {
                  const name = String(it && it.name || "").toLowerCase()
                  for (const bad of bannedSubstrings) {
                    if (name.includes(bad)) {
                      console.warn("[K-Bucks] Banned redemption store item detected:", it.name)
                      return
                    }
                  }
                }
              } catch (e) {}
            }

            (function kbRunGuardrailsOnce() {
              kbVerifyStoreManifest()
              kbWarnIfStoreNotSorted()
              kbWarnIfStoreHasDuplicates()
              kbWarnIfBannedStoreItems()
            })()
function renderStore() {
      if (!storeEl) return

      const items = Array.isArray(STORE_ITEMS) ? STORE_ITEMS : []
      storeEl.innerHTML = ""
      if (!items.length) {
        kbRenderListState(storeEl, "No items yet.")
        return
      }

      const wrap = document.createElement("div")
      wrap.className = "storeList"

      for (const it of items) {
        const row = document.createElement("div")
        row.className = "storeItem"

        const left = document.createElement("div")
        left.className = "storeLeft"

        if (it.image) {
          const img = document.createElement("img")
          img.className = "storeThumb"
          img.alt = it.name
          img.loading = "lazy"
          img.src = it.image
          left.appendChild(img)
        }

        const meta = document.createElement("div")
        meta.className = "storeMeta"

        const nameEl = document.createElement("div")
        nameEl.innerHTML = "<strong>" + it.name + "</strong>"
        meta.appendChild(nameEl)


        // Brand line (Screen 2)
        if (it && it.brand) {
          const brand = document.createElement("div")
          brand.className = "storeBrand"
          brand.textContent = "Brand: " + String(it.brand)
          meta.appendChild(brand)
        }
        // Rating line (Screen 2)
        if (Number.isFinite(Number(it && it.rating))) {
          const rating = document.createElement("div")
          rating.className = "storeRating"

          const v = Number(it.rating)
          const pct = Math.max(0, Math.min(100, (v / 5) * 100))
          const count = String(it && it.reviews || "").trim()

          rating.innerHTML =
            '<span class="ratingValue">' + v.toFixed(1) + '</span>' +
            '<span class="ratingStarsBox"><span class="starsBase">★★★★★</span><span class="starsFill" style="width:' + pct.toFixed(0) + '%;">★★★★★</span></span>' +
            '<span class="ratingCaret">▾</span>' +
            (count ? '<span class="ratingCount">(' + count + ')</span>' : '')

          meta.appendChild(rating)
        }


        const price = document.createElement("div")
        const costStr = fmtWalletMin2U(toMoneyUnits(it.cost))
        price.className = "storePrice"
        price.textContent = "KBU " + costStr
        meta.appendChild(price)

        left.appendChild(meta)

        const btn = document.createElement("button")
        btn.type = "button"
        btn.textContent = "Redeem"

        const costU = toUnits(it.cost)
        btn.disabled = kbGlobalChildU < costU

        btn.addEventListener("click", () => {
          if (btn.disabled) return

          kbGlobalChildU = Math.max(0, kbGlobalChildU - costU)
          saveWallet()
          updateAccounts()
          renderStore()

          const msg = "Redeemed " + it.name + " for KBU " + costStr
          if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = msg
          if (messageEl) messageEl.textContent = msg
          try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_redeem", { kb_item: it.name, kb_item_cost_kbu: Number(costStr) }) } catch (e) {}
        })

        row.appendChild(left)
        row.appendChild(btn)
        wrap.appendChild(row)
      }

      storeEl.appendChild(wrap)
    }
    const EDU_ITEMS = [
      { key: "ntc", name: "Name That Country", cost: 0.10, image: "name_that_country.png" },
      { key: "mm", name: "Multiply Two Numbers", cost: 0.05, image: "multiplication_table.png" }
    ]

    function renderEdu() {
      if (!eduListEl) return
      // Clear any previous render
      eduListEl.innerHTML = ""

      const items = Array.isArray(EDU_ITEMS) ? EDU_ITEMS : []
      if (!items.length) {
        kbRenderListState(eduListEl, "No items yet.")
        return
      }

      const wrap = document.createElement("div")
      wrap.className = "storeList"

      for (const it of items) {
        const row = document.createElement("div")
        row.className = "storeItem eduItem"

        const left = document.createElement("div")
        left.className = "storeLeft eduLeft"

        if (it.image) {
          const img = document.createElement("img")
          img.className = "storeThumb"
          img.alt = it.name
          img.loading = "lazy"
          img.src = it.image
          left.appendChild(img)
        }

        const mid = document.createElement("div")
        mid.className = "eduMid"

        const meta = document.createElement("div")
        meta.className = "storeMeta"

        const nameEl = document.createElement("div")
        nameEl.innerHTML = "<strong>" + it.name + "</strong>"
        nameEl.className = "eduRow1Left"
        meta.appendChild(nameEl)
        // Rating line (Screen 1)
        if (it.key === "ntc" || it.key === "mm") {
          // Content developer line (Screen 1) between title and rating.
          const author = document.createElement("div")
          author.className = "storeRating eduRow2Left"
          author.textContent = (it.key === "ntc") ? "by Geography Ninjas (Developer)" : "by Math Magicians (Developer)"
          meta.appendChild(author)

          const rating = document.createElement("div")
        rating.className = "storeRating storeStarsLine eduRow3Left"

          if (it.key === "ntc") {
            rating.innerHTML =
              '<span class="ratingValue">4.8</span>' +
              '<span class="ratingStars">★★★★★</span>' +
              '<span class="ratingCaret">▾</span>' +
              '<span class="ratingCount">(53.3K)</span>'
          } else {
            rating.innerHTML =
              '<span class="ratingValue">4.5</span>' +
              '<span class="ratingStarsBox"><span class="starsBase">★★★★★</span><span class="starsFill" style="width:90%;">★★★★★</span></span>' +
              '<span class="ratingCaret">▾</span>' +
              '<span class="ratingCount">(8.6K)</span>'
          }

          meta.appendChild(rating)
        }

        // Grade line (Screen 1) placed below rating.
        if (it.key === "mm" || it.key === "ntc") {
          const grade = document.createElement("div")
          grade.className = "storeRating storeGradeLine eduRow4Left"
          grade.textContent = (it.key === "mm") ? "Math: Grade 3" : "Geography: Grade 7"
          meta.appendChild(grade)
        }

        const fundsCol = document.createElement("div")
        fundsCol.className = "eduFundsCol"

        // Funds lines (Screen 1) replace the single KBU cost for the two games.
        if (it.key === "ntc") {



          const BLANK = "\u00A0"

          const parentStr = fmtOtherU(parentU)

          const sponsorStr = fmtOtherU(sponsorU)

          const availStr = fmtOtherU(kbAvailableToEarnNtcU())

          const hideFunds = parentStr === "0.00" && sponsorStr === "0.00" && availStr === "0.00"


          const kb = document.createElement("div")

          kb.className = "eduFundsTitle eduRow1Right"

          kb.textContent = hideFunds ? BLANK : "KBU"

          fundsCol.appendChild(kb)


          const p = document.createElement("div")

          p.className = "eduFundsLine eduRow2Right"

          p.textContent = hideFunds ? BLANK : ("Parent: " + parentStr)

          fundsCol.appendChild(p)


          const s = document.createElement("div")

          s.className = "eduFundsLine eduRow3Right"

          s.textContent = hideFunds ? BLANK : ("Sponsors: " + sponsorStr)

          fundsCol.appendChild(s)


          const a = document.createElement("div")

          a.className = "eduFundsLine eduRow4Right"

          a.textContent = hideFunds ? BLANK : ("Available to earn: " + availStr)

          fundsCol.appendChild(a)        } else if (it.key === "mm") {



          const BLANK = "\u00A0"

          const parentStr = fmtOtherU(kbBingoParentU)

          const sponsorStr = fmtOtherU(kbBingoSponsorU)

          const availStr = fmtOtherU(kbAvailableToEarnBingoU())

          const hideFunds = parentStr === "0.00" && sponsorStr === "0.00" && availStr === "0.00"


          const kb = document.createElement("div")

          kb.className = "eduFundsTitle eduRow1Right"

          kb.textContent = hideFunds ? BLANK : "KBU"

          fundsCol.appendChild(kb)


          const p = document.createElement("div")

          p.className = "eduFundsLine eduRow2Right"

          p.textContent = hideFunds ? BLANK : ("Parent: " + parentStr)

          fundsCol.appendChild(p)


          const s = document.createElement("div")

          s.className = "eduFundsLine eduRow3Right"

          s.textContent = hideFunds ? BLANK : ("Sponsors: " + sponsorStr)

          fundsCol.appendChild(s)


          const a = document.createElement("div")

          a.className = "eduFundsLine eduRow4Right"

          a.textContent = hideFunds ? BLANK : ("Available to earn: " + availStr)

          fundsCol.appendChild(a)        } else {
          const price = document.createElement("div")
          const costStr = fmtWalletMin2U(toMoneyUnits(it.cost))
          price.className = "storeCost"
          price.textContent = "KBU " + costStr
          meta.appendChild(price)
        }

        mid.appendChild(meta)

        mid.appendChild(fundsCol)
        left.appendChild(mid)

        const btn = document.createElement("button")
        btn.type = "button"
        btn.textContent = "Play"

        btn.addEventListener("click", () => {
          if (it.key === "ntc") {
            // Start a new Name That Country game (Screen 3)
            showGameScreen()
            try { kbEnsureLeafletMap("play-ntc") } catch (e) {}
            // Wait for the game screen to be visible and Leaflet to have a stable size.
            requestAnimationFrame(() => {
              try { syncMapHeight() } catch (e) {}
              try { if (map && map.invalidateSize) map.invalidateSize({ animate: false, pan: false }) } catch (e) {}
              try { kbNormalizeMapView("play-ntc-after-invalidate") } catch (e) {}
              requestAnimationFrame(() => {
                try { syncMapHeight() } catch (e) {}
                try { if (map && map.invalidateSize) map.invalidateSize({ animate: false, pan: false }) } catch (e) {}
                try { kbNormalizeMapView("play-ntc-before-startNewGame") } catch (e) {}
                // Always start a fresh game on entry.
                startNewGame()
              })
            })
          } else {
            // Multiply Two Numbers (Screen 4)
            showBingoScreen()
          }
        })

        row.appendChild(left)
        row.appendChild(btn)
        wrap.appendChild(row)
      }

      eduListEl.appendChild(wrap)
    }


    function openRedeem() {
  if (!redeemPane) return
  if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = ""
  updateAccounts()
  if (mode === "normal" && !gameComplete) pauseTimer()
  renderStore()
  syncMapHeight()
  showStoreScreen()
}

function closeRedeem() {
  if (!redeemPane) return
  if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = ""
  showEduScreen()
}

function openStoreFromEdu() {
  if (!redeemPane) return
  if (redeemPaneMessageEl) redeemPaneMessageEl.textContent = ""
  updateAccounts()
  renderStore()
  showStoreScreen()
}

function quitGameToEdu() {
  if (mode === "normal" && !gameComplete) pauseTimer()
  showEduScreen()
}


    function toggleRedeem() {
      if (!redeemPane) return
      if (currentScreen === "store") closeRedeem()
      else openRedeem()
    }


    function syncMapHeight() {
      if (!mapDiv) return
      const slot = mapSlotEl || document.getElementById("mapSlot")
      const h = slot ? slot.clientHeight : (sideEl ? sideEl.offsetHeight : 0)
      try { kbDbg("syncMapHeight h", { h: h, now: kbMapState() }) } catch (e) {}
      if (!h || h <= 0) return

      const desired = h + "px"
      const seq = (map && map._kbSeq) ? map._kbSeq : 0
      const forceForNewMap = seq && window.kbLastSyncMapSeq !== seq

      // Only touch layout, and invalidate Leaflet, when the height actually changes,
      // or when the Leaflet map was just recreated.
      if (window.kbLastSyncMapH === desired && !forceForNewMap) return
      window.kbLastSyncMapH = desired
      if (seq) window.kbLastSyncMapSeq = seq

      mapDiv.style.height = desired

      try {
        // Avoid panning during invalidate, which can interact badly with an in-flight fitBounds.
        if (map && map.invalidateSize) {
          try { map.invalidateSize({ animate: false, pan: false }) } catch (e) { map.invalidateSize() }
        }
      } catch (e) {}
      try {
        const backBuf = kbGetBackBuffer()
        if (backBuf && backBuf.map && backBuf.map.invalidateSize) {
          try { backBuf.map.invalidateSize({ animate: false, pan: false }) } catch (e) { backBuf.map.invalidateSize() }
        }
      } catch (e) {}
      try { kbDbg("syncMapHeight invalidateSize", kbMapState()) } catch (e) {}
    }

    function resetUIForNewQuestion() {
      answersEl.innerHTML = ""
      if (messageEl) messageEl.textContent = ""
      nextBtn.disabled = true
      locked = false
      try { kbUpdateNextBtnEnabled() } catch (e) {}
    }

    // Double-buffer prebuild state for Name That Country
    let kbPrebuildJobId = 0
    let kbPrebuilt = null
    let kbPrebuildReady = true

    function kbResetPrebuild(reason) {
      kbPrebuildJobId += 1
      kbPrebuilt = null
      kbPrebuildReady = true
      try { kbUpdateNextBtnEnabled() } catch (e) {}
      try { kbDbg("resetPrebuild", { reason: reason }) } catch (e) {}
    }

    function kbUpdateNextBtnEnabled() {
      if (!nextBtn) return
      // Next question is enabled immediately after an answer is selected.
      // We still prebuild the next map in the background, but we do not gate the button on prebuild readiness.
      if (!locked) {
        nextBtn.disabled = true
        return
      }
      nextBtn.disabled = false
    }

    function kbIsMapVisibleForPrebuild() {
      try {
        if (!mapDiv) return false
        return !(mapDiv.offsetWidth === 0 || mapDiv.offsetHeight === 0)
      } catch (e) {
        return false
      }
    }

    function kbClearLayerOn(buf) {
      try {
        if (buf && buf.map && buf.currentLayer) {
          buf.map.removeLayer(buf.currentLayer)
        }
      } catch (e) {}
      try { if (buf) buf.currentLayer = null } catch (e) {}
    }

    function kbSetCountryOnBuffer(buf, feature) {
      if (!buf || !buf.map) return null
      kbClearLayerOn(buf)
      try {
        buf.currentLayer = L.geoJSON(feature, { style: ORANGE_STYLE }).addTo(buf.map)
        try { buf.currentLayer.bringToFront() } catch (e) {}
      } catch (e) {
        buf.currentLayer = null
      }
      return buf.currentLayer
    }

    function kbFitBoundsOnBuffer(buf, layer) {
      try {
        if (!buf || !buf.map || !layer) return
        const b = layer.getBounds()
        if (!b || !b.isValid()) return

        const size = buf.map.getSize()
        const padY = Math.round(size.y * 0.25)
        const padX = Math.round(size.x * 0.10)

        try { kbZoomOutAfterNextMoveEnd(buf.map, KB_ZOOM_OUT_AFTER_FIT) } catch (e) {}
        buf.map.fitBounds(b, {
          paddingTopLeft: [padX, padY],
          paddingBottomRight: [padX, padY],
          maxZoom: 13,
          animate: false
        })
      } catch (e) {}
    }

    function kbStartPrebuildForIndex(nextIndex, reason) {
      if (mode !== "normal" && mode !== "practice") return
      if (!deck || nextIndex == null || nextIndex >= deck.length) {
        kbPrebuildReady = true
        kbPrebuilt = null
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      kbPrebuildJobId += 1
      const jobId = kbPrebuildJobId

      const pick = deck[nextIndex]
      if (!pick) {
        kbPrebuildReady = true
        kbPrebuilt = null
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      kbPrebuilt = { index: nextIndex, key: pick.key }
      kbPrebuildReady = false
      try { kbUpdateNextBtnEnabled() } catch (e) {}
      try { kbDbg("prebuild start", { reason: reason, nextIndex: nextIndex, key: pick.key }) } catch (e) {}

      try { kbEnsureLeafletMap("prebuild") } catch (e) {}

      const buf = kbGetBackBuffer()
      if (!buf || !buf.map) {
        kbPrebuildReady = true
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      if (!kbIsMapVisibleForPrebuild()) {
        kbPrebuildReady = true
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        return
      }

      // Build the next country's layer on the hidden buffer
      let layer = null
      try { layer = kbSetCountryOnBuffer(buf, pick.feature) } catch (e) {}
      try { kbFitBoundsOnBuffer(buf, layer) } catch (e) {}
      try { kbHealTilesOnBuffer(buf, "prebuild") } catch (e) {}

      let finished = false
      const finish = (why) => {
        if (finished) return
        finished = true
        if (jobId !== kbPrebuildJobId) return
        kbPrebuildReady = true
        try { kbUpdateNextBtnEnabled() } catch (e) {}
        try { kbDbg("prebuild ready", { why: why, nextIndex: nextIndex }) } catch (e) {}
      }

      try {
        if (buf.map && buf.map.once) {
          buf.map.once("moveend", () => {
            const moveEndAt = Date.now()
            let initial = null
            try {
              if (buf.tileLayer && typeof buf.tileLayer._tilesToLoad === "number") initial = buf.tileLayer._tilesToLoad
            } catch (e) {}

            const thrFor = (init) => Math.max(2, Math.ceil(init * 0.30))

            let tries = 0
            const poll = () => {
              if (finished) return
              if (jobId !== kbPrebuildJobId) return
              tries += 1

              let remaining = null
              try {
                if (buf.tileLayer && typeof buf.tileLayer._tilesToLoad === "number") remaining = buf.tileLayer._tilesToLoad
              } catch (e) {}

              if (remaining != null) {
                if (remaining <= 0) return finish("tiles ready")
                if (initial == null) initial = remaining
                if (initial != null && remaining <= thrFor(initial)) return finish("tiles soft ready")
              }

              if (tries < 10) setTimeout(poll, 80)
            }

            try {
              if (buf.tileLayer && buf.tileLayer.once) {
                buf.tileLayer.once("tileload", () => {
                  const delay = Math.max(120, 180 - (Date.now() - moveEndAt))
                  setTimeout(() => finish("first tile"), delay)
                })
                buf.tileLayer.once("load", () => finish("tileLayer load"))
              }
            } catch (e) {}

            setTimeout(poll, 60)

            // Short timeout after moveend so Next question does not wait for full tile completion.
            setTimeout(() => finish("timeout-after-moveend"), 650)
          })
        }
      } catch (e) {}

      // Safety timeout so we never deadlock the Next question button
      setTimeout(() => finish("timeout"), 1600)
    }


    function renderAnswers(options) {
      answersEl.innerHTML = ""

      for (const opt of options) {
        const li = document.createElement("li")
        const btn = document.createElement("button")
        btn.className = "ansBtn"
        btn.type = "button"

        const bullet = document.createElement("span")
        bullet.className = "bullet"
        bullet.textContent = "•"

        const label = document.createElement("span")
        label.className = "label"
        label.textContent = opt.displayName

        const mark = document.createElement("span")
        mark.className = "mark"
        mark.textContent = ""

        btn.appendChild(bullet)
        btn.appendChild(label)
        btn.appendChild(mark)

        btn.addEventListener("click", () => onGuess(opt.key, btn))

        li.appendChild(btn)
        answersEl.appendChild(li)
      }
    }

    function lockAnswers() {
      const allButtons = Array.from(document.querySelectorAll("#quizPane .ansBtn"))
      for (const b of allButtons) b.disabled = true
      return allButtons
    }

    function onGuess(chosenKey, chosenBtn) {
  if (locked) return
  if (!current) { locked = false; return }
  locked = true
  kbUpdateNextBtnEnabled()

  rounds += 1

  let kbTelemetryIsCorrect = false
  let kbTelemetryTotalPayU = 0
  let kbTelemetryParentPayU = 0
  let kbTelemetrySponsorPayU = 0

  const correctKey = current.key
  const correctDisplay = current.displayName
  const allButtons = lockAnswers()

  if (chosenKey === correctKey) {
    kbTelemetryIsCorrect = true
    correctCount += 1
    chosenBtn.classList.add("correct")
    const _mk = chosenBtn.querySelector(".mark"); if (_mk) _mk.textContent = "✓"

    if (mode === "normal") {
      // Reward payout on a correct answer is the sum of the parent and sponsor flow rates.
      // That sum is distributed 75% to Child, 12.5% to Developer, 12.5% to Platform.
      const parentFlowU = Math.min(flowU, parentU)
      const parentPayU = parentFlowU > 0 ? parentFlowU : 0

      let sponsorPayU = 0
      const m = Number(sponsorMatch)
      if (parentFlowU > 0 && Number.isFinite(m) && m > 0 && sponsorU > 0) {
        const sponsorFlowU = Math.floor(Number(parentFlowU) / m)
        if (sponsorFlowU > 0) sponsorPayU = Math.min(sponsorFlowU, sponsorU)
      }

      const totalPayU = parentPayU + sponsorPayU

      kbTelemetryParentPayU = parentPayU
      kbTelemetrySponsorPayU = sponsorPayU
      kbTelemetryTotalPayU = totalPayU

      if (totalPayU > 0) {
        // Split: 75% child, 12.5% content developer, 12.5% platform.
        // Use carry remainders (denominator 8) to avoid systematic rounding bias.
        const devNumer = totalPayU + devCarry
        const platNumer = totalPayU + platCarry

        const devAdd = Math.floor(devNumer / 8)
        const platAdd = Math.floor(platNumer / 8)

        devCarry = devNumer % 8
        platCarry = platNumer % 8

        const childAdd = totalPayU - devAdd - platAdd

        parentU -= parentPayU
        sponsorU -= sponsorPayU
        kbGlobalChildU += childAdd
        devU += devAdd
        kbGlobalPlatformU += platAdd

        saveWallet()
        clampFlowRate()
        updateAccounts()
      } else {
        if (messageEl) messageEl.textContent = ""
      }
    } else {
      // Practice misses mode, no money flows.
      if (messageEl) messageEl.textContent = ""
    }
  } else {
    chosenBtn.classList.add("wrong")
    const _mk2 = chosenBtn.querySelector(".mark"); if (_mk2) _mk2.textContent = "✕"

    const correctBtn = allButtons.find(b => { const _l = b.querySelector(".label"); return _l && _l.textContent === correctDisplay })
    if (correctBtn) {
      correctBtn.classList.add("correct")
      const _mk3 = correctBtn.querySelector(".mark"); if (_mk3) _mk3.textContent = "✓"
    }

    if (mode === "normal") {
      // Record a miss (unique countries) for Practice misses mode.
      if (!missesSet.has(correctKey)) {
        missesSet.add(correctKey)
        misses.push(correctKey)
      }
      if (quitBtn) quitBtn.disabled = misses.length === 0
    }
  }

  if (mode === "practice") {
    nextBtn.textContent = "Next question"
    updateScoreDisplay(false)
  } else {
    const done = rounds >= deck.length
    if (done) {
      gameComplete = true
      stopTimer()
      nextBtn.textContent = "Game over"
      nextBtn.disabled = true
      updateScoreDisplay(true)
    } else {
      nextBtn.textContent = "Next question"
      updateScoreDisplay(false)
    }
  }

  try {
    if (window.KB_TELEMETRY) {
      const toKbu = (u) => {
        const n = Number(u) || 0
        return n > 0 ? (n / SCALE) : 0
      }
      window.KB_TELEMETRY.event("kb_answer", {
        kb_game: "name_that_country",
        kb_mode: mode,
        kb_correct: kbTelemetryIsCorrect ? 1 : 0,
        kb_round: rounds,
        kb_total_pay_kbu: toKbu(kbTelemetryTotalPayU),
        kb_parent_pay_kbu: toKbu(kbTelemetryParentPayU),
        kb_sponsor_pay_kbu: toKbu(kbTelemetrySponsorPayU)
      })
    }
  } catch (e) {}

  syncMapHeight()
}



    function nextQuestion() {
      try { kbDbg("nextQuestion", kbMapState()) } catch (e) {}

  resetUIForNewQuestion()

  if (mode === "practice") {
    // Practice misses: infinite loop over missed countries.
    if (misses.length === 0) {
      if (messageEl) messageEl.textContent = "No misses yet. Play a New game first."
      nextBtn.disabled = true
      if (quitBtn) quitBtn.disabled = true
      syncMapHeight()
      return
    }

    if (!deck || deck.length === 0 || deckIndex >= deck.length) {
      buildPracticeDeck()
    }

    const currentIndex = deckIndex
    const pickOne = deck[deckIndex]
    deckIndex += 1
    current = pickOne

    let usedPrebuilt = false
    try {
      if (kbPrebuildReady && kbPrebuilt && kbPrebuilt.index === currentIndex && kbPrebuilt.key === pickOne.key) {
        kbSwapMapBuffers("use-prebuilt")
        usedPrebuilt = true
        kbPrebuilt = null
        kbPrebuildReady = true
      }
    } catch (e) {}

    if (!usedPrebuilt) {
      setCountryOnMap(pickOne.feature)

    try { kbResetPrebuild("practice") } catch (e) {}
    }

    const others = pickNOther(9, pickOne.key)
    const options = shuffle([pickOne, ...others])

    renderAnswers(options)

    try { kbStartPrebuildForIndex(deckIndex, "after-render") } catch (e) {}

    nextBtn.textContent = "Next question"
    updateScoreDisplay(false)

    syncMapHeight()
    return
  }

  if (gameComplete) return

  if (deckIndex >= deck.length) {
    gameComplete = true
    nextBtn.textContent = "Game over"
    nextBtn.disabled = true
    updateScoreDisplay(true)
    syncMapHeight()
    return
  }

  const currentIndex = deckIndex
  const pickOne = deck[deckIndex]
  deckIndex += 1
  current = pickOne

  let usedPrebuilt = false
  try {
    if (kbPrebuildReady && kbPrebuilt && kbPrebuilt.index === currentIndex && kbPrebuilt.key === pickOne.key) {
      kbSwapMapBuffers("use-prebuilt-normal")
      usedPrebuilt = true
      kbPrebuilt = null
      kbPrebuildReady = true
    }
  } catch (e) {}

  if (!usedPrebuilt) {
    setCountryOnMap(pickOne.feature)
  }

  const others = pickNOther(9, pickOne.key)
  const options = shuffle([pickOne, ...others])

  renderAnswers(options)
  updateScoreDisplay(false)

  try { kbStartPrebuildForIndex(deckIndex, "after-render-normal") } catch (e) {}

  syncMapHeight()
}




    function startNewGame() {
      try { kbNormalizeMapView("startNewGame") } catch (e) {}

      try { kbDbg("startNewGame", kbMapState()) } catch (e) {}

      overlay.classList.remove("show")

      rounds = 0
      correctCount = 0
      gameComplete = false

      mode = "normal"

      try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_game_start", { kb_game: "name_that_country" }) } catch (e) {}

      try { kbResetPrebuild("startNewGame") } catch (e) {}
      try { kbClearLayerOn(kbGetFrontBuffer()) } catch (e) {}
      try { kbClearLayerOn(kbGetBackBuffer()) } catch (e) {}

      setTimerVisible(true)
      resetAndStartTimer()
      misses = []
      missesSet = new Set()
      if (quitBtn) quitBtn.disabled = true

      deck = shuffle(countries)
      deckIndex = 0

      nextBtn.textContent = "Next question"
      updateScoreDisplay(false)

      updateAccounts()
      if (messageEl) messageEl.textContent = ""

      nextQuestion()
    }

    

function startPracticeMisses() {
  overlay.classList.remove("show")

  pauseTimer()
  setTimerVisible(false)

  if (misses.length === 0) {
    if (messageEl) messageEl.textContent = "No misses yet. Play a New game first."
    if (quitBtn) quitBtn.disabled = true
    return
  }

  mode = "practice"
  rounds = 0
  correctCount = 0
  gameComplete = false

  buildPracticeDeck()

      if (!deck || deck.length === 0) {
        if (messageEl) messageEl.textContent = "No missed countries could be loaded. Start a new game and miss a few questions first."
        nextBtn.disabled = true
        if (quitBtn) quitBtn.disabled = true
        return
      }

      nextBtn.textContent = "Next question"
  updateScoreDisplay(false)
  if (messageEl) messageEl.textContent = ""
  nextQuestion()
}

function quitGame() {
      overlay.classList.add("show")
      document.getElementById("finalText").textContent =
        "Final score: " + correctCount + "/" + rounds + "."
    }

    nextBtn.addEventListener("click", () => {
      try { if (window.KB_TELEMETRY) window.KB_TELEMETRY.event("kb_next_question_press", { kb_game: "name_that_country", kb_mode: mode }) } catch (e) {}
      if (gameComplete) return
      nextQuestion()
    })

    quitBtn.addEventListener("click", startPracticeMisses)
    if (startNewBtn) startNewBtn.addEventListener("click", () => {
      // Reset score and country deck, keep wallets and settings.
      startNewGame()
    })

    restartBtn.addEventListener("click", startNewGame)

    redeemBtn.addEventListener("click", quitGameToEdu)
    closeRedeemBtn.addEventListener("click", closeRedeem)
    if (openStoreBtn) openStoreBtn.addEventListener("click", openStoreFromEdu)
    if (flowRateInput) {
      flowRateInput.addEventListener("change", clampFlowRate)
      flowRateInput.addEventListener("blur", clampFlowRate)
    }
    // Parent wallet parsing should not run on each keystroke.
    // Commit when the user presses Enter or when the field loses focus.
    if (parentInput) {
      parentInput.addEventListener("blur", clampParentInput)
      parentInput.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return
        e.preventDefault()
        // Blur triggers clampParentInput, matching click-outside behavior.
        parentInput.blur()
      })
    }

    if (sponsorInput) {
      sponsorInput.addEventListener("change", clampSponsorInput)
      sponsorInput.addEventListener("blur", clampSponsorInput)
    }

    if (sponsorMatchInput) {
      sponsorMatchInput.addEventListener("change", clampSponsorMatch)


// When user presses Enter in any input, commit parsing (change) and then blur to apply formatting.
for (const el of document.querySelectorAll("input")) {
  el.addEventListener("keydown", (e) => {
    if (el === parentInput) return
    if (e.key !== "Enter") return
    e.preventDefault()
    el.dispatchEvent(new Event("change", { bubbles: true }))
    el.blur()
  })
}
      sponsorMatchInput.addEventListener("blur", clampSponsorMatch)
    }

    // Bingo (Screen 4) wallet controls.
    if (bingoFlowRateInput) {
      bingoFlowRateInput.addEventListener("change", kbBingoClampFlowRate)
      bingoFlowRateInput.addEventListener("blur", kbBingoClampFlowRate)
    }
    if (bingoParentInput) {
      bingoParentInput.addEventListener("blur", kbBingoClampParentInput)
      bingoParentInput.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return
        e.preventDefault()
        bingoParentInput.blur()
      })
    }
    if (bingoSponsorInput) {
      bingoSponsorInput.addEventListener("change", kbBingoClampSponsorInput)
      bingoSponsorInput.addEventListener("blur", kbBingoClampSponsorInput)
    }
    if (bingoSponsorMatchInput) {
      bingoSponsorMatchInput.addEventListener("change", kbBingoClampSponsorMatch)
      bingoSponsorMatchInput.addEventListener("blur", kbBingoClampSponsorMatch)
    }
    try { kbBingoUpdateAccounts() } catch (e) {}


    const ro = new ResizeObserver(() => syncMapHeight())
    ro.observe(sideEl)
    window.addEventListener("resize", () => syncMapHeight())

    async function loadCountries() {
      updateScoreDisplay(false)

      const [unRes, geoRes] = await Promise.all([
        fetch(UN_MEMBERS_URL),
        fetch("countries.geojson")
      ])

      if (!unRes.ok) throw new Error("Could not load map data. Please refresh the page.")
      if (!geoRes.ok) throw new Error("Could not load map data. Please refresh the page.")

      const unRaw = await unRes.json()
      const gj = await geoRes.json()

      const unArr = Array.isArray(unRaw) ? unRaw : []

      const unByA2 = new Map()
      const unByA3 = new Map()
      const unByCanonName = new Map()

      for (const x of unArr) {
        if (!x || (x.unMember !== true && String(x.cca3 || "").toUpperCase() !== "GNB")) continue

        const cca2 = String(x.cca2 || "").toUpperCase()
        const cca3 = String(x.cca3 || "").toUpperCase()
        const common = x.name && x.name.common ? String(x.name.common) : ""
        const official = x.name && x.name.official ? String(x.name.official) : ""

        const key = cca3 || cca2 || canon(common) || canon(official)
        const entry = { key, cca2, cca3, common, official }

        if (cca2) unByA2.set(cca2, entry)
        if (cca3) unByA3.set(cca3, entry)

        if (common) unByCanonName.set(canon(common), entry)
        if (official) unByCanonName.set(canon(official), entry)
      }

      const feats = (gj && gj.features) ? gj.features : []

      const matched = []
      for (const f of feats) {
        const props = f.properties || {}
        const name = geoName(props)
        if (!name) continue

        const iso2u = String(getISO2(props) || "").toUpperCase()
        const iso3u = String(getISO3(props) || "").toUpperCase()

        let entry = null

        if (iso3u && unByA3.has(iso3u)) entry = unByA3.get(iso3u)
        else if (iso2u && unByA2.has(iso2u)) entry = unByA2.get(iso2u)
        else {
          const cn = canon(name)
          if (unByCanonName.has(cn)) entry = unByCanonName.get(cn)
        }

        if (!entry) continue

        let displayName = entry.common || entry.official || name

        // Fix diacritics for consistent display
        if (normNameKey(displayName) === "sao tome and principe") displayName = "Sao Tome and Principe"

        matched.push({
          key: entry.key,
          displayName,
          feature: f
        })
      }

      const seen = new Set()
      countries = matched.filter(x => {
        if (!x.key) return false
        if (seen.has(x.key)) return false
        seen.add(x.key)
        return true
      })

      if (countries.length < 150) {
        throw new Error("UN filter left too few countries")
      }

// Build a lookup map so Practice misses can quickly map keys to country objects.
countryByKey = new Map()
for (const c of countries) countryByKey.set(c.key, c)

    }

    // Ensure Screen 1 content is rendered on initial load
    try { showEduScreen() } catch (e) {}

    loadCountries()
      .then(() => {
        resetWalletDefaults()
flowDec = 2
        if (flowRateInput) flowRateInput.value = fmtFlowInputU(flowU)
        clampFlowRate()
        updateAccounts()
        // Do not auto-start Name That Country on initial load.
        // The game starts when the user presses Play.
        syncMapHeight()
      })
      .catch(err => {
        const m = (err && err.message && String(err.message).includes("Could not load map data")) ? String(err.message) : "Could not load data. Please refresh."
        kbSetUnifiedLoadError(m)
        syncMapHeight()
      })
  
  
  
  
  
  
  
  
  
  </script>
</body>
</html>